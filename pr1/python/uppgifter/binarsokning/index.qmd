---
title: "Uppgifter: Bin칛rs칬kning"
format:
  html:
    fontsize: 1em
    css: style.css
---

# Bin칛rs칬kning i Python

## Exempel och uppgifter

### Beskrivning av algoritm

1. **F칬rst친 problemet**: Bin칛rs칬kning 칛r en effektiv algoritm f칬r att hitta ett specifikt element i en sorterad lista. Den fungerar genom att kontinuerligt dela listan i h칛lften tills det s칬kta elementet hittas eller tills det inte finns n친gra element kvar att s칬ka igenom.

2. **Identifiera indata**: Funktionen beh칬ver fyra indata: en sorterad lista, ett s칬kt tal och tv친 index som representerar de nedre och 칬vre gr칛nserna f칬r s칬kningen.

3. **Ber칛kna mitten**: F칬r varje s칬kning, ber칛kna mitten av listan (eller den aktuella delen av listan) genom att addera det nedre och 칬vre indexet och dela med tv친.

4. **J칛mf칬r mitten med m친let**: Kontrollera om det s칬kta talet 칛r lika med, mindre 칛n eller st칬rre 칛n elementet i mitten av listan.

5. **Uppdatera gr칛nserna**: Om det s칬kta talet 칛r mindre 칛n elementet i mitten, uppdatera det 칬vre indexet till att vara ett steg mindre 칛n mitten. Om det s칬kta talet 칛r st칬rre, uppdatera det nedre indexet till att vara ett steg st칬rre 칛n mitten.

6. **Returnera resultatet**: Resultatet returneras i form av tre tal; de b친da
indexen som 칛r ber칛knade samt en boolesk flagga `True` om talet 칛r hittat eller
`False` om talet 칛nnu inte 칛r hittat eller saknas.

7. **Iterera**: Anv칛nd en loop f칬r att upprepa dessa steg tills det s칬kta talet hittas eller tills det inte finns n친gra element kvar att s칬ka igenom. Denna loop ska vara utanf칬r funktionen och anropa funktionen vid varje iteration.

Kom ih친g att bin칛rs칬kning endast fungerar p친 sorterade listor, s친 om listan inte 칛r sorterad m친ste du sortera den innan du anv칛nder denna funktion. Lycka till med programmeringen! 游땕

### Exempel

H칛r 칛r en lista med tal. L친t oss s칬ka efter ett tal med hj칛lp av algoritm.

```
2 4 6 8 10 12 14 16 18 20
```

**Fall 1: S칬ker efter talet `14` som finns i listan**

1. F칬rst ber칛knar vi mitten av listan. I det h칛r fallet 칛r mittenindexet `5` (v칛rdet `12`).

```
2 4 6 8 10 [12] 14 16 18 20
```

2. Eftersom `14` 칛r st칬rre 칛n `12`, forts칛tter vi att s칬ka i den h칬gra halvan av listan.

```
14 16 18 20
```

3. Vi ber칛knar mitten av den nya listan, vilket 칛r index `1` (v칛rdet `16`).

```
14 [16] 18 20
```

4. Eftersom `14` 칛r mindre 칛n `16`, forts칛tter vi att s칬ka i den v칛nstra halvan av listan.

```
14
```

5. Nu 칛r det bara ett element kvar i listan och det 칛r det s칬kta talet `14`. S친 vi har hittat talet vi letade efter!

**Fall 2: S칬ker efter talet `11` som inte finns i listan**

1. F칬rst ber칛knar vi mitten av listan. I det h칛r fallet 칛r mittenindexet `5` (v칛rdet `12`).

```
2 4 6 8 10 [12] 14 16 18 20
```

2. Eftersom `11` 칛r mindre 칛n `12`, forts칛tter vi att s칬ka i den v칛nstra halvan av listan.

```
2 4 6 8 10
```

3. Vi ber칛knar mitten av den nya listan, vilket 칛r index `2` (v칛rdet `6`).

```
2 4 [6] 8 10
```

4. Eftersom `11` 칛r st칬rre 칛n `6`, forts칛tter vi att s칬ka i den h칬gra halvan av listan.

```
8 10
```

5. Vi ber칛knar mitten av den nya listan, vilket 칛r index `0` (v칛rdet `8`).

```
[8] 10
```

6. Eftersom `11` 칛r st칬rre 칛n `8`, forts칛tter vi att s칬ka i den h칬gra halvan av listan.

```
10
```

7. Nu 칛r det bara ett element kvar i listan och det 칛r inte det s칬kta talet `11`. S친 vi har inte hittat talet vi letade efter!


### Uppgift 1

Skriv en funktion som implementerar bin칛rs칬kning enligt algoritm ovan.
Till en b칬rjan, g칬r inte en loop som upprepar s칬kningen, utan testa dig fram
steg f칬r steg och kontrollera att du f친r r칛tt index i retur.

Som det st친r i beskrivningen av algoritm s친 ska funktionen returnera tre tal.
Exempel p친 hur detta g친r till:

**Exempel**
```{python}
# | echo: true
def calc(a, b):
    sum = a + b
    diff = a - b
    prod = a * b
    return sum, diff, prod


# Anropa funktionen
summa, differens, produkt = calc(5, 8)
print(summa, differens, produkt)
```

Vidare s친 anv칛nds *heltalsdivision* f칬r att ta reda p친 mittenindex. Denna
resulterar alltid i heltaldelen av divisionens resultat. Exempel:

```{python}
# | echo: true
print(21 // 2)  # Ger resultatet 10 (se nedan)
```

:::{.callout-tip collapse="true" icon="false" title="L칬sningsf칬rslag"}
```{python}
# | echo: true
def binary_search(lst, key, lower, upper):
    # Tar emot en lista lst,
    # en s칬knyckel key,
    # ett undre index f칬r s칬kning i listan,
    # ett 칬vre index f칬r s칬kning i listan

    # mi 칛r mittenindex
    mi = (lower + upper) // 2

    if upper >= lower:
        # Nyckeln hittades
        if key == lst[mi]:
            return mi, mi, True

        # Nyckeln 칛r mindre 칛n v칛rdet p친 mittenindex
        if key < lst[mi]:
            upper = mi - 1
            return lower, upper, False

        # Nyckeln 칛r st칬rre 칛n v칛rdet p친 mittenindex
        if key > lst[mi]:
            lower = mi + 1
            return lower, upper, False

    # Om inget av ovanst친ende, nyckeln saknas
    # i listan
    return -1, -1, False
```

Exempel p친 anv칛nding av funktionen f칬r att s칬ka efter talet `12` i en lista:
```{python}
# | echo: true
lst = [2, 4, 5, 7, 9, 12, 14]
lower = 0
upper = len(lst) - 1
print(binary_search(lst, 12, lower, upper))
```

Inneb칬rden av resultatet `(4, 6, False)` 칛r att **om**  talet `12` finns i
listan s친 g칛ller att det m친ste ligga mellan (och inklusive) index 4 och 6 i
listan och att talets befintlighet i listan varken har konstaterats eller
uteslutits.
:::

### Uppgift 2

Slutf칬r programmet med en loop som under en k칬rning avg칬r om, och i s친 fall
p친 vilket index, som det s칬kta talet finns alternativt saknas.

**K칬rningsexempel**
```{python}
# | echo: false
def binary_search(arr, target, low, high):
    if high >= low:
        mid = (high + low) // 2

        # Om elementet finns i mitten
        if arr[mid] == target:
            return mid, mid, True

        # Om elementet 칛r mindre 칛n mitten, d친 칛r det bara i v칛nstra delen
        elif arr[mid] > target:
            return low, mid - 1, False

        # Annars 칛r elementet i h칬gra delen
        else:
            return mid + 1, high, False

    else:
        # Elementet finns inte i listan
        return -1, -1, False


a_list = [-1, 2, 4, 5, 8, 12, 15, 16, 20]
# index: 0  1  2  3  4   5   6   7   8
key = 5
counter = 0
verbose = True
print("Listan som ska s칬kas igenom")
print(a_list)
print(f"Talet som s칬ks: {key}")
for key in range(key, key + 1):
    a = 0
    b = len(a_list) - 1
    res = False
    counter = 0
    while a <= b and not res:
        counter += 1
        if verbose:
            print(
                f"Ska s칬ka mellan (och inklusive) index {a} och {b} (med mitt p친 {(a+b)//2})"
            )
        a, b, res = binary_search(a_list, key, a, b)

    if res:
        print(f"Talet {key} hittades p친 index {a} p친 {counter} s칬kningar")
    else:
        print(
            f"Talet {key} finns inte i listan, konstaterades efter {counter} s칬kningar"
        )

```

:::{.callout-tip collapse="true" icon="false" title="Partiellt l칬sningsf칬rslag"}

```{python}
# | echo: true
# Huvudprogram d칛r funktionen i Uppgift 1 testas
# ----------------------------------------------

# En lista definieras
lst = [2, 4, 5, 7, 9, 12, 14]

# Ett tal att s칬ka efter samt listindexen f칬r denna s칬kning
key = 12
lower = 0
upper = len(lst) - 1

# Funktionen anropas flera g친nger i en loop
while True:
    lower, upper, flag = binary_search(lst, key, lower, upper)
    if flag == True or lower == upper == -1:
        break
if flag == True:
    print(f"Talet {key} hittades p친 index {lower}")
else:
    print(f"Talet {key} finns inte i listan")

```
:::


### Uppgift 3

Unders칬k antalet s칬kningar som beh칬ver g칬ras f칬r ett antal tal. H칛r 칛r
utmatningsexempel p친 n친gra s칬kningar i listan:

```{python}
# | echo: false
verbose = False
print("Listan som ska s칬kas igenom")
print(a_list)
for key in range(-2, 20 + 1):
    a = 0
    b = len(a_list) - 1
    res = False
    counter = 0
    while a != -1 and not res:
        counter += 1
        if verbose:
            print(
                f"S칬ker mellan (och inklusive) index {a} och {b} (med mitt p친 {(a+b)//2})"
            )
        a, b, res = binary_search(a_list, key, a, b)

    if res:
        print(f"Talet {key} hittades p친 index {a} p친 {counter} s칬kningar")
    else:
        print(
            f"Talet {key} finns inte i listan, konstaterades efter {counter} s칬kningar"
        )
```

Skapa en (sorterad) lista med $1\,000$ element med spridda heltalsv칛rden mellan
$0$ och $2\,000$. Hur m친nga s칬kningar m친ste

a. maximalt g칬ras
b. i genomsnitt g칬ras

f칬r att hitta ett tal som finns i listan alternativt utesluta f칬rekomsten av
det?

G칬r om samma undes칬kning med en lista p친 $10\,000$ element (med spridda
heltalsv칛rden mellan 0 och $20\,000$). Kommentera resultatet.