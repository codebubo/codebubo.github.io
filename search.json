[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Jag heter Nikodemus Karlsson, och är verksam gymnasielärare i matematik, fysik och programmering. Syftet med sajten är att samla mycket av det undervisningsmaterial som jag använder."
  },
  {
    "objectID": "about.html#vem-skriver-på-denna-sajt",
    "href": "about.html#vem-skriver-på-denna-sajt",
    "title": "About",
    "section": "",
    "text": "Jag heter Nikodemus Karlsson, och är verksam gymnasielärare i matematik, fysik och programmering. Syftet med sajten är att samla mycket av det undervisningsmaterial som jag använder."
  },
  {
    "objectID": "about.html#verktyg-som-används-för-uppbyggnad",
    "href": "about.html#verktyg-som-används-för-uppbyggnad",
    "title": "About",
    "section": "Verktyg som används för uppbyggnad",
    "text": "Verktyg som används för uppbyggnad\nSajten är byggd med publiceringssystemet Quarto och publicerad på GitHub Pages. Det jag framförallt gillar med Quarto är att man skriver i Markdown och att det är enkelt att integrera text, bilder, kod samt matematiska formler på såväl vanliga webbsidor och i presentationer. Quarto är byggd på öppen källkod och finns såväl till Windows, Linux och macOS."
  },
  {
    "objectID": "about.html#användning-av-materialet",
    "href": "about.html#användning-av-materialet",
    "title": "About",
    "section": "Användning av materialet",
    "text": "Användning av materialet\nDen som vill får gärna använda, kopiera och sprida material från sajten. Källkod till sidorna och presentationerna finns i denna repo på GitHub."
  },
  {
    "objectID": "fy/simuleringar/waves/index.html#gående-vågor",
    "href": "fy/simuleringar/waves/index.html#gående-vågor",
    "title": "Simuleringar vågrörelse",
    "section": "Gående vågor",
    "text": "Gående vågor\n\nGående transversella vågor\nEn gående våg (travelling wave) består av partiklar som svänger med en viss fasförskjutning i förhållande till varandra. Nedan visas en transversell våg, där varje partikel rör sig vinkelrätt mot vågens utbredningsriktning. Svängningen är harmonisk, vilket innebär att varje partikel rör sig enligt en sinusfunktion över tid — och vågen får därmed en sinusformad profil.\nI den här animeringen sker utbredningen åt höger, vilket innebär att vågens form förflyttar sig i den riktningen, även om varje enskild partikel bara rör sig upp och ner.\n\n\n\n\n\n\n\n\n\nGående longitudinella vågor",
    "crumbs": [
      "Home",
      "Fysikrelaterat",
      "Simuleringar vågrörelse"
    ]
  },
  {
    "objectID": "fy/simuleringar/waves/index.html#stående-våg",
    "href": "fy/simuleringar/waves/index.html#stående-våg",
    "title": "Simuleringar vågrörelse",
    "section": "Stående våg",
    "text": "Stående våg\nUnder konstruktion.",
    "crumbs": [
      "Home",
      "Fysikrelaterat",
      "Simuleringar vågrörelse"
    ]
  },
  {
    "objectID": "ma/ma-spec/komp-mat/determinant/index.html#uppgifter",
    "href": "ma/ma-spec/komp-mat/determinant/index.html#uppgifter",
    "title": "Determinant mm",
    "section": "Uppgifter",
    "text": "Uppgifter\n\nGå igenom begreppen injektiv, surjektiv och bijektiv på denna sida och gör de 10 quiz-frågorna som finns länkade i slutet på sidan.\nAvgör för respektive funktion nedan om den är injektiv eller inte. Motivera!\nA. \\(f:\\mathbb{R} \\to \\mathbb{R}\\) där \\(f(x)=x^3+4\\)\nB. \\(f:\\mathbb{N} \\to \\mathbb{N}\\) där \\(f(x)=x^3+4\\)\nC. \\(f:\\mathbb{R} \\to \\mathbb{R}\\) där \\(f(x)=x^2+4\\)\nD. \\(f:\\mathbb{N} \\to \\mathbb{N}\\) där \\(f(x)=x^2+4\\)\nDen symmetriska gruppen:\n\nBestäm antalet element då \\(n=4\\).\nAnge och skriv ned (på samma sätt som på s. 49 i studiematerialet) alla permutationer för \\(n=4\\). Ange också för respektive permutation antalet inversioner och om dess paritet är jämn eller udda.",
    "crumbs": [
      "Home",
      "Matematik specialisering",
      "Determinant mm"
    ]
  },
  {
    "objectID": "ma/ma-spec/programmering/teori-och-ovningar/funktioner-villkor-och-loopar/index.html",
    "href": "ma/ma-spec/programmering/teori-och-ovningar/funktioner-villkor-och-loopar/index.html",
    "title": "Octave: Funktioner, villkor och loopar",
    "section": "",
    "text": "Se kap. 2 i dokumentet Teori och övningar i programmet Octave\n\n\n\n\n\nSkapa en anonym funktion som adderar två tal med varandra och returnerar resultatet. Funktionen ska ges handtaget add.\n\n\n\n\n\n\nLösningsförslag övning 201\n\n\n\n\n\nÖvningen kan antingen göras i Command Window eller genom att skapa en fil i Octave.\n# Koden sparas under valfritt filnamn\n\nadd = @(a, b) a + b;\nadd(2, 3) # Skriver ut 5\n\n\n\n\n\n\nSkapa en anonym funktion som parvis multiplicerar talen i två vektorer med varandra. Funktionen ska ges handtaget elementmul.\nKörningsexempel:\noctave:1&gt; elementmul([1 2 3], [4 5 6])\nans = 4 10 18\n\n\n\n\n\n\nLösningsförslag övning 202\n\n\n\n\n\n# Koden sparas under valfritt filnamn\n\nelementmul = @(u, v) u .* v;\nelementmul([1 2 3], [4 5 6])\n\n\n\n\n\n\nSkapa en anonym funktion som beräknar logaritmen på ett tal \\(x\\) i en valfri bas \\(n\\). Funktionen ska tilldelas handtaget logn. Funktionen ska kunna ta emot såväl enstaka tal som en vektor med tal, och returnera logaritmen för respektive tal som en vektor.\nKörningsexempel:\noctave:2&gt; logn(9, 3) # Beräknar logaritmen av 9 i basen 3\nans = 2\noctave:3&gt; logn([1 3 9 27 81], 3)\nans =\n\n   0   1   2   3   4\n\n\n\n\n\n\nLösningsförslag övning 203\n\n\n\n\n\nVi utgår från följande sätt att lösa ekvationen \\(n^y = x\\) med avseende på \\(y\\):\n\\[\n\\begin{matrix}\nn^y &=& x &\\Leftrightarrow& y &=& \\log_n x \\\\[5mm]\nn^y &=& x &\\Leftrightarrow& y &=& \\frac{\\log{x}}{\\log{n}}\n\\end{matrix}\n\\hspace{5mm} \\Rightarrow \\log_n{x} = \\frac{\\log{x}}{\\log{n}}\n\\]\ndär log är logaritmen med en godtycklig bas (i Octave ger funktionen log logaritmen givet basen \\(e\\)).\nFunktionen kan då kodas\n# Koden sparas under valfritt filnamn\n\nlogn = @(x, n) log(x) ./ log(n);\n\n\n\n\n\n\nSkapa en namngiven funktion dotmul i en separat fil. Funktionen ska parvis multiplicera komponenterna i två vektorer och returnera summan av produkterna. (Denna typ av multiplikation kallas för skalärmultiplikation och är en viktig komponent i den linjära algebran.)\nKörningsexempel:\noctave:4&gt; dotmul([1 2 3], [4 5 6])\nans = 32\n\n\n\n\n\n\nLösningsförslag övning 204\n\n\n\n\n\n# Denna kod sparas i filen dotmul.m\n\nfunction retval = dotmul(u, v)\n  retval = 0;\n  for i = 1:length(u)\n    retval += u(i) * v(i);\n  endfor\nendfunction\nFör att de skript som använder dotmul ska hitta funktionen måste sökvägen till filen läggas till. Detta görs på menyn Edit -&gt; Set Path.\n\n\n\n\n\n\nSkapa en funktion clock_hands_angles i en separat fil, vilken ska returnera vinkeln för tim- minut- och sekundvisaren för ett givet klockslag på en analog klocka. Vinklarna ska returneras som ”standardvinklar” uttryckta i grader i enhetscirkeln, dvs när t ex minutvisaren står på 3 så motsvarar det vinkeln 0°, och när den står på 12 så motsvarar det 90°.\nTänk på att alla visares vinklar ändrar sig lite för varje sekund som går.\nKörningsexempel (då funktionen anropas med tiden 03:00:00):\noctave:5&gt; [h_ang m_ang s_ang] = clock_hands_angles(03, 00, 00)\nh_ang = 0\nm_ang = 90\ns_ang = 90\nKörningsexempel (då funktionen anropas med tiden 13:45:30):\noctave:6&gt; [h_ang m_ang s_ang] = clock_hands_angles(13, 45, 30)\nh_ang = 37.250\nm_ang = 177\ns_ang = 270\n\n\n\n\n\n\nLösningsförslag övning 205\n\n\n\n\n\n# Denna kod sparas i filen clock_hands_angles.m\n\nfunction [hv mv sv] = clock_hands_angles (h, m, s)\n  secs = s + 60*m + 3600*h;\n  sv = mod(90-6*secs, 360);     # Modulofunktionen ger\n  # Min.visare: 6° på 60 sek.   # vinkeln i det \"första\"\n  mv = mod(90-1/10*secs, 360);  # varvet.\n  # Timvisare: 30° på 3600 sek.\n  hv = mod(90-1/120*secs, 360);\nendfunction\n\n\n\n\n\n\nI spelet LOTTO slumpas sju olika nummer bland heltalen 1, 2, 3,. . . , 35. Spelaren ska gissa vilka nummer som kommer att slumpas fram och hoppas förstås att få alla rätt (vilket brukar rendera en vinst runt 1 miljon kronor).\nDu ska skapa ett skript, lotto, som slumpar fram en spelares rad. Skriptet ska i sin tur anropa en funktion lottoeval som ska slumpa fram en vinstrad och utvärdera spelarens rad med avseende på vilka nummer som är rätt och dessutom räkna antalet rätt. Körningsexempel (observera att talen är justerade under varandra):\noctave:7&gt; lotto\nTippad rad:        5  11  13  15  20  33  34\nVinnande rad:      4  13  16  17  19  25  34\nMatchande nummer: 13  34\nAntal rätt:        2\nInga utskrifter ska göras från funktionen lottoeval, dessa ska göras från skriptet lotto. Funktionen lottoeval måste alltså returnera det som behövs för utskrift.\nTips: använd funktionen randperm, t ex skapar randperm(35, 7) en vektor med sju slumpade heltal mellan 1 och 35.\n\n\n\n\n\n\nLösningsförslag övning 206\n\n\n\n\n\n# Denna kod sparas i filen lottoeval.m\n\nfunction [correct_nums result matches] = lottoeval(guesses)\n  # Inparameter:   guesses, en vektor med spelarens sju gissade nummer\n  # Utdata:\n     # correct_nums: vektorn som spelarens rad ska utvärderas mot (dragen rad)\n     # result:       antalet rätta gissningar (ett tal)\n     # matches:      vektor med de korrekta gissningarna\n\n  correct_guesses = 0;\n  correct_nums = sort(randperm(35, 7));\n  matches = [];\n\n  # Spelarens rad jämförs mot den dragna raden i en nästlad loop\n  for i = 1:7;\n    for j = 1:7;\n      if guesses(i) == correct_nums(j);\n        correct_guesses += 1;\n        matches(end+1) = guesses(i);\n      endif;\n    endfor;\n  endfor;\n  result = correct_guesses;\nendfunction\nNedan följer skriptet lotto:\n# Koden sparas under valfritt filnamn\n\n# Raden som spelaren tippar slumpas fram\ntippad_rad = randperm(35, 7);\n\n# Den tippade raden rättas\n[dragen_rad antal_ratt matchningar] = lottoeval(tippad_rad);\n\n# Strängar för utskrift skapas\nf = sprintf('%3.d ', sort(tippad_rad));\ng = sprintf('%3.d ', sort(dragen_rad));\nh = sprintf('%3.f ', sort(matchningar));\n\n# Strängarna skrivs ut\nprintf('Tippad rad:      %s\\n', f);\nprintf('Vinnande rad:    %s\\n', g);\nprintf('Matchande nummer:%s\\n', h);\nprintf('Antal rätt:        %d\\n', antal_ratt);\n\n\n\n\n\n\nSkriv en funktion lottovinst som använder funktionen lottoeval från övning 206. Funktionen lottovinst ska slumpa fram en tippad LOTTO-rad och köra den upprepade gånger i lottoeval tills ett minsta antal rätt uppnås på den tippade raden. Funktionen lottovinst ska ta emot parametern minst_antal_ratt, som förstås anger efter hur många rätt på en dragning som körningen ska stoppas efter.\nKörningsexempel, då lottovinst anropas från Command Window och vi önskar minst två rätt:\noctave:8&gt; lottovinst(2)\nantal_dragningar = 4\nantal_ratt = 3\nHär behövde fyra dragningar göras innan det blev minst två rätt (och då blev det tre rätt).\nKörningsexempel då ett större antal rätt önskas:\noctave:9&gt; lottovinst(6)\nantal_dragningar = 15742\nantal_ratt = 6\nDet här anropet, där minst sex rätt önskades, tog 11.3 sekunder för att uppfylla önskemålet.\nTiden att köra klart funktionen kan mätas med funktionerna tic och toc enligt\noctave:10&gt; tic; lottovinst(5); toc\nantal_dragningar = 1331\nantal_ratt = 5\nElapsed time is 0.948647 seconds.\n\n\n\n\n\n\nLösningsförslag övning 207\n\n\n\n\n\n# Denna kod sparas i filen lottovinst.m\n\nfunction lottovinst(minst_antal_ratt)\n  # Här skapas en rad som ska tippas gång på gång tills antalet\n  # rätt uppgår till parametervärdet minst_antal_ratt\n  tippad_rad = randperm(35, 7);\n\n  # Den tippade raden rättas\n  [dragen_rad antal_ratt matchningar] = lottoeval(tippad_rad);\n\n  antal_dragningar = 1;\n\n  # Om inte tillräckligt antal rätt erhålls, tippa samma rad igen och rätta\n  # mot en ny dragen rad\n  while (antal_ratt &lt; minst_antal_ratt)\n    antal_dragningar += 1;\n    [dragen_rad antal_ratt matchningar] = lottoeval(tippad_rad);\n  endwhile\n\n  # Här sker utskriften av resultatet\n  antal_dragningar, antal_ratt \nendfunction\nNu kan lottovinst anropas antingen från ett skript eller från Command Window.",
    "crumbs": [
      "Home",
      "Programmering i matematik",
      "MatSpec",
      "Teori och övningar",
      "Octave: Funktioner, villkor och loopar"
    ]
  },
  {
    "objectID": "ma/ma-spec/programmering/teori-och-ovningar/funktioner-villkor-och-loopar/index.html#teori",
    "href": "ma/ma-spec/programmering/teori-och-ovningar/funktioner-villkor-och-loopar/index.html#teori",
    "title": "Octave: Funktioner, villkor och loopar",
    "section": "",
    "text": "Se kap. 2 i dokumentet Teori och övningar i programmet Octave",
    "crumbs": [
      "Home",
      "Programmering i matematik",
      "MatSpec",
      "Teori och övningar",
      "Octave: Funktioner, villkor och loopar"
    ]
  },
  {
    "objectID": "ma/ma-spec/programmering/teori-och-ovningar/funktioner-villkor-och-loopar/index.html#övningar",
    "href": "ma/ma-spec/programmering/teori-och-ovningar/funktioner-villkor-och-loopar/index.html#övningar",
    "title": "Octave: Funktioner, villkor och loopar",
    "section": "",
    "text": "Skapa en anonym funktion som adderar två tal med varandra och returnerar resultatet. Funktionen ska ges handtaget add.\n\n\n\n\n\n\nLösningsförslag övning 201\n\n\n\n\n\nÖvningen kan antingen göras i Command Window eller genom att skapa en fil i Octave.\n# Koden sparas under valfritt filnamn\n\nadd = @(a, b) a + b;\nadd(2, 3) # Skriver ut 5\n\n\n\n\n\n\nSkapa en anonym funktion som parvis multiplicerar talen i två vektorer med varandra. Funktionen ska ges handtaget elementmul.\nKörningsexempel:\noctave:1&gt; elementmul([1 2 3], [4 5 6])\nans = 4 10 18\n\n\n\n\n\n\nLösningsförslag övning 202\n\n\n\n\n\n# Koden sparas under valfritt filnamn\n\nelementmul = @(u, v) u .* v;\nelementmul([1 2 3], [4 5 6])\n\n\n\n\n\n\nSkapa en anonym funktion som beräknar logaritmen på ett tal \\(x\\) i en valfri bas \\(n\\). Funktionen ska tilldelas handtaget logn. Funktionen ska kunna ta emot såväl enstaka tal som en vektor med tal, och returnera logaritmen för respektive tal som en vektor.\nKörningsexempel:\noctave:2&gt; logn(9, 3) # Beräknar logaritmen av 9 i basen 3\nans = 2\noctave:3&gt; logn([1 3 9 27 81], 3)\nans =\n\n   0   1   2   3   4\n\n\n\n\n\n\nLösningsförslag övning 203\n\n\n\n\n\nVi utgår från följande sätt att lösa ekvationen \\(n^y = x\\) med avseende på \\(y\\):\n\\[\n\\begin{matrix}\nn^y &=& x &\\Leftrightarrow& y &=& \\log_n x \\\\[5mm]\nn^y &=& x &\\Leftrightarrow& y &=& \\frac{\\log{x}}{\\log{n}}\n\\end{matrix}\n\\hspace{5mm} \\Rightarrow \\log_n{x} = \\frac{\\log{x}}{\\log{n}}\n\\]\ndär log är logaritmen med en godtycklig bas (i Octave ger funktionen log logaritmen givet basen \\(e\\)).\nFunktionen kan då kodas\n# Koden sparas under valfritt filnamn\n\nlogn = @(x, n) log(x) ./ log(n);\n\n\n\n\n\n\nSkapa en namngiven funktion dotmul i en separat fil. Funktionen ska parvis multiplicera komponenterna i två vektorer och returnera summan av produkterna. (Denna typ av multiplikation kallas för skalärmultiplikation och är en viktig komponent i den linjära algebran.)\nKörningsexempel:\noctave:4&gt; dotmul([1 2 3], [4 5 6])\nans = 32\n\n\n\n\n\n\nLösningsförslag övning 204\n\n\n\n\n\n# Denna kod sparas i filen dotmul.m\n\nfunction retval = dotmul(u, v)\n  retval = 0;\n  for i = 1:length(u)\n    retval += u(i) * v(i);\n  endfor\nendfunction\nFör att de skript som använder dotmul ska hitta funktionen måste sökvägen till filen läggas till. Detta görs på menyn Edit -&gt; Set Path.\n\n\n\n\n\n\nSkapa en funktion clock_hands_angles i en separat fil, vilken ska returnera vinkeln för tim- minut- och sekundvisaren för ett givet klockslag på en analog klocka. Vinklarna ska returneras som ”standardvinklar” uttryckta i grader i enhetscirkeln, dvs när t ex minutvisaren står på 3 så motsvarar det vinkeln 0°, och när den står på 12 så motsvarar det 90°.\nTänk på att alla visares vinklar ändrar sig lite för varje sekund som går.\nKörningsexempel (då funktionen anropas med tiden 03:00:00):\noctave:5&gt; [h_ang m_ang s_ang] = clock_hands_angles(03, 00, 00)\nh_ang = 0\nm_ang = 90\ns_ang = 90\nKörningsexempel (då funktionen anropas med tiden 13:45:30):\noctave:6&gt; [h_ang m_ang s_ang] = clock_hands_angles(13, 45, 30)\nh_ang = 37.250\nm_ang = 177\ns_ang = 270\n\n\n\n\n\n\nLösningsförslag övning 205\n\n\n\n\n\n# Denna kod sparas i filen clock_hands_angles.m\n\nfunction [hv mv sv] = clock_hands_angles (h, m, s)\n  secs = s + 60*m + 3600*h;\n  sv = mod(90-6*secs, 360);     # Modulofunktionen ger\n  # Min.visare: 6° på 60 sek.   # vinkeln i det \"första\"\n  mv = mod(90-1/10*secs, 360);  # varvet.\n  # Timvisare: 30° på 3600 sek.\n  hv = mod(90-1/120*secs, 360);\nendfunction\n\n\n\n\n\n\nI spelet LOTTO slumpas sju olika nummer bland heltalen 1, 2, 3,. . . , 35. Spelaren ska gissa vilka nummer som kommer att slumpas fram och hoppas förstås att få alla rätt (vilket brukar rendera en vinst runt 1 miljon kronor).\nDu ska skapa ett skript, lotto, som slumpar fram en spelares rad. Skriptet ska i sin tur anropa en funktion lottoeval som ska slumpa fram en vinstrad och utvärdera spelarens rad med avseende på vilka nummer som är rätt och dessutom räkna antalet rätt. Körningsexempel (observera att talen är justerade under varandra):\noctave:7&gt; lotto\nTippad rad:        5  11  13  15  20  33  34\nVinnande rad:      4  13  16  17  19  25  34\nMatchande nummer: 13  34\nAntal rätt:        2\nInga utskrifter ska göras från funktionen lottoeval, dessa ska göras från skriptet lotto. Funktionen lottoeval måste alltså returnera det som behövs för utskrift.\nTips: använd funktionen randperm, t ex skapar randperm(35, 7) en vektor med sju slumpade heltal mellan 1 och 35.\n\n\n\n\n\n\nLösningsförslag övning 206\n\n\n\n\n\n# Denna kod sparas i filen lottoeval.m\n\nfunction [correct_nums result matches] = lottoeval(guesses)\n  # Inparameter:   guesses, en vektor med spelarens sju gissade nummer\n  # Utdata:\n     # correct_nums: vektorn som spelarens rad ska utvärderas mot (dragen rad)\n     # result:       antalet rätta gissningar (ett tal)\n     # matches:      vektor med de korrekta gissningarna\n\n  correct_guesses = 0;\n  correct_nums = sort(randperm(35, 7));\n  matches = [];\n\n  # Spelarens rad jämförs mot den dragna raden i en nästlad loop\n  for i = 1:7;\n    for j = 1:7;\n      if guesses(i) == correct_nums(j);\n        correct_guesses += 1;\n        matches(end+1) = guesses(i);\n      endif;\n    endfor;\n  endfor;\n  result = correct_guesses;\nendfunction\nNedan följer skriptet lotto:\n# Koden sparas under valfritt filnamn\n\n# Raden som spelaren tippar slumpas fram\ntippad_rad = randperm(35, 7);\n\n# Den tippade raden rättas\n[dragen_rad antal_ratt matchningar] = lottoeval(tippad_rad);\n\n# Strängar för utskrift skapas\nf = sprintf('%3.d ', sort(tippad_rad));\ng = sprintf('%3.d ', sort(dragen_rad));\nh = sprintf('%3.f ', sort(matchningar));\n\n# Strängarna skrivs ut\nprintf('Tippad rad:      %s\\n', f);\nprintf('Vinnande rad:    %s\\n', g);\nprintf('Matchande nummer:%s\\n', h);\nprintf('Antal rätt:        %d\\n', antal_ratt);\n\n\n\n\n\n\nSkriv en funktion lottovinst som använder funktionen lottoeval från övning 206. Funktionen lottovinst ska slumpa fram en tippad LOTTO-rad och köra den upprepade gånger i lottoeval tills ett minsta antal rätt uppnås på den tippade raden. Funktionen lottovinst ska ta emot parametern minst_antal_ratt, som förstås anger efter hur många rätt på en dragning som körningen ska stoppas efter.\nKörningsexempel, då lottovinst anropas från Command Window och vi önskar minst två rätt:\noctave:8&gt; lottovinst(2)\nantal_dragningar = 4\nantal_ratt = 3\nHär behövde fyra dragningar göras innan det blev minst två rätt (och då blev det tre rätt).\nKörningsexempel då ett större antal rätt önskas:\noctave:9&gt; lottovinst(6)\nantal_dragningar = 15742\nantal_ratt = 6\nDet här anropet, där minst sex rätt önskades, tog 11.3 sekunder för att uppfylla önskemålet.\nTiden att köra klart funktionen kan mätas med funktionerna tic och toc enligt\noctave:10&gt; tic; lottovinst(5); toc\nantal_dragningar = 1331\nantal_ratt = 5\nElapsed time is 0.948647 seconds.\n\n\n\n\n\n\nLösningsförslag övning 207\n\n\n\n\n\n# Denna kod sparas i filen lottovinst.m\n\nfunction lottovinst(minst_antal_ratt)\n  # Här skapas en rad som ska tippas gång på gång tills antalet\n  # rätt uppgår till parametervärdet minst_antal_ratt\n  tippad_rad = randperm(35, 7);\n\n  # Den tippade raden rättas\n  [dragen_rad antal_ratt matchningar] = lottoeval(tippad_rad);\n\n  antal_dragningar = 1;\n\n  # Om inte tillräckligt antal rätt erhålls, tippa samma rad igen och rätta\n  # mot en ny dragen rad\n  while (antal_ratt &lt; minst_antal_ratt)\n    antal_dragningar += 1;\n    [dragen_rad antal_ratt matchningar] = lottoeval(tippad_rad);\n  endwhile\n\n  # Här sker utskriften av resultatet\n  antal_dragningar, antal_ratt \nendfunction\nNu kan lottovinst anropas antingen från ett skript eller från Command Window.",
    "crumbs": [
      "Home",
      "Programmering i matematik",
      "MatSpec",
      "Teori och övningar",
      "Octave: Funktioner, villkor och loopar"
    ]
  },
  {
    "objectID": "ma/ma-5/kombinatorik/index.html",
    "href": "ma/ma-5/kombinatorik/index.html",
    "title": "Kombinatorik: Extra övningar",
    "section": "",
    "text": "Ett kodlås har en kod bestående av fyra siffror, där varje siffra kan väljas bland de tio siffrorna 0 – 9.\nHur många olika koder finns det om\n\ndet inte finns någon begränsning i hur siffrorna i koden får väljas?\ningen siffra får upprepas?\ningen siffra får får upprepas, och den tredje siffran är en \\(8\\)?\ningen siffra får upprepas, och koden måste vara i stigande nummerföljd?\ningen siffra får upprepas, och såväl siffran \\(2\\) som siffran \\(5\\) måste ingå?\n\n\n\n\n\n\n\nLösningsförslag\n\n\n\n\n\n\nRespektive siffra (\\(0\\) – \\(9\\)) kan väljas på varje plats i koden. Det gör att det totala antalet koder blir \\(10\\cdot 10\\cdot 10\\cdot 10=10^4\\)\nDen första siffran kan väljas på tio sätt, den andra på nio sätt, den tredje på åtta sätt och den fjärde på sju sätt. Det ger antalet koder till \\(P(10,4)=10\\cdot 9\\cdot 8\\cdot 7=5040\\).\nDen första siffran kan väljas på nio sätt, den andra på åtta sätt, den tredje på ett sätt och den fjärde på sju sätt. Det ger antalet koder till \\(P(10,4)=9\\cdot 8\\cdot 1\\cdot 7=504\\).\nHär ska vi räkna antalet oordnade urval på fyra siffror av tio. Eftersom ingen siffra får upprepas, och eftersom det därmed enbart finns en enda godtagbar nummerföljd per urval, så kommer antalet oordnade urval att ge det sökta antalet koder. Det blir \\(C(10,4)=210\\) st.\nHär väljer vi först de två siffror som ska ingå (utöver siffrorna 2 och 5). Det kan göras på \\(C(8,2)=28\\) olika sätt. Därefter ska de båda positionerna på dessa siffror väljas, det kan göras på \\(C(4,2)=6\\) sätt. Därefter ska placeringen av dessa siffror i de valda lägena bestämmas, det kan ske på \\(2!=2\\) sätt. Slutligen så ska placeringen i de kvarvarande lägena väljas för siffrorna \\(2\\) och \\(5\\), det kan också göras på \\(2!=2\\) sätt. Multiplikationsprincipen ger nu att det totala antalet koder blir \\(28\\cdot 6\\cdot 2\\cdot 2=672\\) stycken.\n\n\n\n\n\n\n\n\nEn kortlek består av 52 kort. På hur många sätt kan en blandning falla ut om\n\nalla blandningar är tillåtna?\nenbart de blandningar där ♣️3 ligger direkt ovanpå ♦️4 räknas?\n\n\n\n\n\n\n\nLösningsförslag\n\n\n\n\n\n\nEftersom alla kort är olika gäller att det översta kortet i en blandad lek kan vara \\(1\\) av \\(52\\), kortet under detta \\(1\\) av \\(51\\) osv. Det innebär att antalet blandningar kan vara \\(52\\cdot 51\\cdot 50\\cdot\\ldots\\cdot 1=52!\\). Multiplikationsprincipen ska tillämpas eftersom antalet möjligheter på en given plats i leken inte påverkas av vilka kort som ligger på andra platser.\nHär kan man tänka att det är \\(51\\) kort som ska blandas, t ex så tar vi bort ♣️3 ur leken. För varje utfall så tänker vi oss vidare att vi “manuellt” lägger in detta ♣️3 ovanpå ♦️4. \nAntalet sådana utfall blir alltså \\(51!\\).\n\n\n\n\n\n\n\n\nEn sträng består av bokstäverna a, a, b, b, c, c, d, d. Hur många olika “ord” kan bildas om\n\nbokstäverna i strängen får blandas utan någon begränsning?\ninget a får stå till höger om ett c?\n\n\n\n\n\n\n\nLösningsförslag\n\n\n\n\n\n\nVi tänker oss till en början att vi har strängen med två olika a, b och c; nämligen a1, a2, b1, b2, c1, c2. Dessa kommer förstås att kunna permuteras på \\(6!\\) olika sätt. Men nu låter vi a1 och a2 förenas till två identiska a:n, varför vi får strängen a, a, b1, b2, c1, c2. Eftersom a kan permuteras på \\(2!\\) olika sätt så blir antalet permutationer \\(6!/2!\\) (där det alltså inte spelar någon roll vilket a som står på respektive plats). Vi fortsätter resonemanget på samma sätt med b, c och d, och landar i att antalet permutationer blir \\(8!/(2!\\cdot 2!\\cdot 2!\\cdot 2!)=2\\,520\\).\nHär får vi tänka på ett annat sätt. Vi börjar med att välja lägena för respektive bokstav b, b, d, d. Därefter väljer vi platserna för respektive bokstav a, a, c, c “manuellt” så att ordningen uppfylls; det kan ses som att a, a, c, c är identiska bokstäver som ska placeras. Antalet sätt blir då \\(8!/(2!\\cdot 2!\\cdot 4!)=420\\).\n\n\n\n\n\n\n\n\nTio basketbollar ska placeras i fyra burar. På hur många sätt kan det ske om\n\ningen begränsning av antalet bollar görs per bur (dvs en bur kan vara alltifrån tom till att den innehåller alla tio bollar)?\nvarje bur måste innehålla minst en boll?\n\n\n\n\n\n\n\nLösningsförslag\n\n\n\n\n\n\nHär kan metoden “Stars and Bars” tillämpas, där bollarna är “stars” och burarna är de mellanrum som bildas mellan “bars”. Ett exempel på utfall är **|****||****, vilket visar två bollar i bur \\(1\\), fyra bollar i bur \\(2\\), inga bollar i bur \\(3\\) och fyra bollar i bur \\(4\\). Vi har totalt tretton element (tio “stars” och tre “bars”) och antalet bollar i respektive mellanrum kan förändras genom att vi flyttar på “bars”. Eftersom det är tre “bars” (vilket ju ger fyra burar) blir antalet sätt \\[\n\\binom{10+4-1}{4-1}=\\binom{13}{3}=286\n\\]\nHär måste vi redan från början tänka oss att en boll ligger i respektive bur. Då blir det sex bollar (eller “stars”) kvar att fördela på de fyra burarna. Analogt med a-uppgiften så blir antalet sätt\n\n\\[\n\\binom{6+4-1}{4-1}=\\binom{9}{3}=84\n\\]\n\n\n\n\n\n\n\nHur många lösningar har ekvationen \\(x_1+x_2+x_3+x_4=10\\) om\n\nalla ingående termer är icke-negativa heltal?\nvar och en av de ingående termer är ett heltal som är minst 1?\n\n\n\n\n\n\n\nLösningsförslag\n\n\n\n\n\n\nDenna övnings lösning är exakt densamma som övningen med basketbollarna som skulle placeras i burarna, där varje bur får innehålla hur få eller hur många bollar som helst av det maximala antalet \\(10\\). Varje värde på respektive \\(x\\) är en “star”. Det är fyra stycken \\(x\\), vilket ger tre “bars” Lösningen blir \\[\n\\binom{10+4-1}{4-1}=\\binom{13}{3}=286\n\\]\nDenna övnings lösning är exakt densamma som övningen med basketbollarna som skulle placeras i burarna, där varje bur ska innehålla minst en boll. Lösningen blir \\[\n\\binom{6+4-1}{4-1}=\\binom{9}{3}=84\n\\]\n\n\n\n\n\n\n\n\nHur många torn kan maximalt placeras ut på ett schackbräde (\\(8\\times 8\\) rutor) om inget av tornen ska kunna “äta” något annat torn? Motivera svaret med lådprincipen.\n\n\n\n\n\n\nLösningsförslag\n\n\n\n\n\nEtt torn kan enbart gå i en enda rad och en enda kolumn. Det finns åtta rader och åtta kolumner på schackbrädet. Om det är fler än åtta torn så kommer minst en rad eller kolumn att innehålla fler än ett torn. (Tornen ska placeras ut diagonalt över brädet; det blir åtta stycken där inget av dem kan “äta” något annat torn.)\n\n\n\n\n\n\n\nEtt YATZY-kast är när fem stycken identiska, sexsidiga, tärningar slås. Hur många utfall finns det på ett sådant kast? Observera att ordningen saknar betydelse, t ex räknas utfallet [1, 1, 3, 5, 6] vara desamma som utfallet [1, 3, 1, 6, 5] om tärningarnas ordning räknas som [T1, T2, T3, T4, T5].\n\n\n\n\n\n\nLösningsförslag\n\n\n\n\n\nDetta är, liksom problemet med basketbollarna ovan, ett problem där metoden “Stars and Bars” kan tillämpas. Vi tänker oss fem tärningar (“stars”) och sex utfall (mellanrummen mellan “bars”), där varje tärnings visade tal ska placeras på ett av utfallen (ett utfall är t ex **|*||*||*, som representerar två ettor, en tvåa, en fyra och en sexa). Antalet utfall på ett kast blir \\[\n\\binom{5+6-1}{6-1}=252\n\\]\n\n\n\n\n\n\n\nEtt binomuttryck är \\((2x-3y)^{25}\\). Beräkna koefficienten som faktorn som innehåller \\(x^{12}y^{13}\\) multipliceras med.\n\n\n\n\n\n\nLösningsförslag\n\n\n\n\n\nBinomialsatsen ger direkt koefficienten \\[\n\\binom{25}{12}\\cdot 2^{12}\\cdot (-3)^{13}=-33\\, 959\\, 763\\, 545\\, 702\\, 400\n\\]\n\n\n\n\n\n\n\nJulias träffsäkerhet i ett kast mot mål i basket är \\(0.7\\). Beräkna sannolikheten att hon får\n\nminst en träff när hon kastar tio gånger.\nprecis fem träffar när hon kastar tio gånger.\nminst fem träffar när hon kastar tio gånger.\n\n\n\n\n\n\n\nLösningsförslag\n\n\n\n\n\n\nMinst en träff på tio kast är komplementhändelsen till ingen träff på tio kast. Detta ger sannolikheten för minst en träff till \\(1-0.3^{10}=99.999\\) %.\nAntalet möjliga placeringar i följden om tio kast, som de fem träffarna kan “väljas ut” på, är \\(\\binom{10}{5}\\); resterande antal placeringar är missarna. Det ger sannolikheten för precis fem träffar till \\[\n\\binom{10}{5}0.7^5\\cdot 0.3^5\\approx 10.3\\hspace{1mm}\\mathrm{\\%}\n\\]\nMinst fem träffar ges av summan\n\n\\[\n\\begin{matrix*}[l]\n\\hspace{3mm}\n\\binom{10}{5}0.7^5\\cdot 0.3^5 +\n\\binom{10}{6}0.7^6\\cdot 0.3^4 +\n\\binom{10}{7}0.7^7\\cdot 0.3^3\\\\[2mm] +\n\\binom{10}{8}0.7^8\\cdot 0.3^2 +\n\\binom{10}{9}0.7^9\\cdot 0.3^1\\\\[2mm] +\n\\binom{10}{10}0.7^{10}\\cdot 0.3^0\n\\approx 95.3\\hspace{1mm}\\mathrm{\\%}\n\\end{matrix*}\n\\]\n\n\n\n\n\n\n\nI en grupp som består av \\(23\\) personer så är sannolikheten \\(50.7\\) % att minst två personer har samma födelsedag på året. Visa detta.\n\n\n\n\n\n\nLösningsförslag\n\n\n\n\n\nMan kan tänka sig att personerna i gruppen är listade enligt [P1, P2, P3,..., P23]. Sannolikheten att P2 inte har samma födelsedag som P1 är \\(364/365\\). Sannolikheten att P3 inte har samma födelsedag som P1 eller P2 är \\(363/365\\) osv. Slutligen erhålls att sannolikheten för att alla \\(23\\) personer har olika födelsedagar är\n\\[\n\\frac{364}{365}\\cdot\\frac{363}{365}\\cdot\\frac{362}{365}\\cdot\n\\ldots\\cdot\\frac{343}{365}=\\left(\\frac{1}{365}\\right)^{23}\\cdot(365\\cdot 364\n\\cdot363\\ldots\\cdot343)\\approx 0.493\n\\]\nSannolikheten för komplementhändelsen till att alla födelsedagar är olika, vilken är att minst en person har gemensam födelsedag med någon annan i gruppen, ges av beräkningen \\(1-0.493=0.507\\), dvs \\(50.7\\) %.\nOrsaken att sannolikheten blir så stor för en så förhållandevis liten grupp är att antalet par i gruppen blir stort. Vi gör ingen förutsägelse om vilken födelsedag som kan vara gemensam, enbart att någon födelsedag är gemensam med en viss sannolikhet.\n\n\n\n\n\n\nSex personer, a, b, c, d, e och f ska bilda grupper om två och två. På hur många sätt kan detta ske om\n\nPerson a, b och c är gruppledare för varsina grupper?\nPerson a är gruppledare för en grupp, och de övriga grupperna saknar en given gruppledare?\nIngen grupp har någon given gruppledare?\n\n\n\n\n\n\n\nLösningsförslag\n\n\n\n\n\na-uppgiften\nFöljande illustration ger en idé om hur grupperna formeras:\nGrupp 1    Grupp 2    Grupp 3\n ---        ---        --- \n| a |      | b |      | c |\n|   |      |   |      |   |\n ---        ---        --- \nValbara personer till grupperna:\nd, e och f\nGrupp 1 kan välja en av tre personer, Grupp 2 en av två och till Grupp 3 kommer en enda person att kunna väljas på precis ett sätt. Eftersom a, b och c är givna så kommer det inte att kunna bli några dubletter av grupper (som det blir i nästa deluppgift). Antalet grupper blir, enligt multiplikationsprincipen, \\(3\\cdot 2\\cdot 1 = 6\\).\nb-uppgiften\nFöljande illustration visar hur grupperna formeras. Observera att vi från början har två “tomma grupper” dit personer ska väljas in.\nGrupp 1    Grupp 2    Grupp 3\n ---        ---        --- \n| a |      |   |      |   |\n|   |      |   |      |   |\n ---        ---        --- \nValbara personer till grupperna:\nb, c, d, e och f\nGrupp 1 ska välja en person, medan Grupp 2 och Grupp 3 ska välja två personer. Om vi enbart tecknar antalet konstellationer med multiplikationsprincipen,\n\\[\n\\binom{5}{1}\\binom{4}{2}\\binom{2}{2}=30\n\\]\nså kommer det att finnas fall där Grupp 2 och Grupp 3 i en konstellation är densamma som Grupp 3 och Grupp 2 i en annan konstellation. Detta beroende på att Grupp 2 och Grupp 3 inte innehåller något på förhand givet element. Därför måste vi dividera med antalet permutationer av dessa grupper, vilket är \\(2!\\).\nVi får det korrekta antalet grupper till\n\\[\n\\frac{\\binom{5}{1}\\binom{4}{2}\\binom{2}{2}}{2!}=15\n\\]\nVi behöver inte räkna den grupp med en given person först, ett annat sätt är att välja två personer av fem till Grupp 2 först, och därefter två personer av tre till Grupp 3. Sedan är Grupp 1 given, eftersom det enbart finns en person kvar att välja. Givetvis kan vi även välja Grupp 3 först, därefter Grupp 1 och sist Grupp 2.\n\\[\n\\frac{\\binom{5}{2}\\binom{3}{2}\\binom{1}{1}}{2!}\n=\\frac{\\binom{5}{2}\\binom{3}{1}\\binom{2}{2}}{2!}=15\n\\]\nc-uppgiften\nHär resonerar vi på precis samma sätt som i b-uppgiften, men nu ska till varje grupp ska väljas två personer. Eftersom ingen person är given på förhand till någon grupp så kommer det att bli multipler av konstellationerna. Detta kompenseras genom att dividera med antalet permutationer av alla grupper, vilket är \\(3!\\).\n\\[\n\\frac{\\binom{6}{2}\\binom{4}{2}\\binom{2}{2}}{3!}=15\n\\]\nLustigt nog blir det samma resultat som i b-uppgiften. Det beror på att när två grupper är valda så finns det enbart en möjlighet att välja den sista gruppen.",
    "crumbs": [
      "Home",
      "Matematik 5",
      "Kombinatorik: Extra övningar"
    ]
  },
  {
    "objectID": "ma/ma-5/kombinatorik/index.html#några-kompletterande-övningar",
    "href": "ma/ma-5/kombinatorik/index.html#några-kompletterande-övningar",
    "title": "Kombinatorik: Extra övningar",
    "section": "",
    "text": "Ett kodlås har en kod bestående av fyra siffror, där varje siffra kan väljas bland de tio siffrorna 0 – 9.\nHur många olika koder finns det om\n\ndet inte finns någon begränsning i hur siffrorna i koden får väljas?\ningen siffra får upprepas?\ningen siffra får får upprepas, och den tredje siffran är en \\(8\\)?\ningen siffra får upprepas, och koden måste vara i stigande nummerföljd?\ningen siffra får upprepas, och såväl siffran \\(2\\) som siffran \\(5\\) måste ingå?\n\n\n\n\n\n\n\nLösningsförslag\n\n\n\n\n\n\nRespektive siffra (\\(0\\) – \\(9\\)) kan väljas på varje plats i koden. Det gör att det totala antalet koder blir \\(10\\cdot 10\\cdot 10\\cdot 10=10^4\\)\nDen första siffran kan väljas på tio sätt, den andra på nio sätt, den tredje på åtta sätt och den fjärde på sju sätt. Det ger antalet koder till \\(P(10,4)=10\\cdot 9\\cdot 8\\cdot 7=5040\\).\nDen första siffran kan väljas på nio sätt, den andra på åtta sätt, den tredje på ett sätt och den fjärde på sju sätt. Det ger antalet koder till \\(P(10,4)=9\\cdot 8\\cdot 1\\cdot 7=504\\).\nHär ska vi räkna antalet oordnade urval på fyra siffror av tio. Eftersom ingen siffra får upprepas, och eftersom det därmed enbart finns en enda godtagbar nummerföljd per urval, så kommer antalet oordnade urval att ge det sökta antalet koder. Det blir \\(C(10,4)=210\\) st.\nHär väljer vi först de två siffror som ska ingå (utöver siffrorna 2 och 5). Det kan göras på \\(C(8,2)=28\\) olika sätt. Därefter ska de båda positionerna på dessa siffror väljas, det kan göras på \\(C(4,2)=6\\) sätt. Därefter ska placeringen av dessa siffror i de valda lägena bestämmas, det kan ske på \\(2!=2\\) sätt. Slutligen så ska placeringen i de kvarvarande lägena väljas för siffrorna \\(2\\) och \\(5\\), det kan också göras på \\(2!=2\\) sätt. Multiplikationsprincipen ger nu att det totala antalet koder blir \\(28\\cdot 6\\cdot 2\\cdot 2=672\\) stycken.\n\n\n\n\n\n\n\n\nEn kortlek består av 52 kort. På hur många sätt kan en blandning falla ut om\n\nalla blandningar är tillåtna?\nenbart de blandningar där ♣️3 ligger direkt ovanpå ♦️4 räknas?\n\n\n\n\n\n\n\nLösningsförslag\n\n\n\n\n\n\nEftersom alla kort är olika gäller att det översta kortet i en blandad lek kan vara \\(1\\) av \\(52\\), kortet under detta \\(1\\) av \\(51\\) osv. Det innebär att antalet blandningar kan vara \\(52\\cdot 51\\cdot 50\\cdot\\ldots\\cdot 1=52!\\). Multiplikationsprincipen ska tillämpas eftersom antalet möjligheter på en given plats i leken inte påverkas av vilka kort som ligger på andra platser.\nHär kan man tänka att det är \\(51\\) kort som ska blandas, t ex så tar vi bort ♣️3 ur leken. För varje utfall så tänker vi oss vidare att vi “manuellt” lägger in detta ♣️3 ovanpå ♦️4. \nAntalet sådana utfall blir alltså \\(51!\\).\n\n\n\n\n\n\n\n\nEn sträng består av bokstäverna a, a, b, b, c, c, d, d. Hur många olika “ord” kan bildas om\n\nbokstäverna i strängen får blandas utan någon begränsning?\ninget a får stå till höger om ett c?\n\n\n\n\n\n\n\nLösningsförslag\n\n\n\n\n\n\nVi tänker oss till en början att vi har strängen med två olika a, b och c; nämligen a1, a2, b1, b2, c1, c2. Dessa kommer förstås att kunna permuteras på \\(6!\\) olika sätt. Men nu låter vi a1 och a2 förenas till två identiska a:n, varför vi får strängen a, a, b1, b2, c1, c2. Eftersom a kan permuteras på \\(2!\\) olika sätt så blir antalet permutationer \\(6!/2!\\) (där det alltså inte spelar någon roll vilket a som står på respektive plats). Vi fortsätter resonemanget på samma sätt med b, c och d, och landar i att antalet permutationer blir \\(8!/(2!\\cdot 2!\\cdot 2!\\cdot 2!)=2\\,520\\).\nHär får vi tänka på ett annat sätt. Vi börjar med att välja lägena för respektive bokstav b, b, d, d. Därefter väljer vi platserna för respektive bokstav a, a, c, c “manuellt” så att ordningen uppfylls; det kan ses som att a, a, c, c är identiska bokstäver som ska placeras. Antalet sätt blir då \\(8!/(2!\\cdot 2!\\cdot 4!)=420\\).\n\n\n\n\n\n\n\n\nTio basketbollar ska placeras i fyra burar. På hur många sätt kan det ske om\n\ningen begränsning av antalet bollar görs per bur (dvs en bur kan vara alltifrån tom till att den innehåller alla tio bollar)?\nvarje bur måste innehålla minst en boll?\n\n\n\n\n\n\n\nLösningsförslag\n\n\n\n\n\n\nHär kan metoden “Stars and Bars” tillämpas, där bollarna är “stars” och burarna är de mellanrum som bildas mellan “bars”. Ett exempel på utfall är **|****||****, vilket visar två bollar i bur \\(1\\), fyra bollar i bur \\(2\\), inga bollar i bur \\(3\\) och fyra bollar i bur \\(4\\). Vi har totalt tretton element (tio “stars” och tre “bars”) och antalet bollar i respektive mellanrum kan förändras genom att vi flyttar på “bars”. Eftersom det är tre “bars” (vilket ju ger fyra burar) blir antalet sätt \\[\n\\binom{10+4-1}{4-1}=\\binom{13}{3}=286\n\\]\nHär måste vi redan från början tänka oss att en boll ligger i respektive bur. Då blir det sex bollar (eller “stars”) kvar att fördela på de fyra burarna. Analogt med a-uppgiften så blir antalet sätt\n\n\\[\n\\binom{6+4-1}{4-1}=\\binom{9}{3}=84\n\\]\n\n\n\n\n\n\n\nHur många lösningar har ekvationen \\(x_1+x_2+x_3+x_4=10\\) om\n\nalla ingående termer är icke-negativa heltal?\nvar och en av de ingående termer är ett heltal som är minst 1?\n\n\n\n\n\n\n\nLösningsförslag\n\n\n\n\n\n\nDenna övnings lösning är exakt densamma som övningen med basketbollarna som skulle placeras i burarna, där varje bur får innehålla hur få eller hur många bollar som helst av det maximala antalet \\(10\\). Varje värde på respektive \\(x\\) är en “star”. Det är fyra stycken \\(x\\), vilket ger tre “bars” Lösningen blir \\[\n\\binom{10+4-1}{4-1}=\\binom{13}{3}=286\n\\]\nDenna övnings lösning är exakt densamma som övningen med basketbollarna som skulle placeras i burarna, där varje bur ska innehålla minst en boll. Lösningen blir \\[\n\\binom{6+4-1}{4-1}=\\binom{9}{3}=84\n\\]\n\n\n\n\n\n\n\n\nHur många torn kan maximalt placeras ut på ett schackbräde (\\(8\\times 8\\) rutor) om inget av tornen ska kunna “äta” något annat torn? Motivera svaret med lådprincipen.\n\n\n\n\n\n\nLösningsförslag\n\n\n\n\n\nEtt torn kan enbart gå i en enda rad och en enda kolumn. Det finns åtta rader och åtta kolumner på schackbrädet. Om det är fler än åtta torn så kommer minst en rad eller kolumn att innehålla fler än ett torn. (Tornen ska placeras ut diagonalt över brädet; det blir åtta stycken där inget av dem kan “äta” något annat torn.)\n\n\n\n\n\n\n\nEtt YATZY-kast är när fem stycken identiska, sexsidiga, tärningar slås. Hur många utfall finns det på ett sådant kast? Observera att ordningen saknar betydelse, t ex räknas utfallet [1, 1, 3, 5, 6] vara desamma som utfallet [1, 3, 1, 6, 5] om tärningarnas ordning räknas som [T1, T2, T3, T4, T5].\n\n\n\n\n\n\nLösningsförslag\n\n\n\n\n\nDetta är, liksom problemet med basketbollarna ovan, ett problem där metoden “Stars and Bars” kan tillämpas. Vi tänker oss fem tärningar (“stars”) och sex utfall (mellanrummen mellan “bars”), där varje tärnings visade tal ska placeras på ett av utfallen (ett utfall är t ex **|*||*||*, som representerar två ettor, en tvåa, en fyra och en sexa). Antalet utfall på ett kast blir \\[\n\\binom{5+6-1}{6-1}=252\n\\]\n\n\n\n\n\n\n\nEtt binomuttryck är \\((2x-3y)^{25}\\). Beräkna koefficienten som faktorn som innehåller \\(x^{12}y^{13}\\) multipliceras med.\n\n\n\n\n\n\nLösningsförslag\n\n\n\n\n\nBinomialsatsen ger direkt koefficienten \\[\n\\binom{25}{12}\\cdot 2^{12}\\cdot (-3)^{13}=-33\\, 959\\, 763\\, 545\\, 702\\, 400\n\\]\n\n\n\n\n\n\n\nJulias träffsäkerhet i ett kast mot mål i basket är \\(0.7\\). Beräkna sannolikheten att hon får\n\nminst en träff när hon kastar tio gånger.\nprecis fem träffar när hon kastar tio gånger.\nminst fem träffar när hon kastar tio gånger.\n\n\n\n\n\n\n\nLösningsförslag\n\n\n\n\n\n\nMinst en träff på tio kast är komplementhändelsen till ingen träff på tio kast. Detta ger sannolikheten för minst en träff till \\(1-0.3^{10}=99.999\\) %.\nAntalet möjliga placeringar i följden om tio kast, som de fem träffarna kan “väljas ut” på, är \\(\\binom{10}{5}\\); resterande antal placeringar är missarna. Det ger sannolikheten för precis fem träffar till \\[\n\\binom{10}{5}0.7^5\\cdot 0.3^5\\approx 10.3\\hspace{1mm}\\mathrm{\\%}\n\\]\nMinst fem träffar ges av summan\n\n\\[\n\\begin{matrix*}[l]\n\\hspace{3mm}\n\\binom{10}{5}0.7^5\\cdot 0.3^5 +\n\\binom{10}{6}0.7^6\\cdot 0.3^4 +\n\\binom{10}{7}0.7^7\\cdot 0.3^3\\\\[2mm] +\n\\binom{10}{8}0.7^8\\cdot 0.3^2 +\n\\binom{10}{9}0.7^9\\cdot 0.3^1\\\\[2mm] +\n\\binom{10}{10}0.7^{10}\\cdot 0.3^0\n\\approx 95.3\\hspace{1mm}\\mathrm{\\%}\n\\end{matrix*}\n\\]\n\n\n\n\n\n\n\nI en grupp som består av \\(23\\) personer så är sannolikheten \\(50.7\\) % att minst två personer har samma födelsedag på året. Visa detta.\n\n\n\n\n\n\nLösningsförslag\n\n\n\n\n\nMan kan tänka sig att personerna i gruppen är listade enligt [P1, P2, P3,..., P23]. Sannolikheten att P2 inte har samma födelsedag som P1 är \\(364/365\\). Sannolikheten att P3 inte har samma födelsedag som P1 eller P2 är \\(363/365\\) osv. Slutligen erhålls att sannolikheten för att alla \\(23\\) personer har olika födelsedagar är\n\\[\n\\frac{364}{365}\\cdot\\frac{363}{365}\\cdot\\frac{362}{365}\\cdot\n\\ldots\\cdot\\frac{343}{365}=\\left(\\frac{1}{365}\\right)^{23}\\cdot(365\\cdot 364\n\\cdot363\\ldots\\cdot343)\\approx 0.493\n\\]\nSannolikheten för komplementhändelsen till att alla födelsedagar är olika, vilken är att minst en person har gemensam födelsedag med någon annan i gruppen, ges av beräkningen \\(1-0.493=0.507\\), dvs \\(50.7\\) %.\nOrsaken att sannolikheten blir så stor för en så förhållandevis liten grupp är att antalet par i gruppen blir stort. Vi gör ingen förutsägelse om vilken födelsedag som kan vara gemensam, enbart att någon födelsedag är gemensam med en viss sannolikhet.\n\n\n\n\n\n\nSex personer, a, b, c, d, e och f ska bilda grupper om två och två. På hur många sätt kan detta ske om\n\nPerson a, b och c är gruppledare för varsina grupper?\nPerson a är gruppledare för en grupp, och de övriga grupperna saknar en given gruppledare?\nIngen grupp har någon given gruppledare?\n\n\n\n\n\n\n\nLösningsförslag\n\n\n\n\n\na-uppgiften\nFöljande illustration ger en idé om hur grupperna formeras:\nGrupp 1    Grupp 2    Grupp 3\n ---        ---        --- \n| a |      | b |      | c |\n|   |      |   |      |   |\n ---        ---        --- \nValbara personer till grupperna:\nd, e och f\nGrupp 1 kan välja en av tre personer, Grupp 2 en av två och till Grupp 3 kommer en enda person att kunna väljas på precis ett sätt. Eftersom a, b och c är givna så kommer det inte att kunna bli några dubletter av grupper (som det blir i nästa deluppgift). Antalet grupper blir, enligt multiplikationsprincipen, \\(3\\cdot 2\\cdot 1 = 6\\).\nb-uppgiften\nFöljande illustration visar hur grupperna formeras. Observera att vi från början har två “tomma grupper” dit personer ska väljas in.\nGrupp 1    Grupp 2    Grupp 3\n ---        ---        --- \n| a |      |   |      |   |\n|   |      |   |      |   |\n ---        ---        --- \nValbara personer till grupperna:\nb, c, d, e och f\nGrupp 1 ska välja en person, medan Grupp 2 och Grupp 3 ska välja två personer. Om vi enbart tecknar antalet konstellationer med multiplikationsprincipen,\n\\[\n\\binom{5}{1}\\binom{4}{2}\\binom{2}{2}=30\n\\]\nså kommer det att finnas fall där Grupp 2 och Grupp 3 i en konstellation är densamma som Grupp 3 och Grupp 2 i en annan konstellation. Detta beroende på att Grupp 2 och Grupp 3 inte innehåller något på förhand givet element. Därför måste vi dividera med antalet permutationer av dessa grupper, vilket är \\(2!\\).\nVi får det korrekta antalet grupper till\n\\[\n\\frac{\\binom{5}{1}\\binom{4}{2}\\binom{2}{2}}{2!}=15\n\\]\nVi behöver inte räkna den grupp med en given person först, ett annat sätt är att välja två personer av fem till Grupp 2 först, och därefter två personer av tre till Grupp 3. Sedan är Grupp 1 given, eftersom det enbart finns en person kvar att välja. Givetvis kan vi även välja Grupp 3 först, därefter Grupp 1 och sist Grupp 2.\n\\[\n\\frac{\\binom{5}{2}\\binom{3}{2}\\binom{1}{1}}{2!}\n=\\frac{\\binom{5}{2}\\binom{3}{1}\\binom{2}{2}}{2!}=15\n\\]\nc-uppgiften\nHär resonerar vi på precis samma sätt som i b-uppgiften, men nu ska till varje grupp ska väljas två personer. Eftersom ingen person är given på förhand till någon grupp så kommer det att bli multipler av konstellationerna. Detta kompenseras genom att dividera med antalet permutationer av alla grupper, vilket är \\(3!\\).\n\\[\n\\frac{\\binom{6}{2}\\binom{4}{2}\\binom{2}{2}}{3!}=15\n\\]\nLustigt nog blir det samma resultat som i b-uppgiften. Det beror på att när två grupper är valda så finns det enbart en möjlighet att välja den sista gruppen.",
    "crumbs": [
      "Home",
      "Matematik 5",
      "Kombinatorik: Extra övningar"
    ]
  },
  {
    "objectID": "pr1/python/while-loopar/presentation/index.html#uppgifter",
    "href": "pr1/python/while-loopar/presentation/index.html#uppgifter",
    "title": "Presentation: while-loopar",
    "section": "Uppgifter",
    "text": "Uppgifter\nUppgifterna 1 – 7 i dokumentet Uppgifter Pr1, loopar",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Presentationer, Python",
      "Presentation: `while`-loopar"
    ]
  },
  {
    "objectID": "pr1/python/spara-data-pa-fil/presentation/index.html#uppgifter",
    "href": "pr1/python/spara-data-pa-fil/presentation/index.html#uppgifter",
    "title": "Presentation: Spara data till fil",
    "section": "Uppgifter",
    "text": "Uppgifter\nUppgifterna i dokumentet Uppgifter Pr1, Spara objekt",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Presentationer, Python",
      "Presentation: Spara data till fil"
    ]
  },
  {
    "objectID": "pr1/python/funktioner/presentation/index.html#uppgifter",
    "href": "pr1/python/funktioner/presentation/index.html#uppgifter",
    "title": "Presentation: Funktioner",
    "section": "Uppgifter",
    "text": "Uppgifter\nUppgifterna i dokumentet Uppgifter Pr1, funktioner",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Presentationer, Python",
      "Presentation: Funktioner"
    ]
  },
  {
    "objectID": "pr1/python/for-loopar/presentation/index.html#uppgifter",
    "href": "pr1/python/for-loopar/presentation/index.html#uppgifter",
    "title": "Presentation: for-loopar",
    "section": "Uppgifter",
    "text": "Uppgifter\nUppgifterna 8 – 10 i dokumentet Uppgifter Pr1, loopar",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Presentationer, Python",
      "Presentation: `for`-loopar"
    ]
  },
  {
    "objectID": "pr1/python/strangar/presentation/strangar-pres.html#dagens-mål",
    "href": "pr1/python/strangar/presentation/strangar-pres.html#dagens-mål",
    "title": "Strängar i Python",
    "section": "Dagens mål",
    "text": "Dagens mål\n\nAtt känna till datatypen str\nAtt kunna komma åt enskilda tecken i en sträng\nAtt kunna applicera olika metoder på en sträng"
  },
  {
    "objectID": "pr1/python/strangar/presentation/strangar-pres.html#vad-är-en-sträng",
    "href": "pr1/python/strangar/presentation/strangar-pres.html#vad-är-en-sträng",
    "title": "Strängar i Python",
    "section": "Vad är en sträng?",
    "text": "Vad är en sträng?\n\n\n\n\nEn sträng är en följd av tecken. Ofta används dessa för någon form av utmatning i programmet.\nDen datatyp som representerar en sträng i Python kallas str.\nSträngar har vissa saker gemensamt med listor; t ex så har varje tecken ett index, som gör att det kan adresseras."
  },
  {
    "objectID": "pr1/python/strangar/presentation/strangar-pres.html#exempel-på-en-sträng",
    "href": "pr1/python/strangar/presentation/strangar-pres.html#exempel-på-en-sträng",
    "title": "Strängar i Python",
    "section": "Exempel på en sträng",
    "text": "Exempel på en sträng\n\n\n\nmy_string = \"Hello, world\"\nTexten Hello, world kallas för en strängkonstant eller strängliteral. Denna strängkonstant måste vara given inom citationstecken."
  },
  {
    "objectID": "pr1/python/strangar/presentation/strangar-pres.html#strängar-jämfört-med-listor",
    "href": "pr1/python/strangar/presentation/strangar-pres.html#strängar-jämfört-med-listor",
    "title": "Strängar i Python",
    "section": "Strängar jämfört med listor",
    "text": "Strängar jämfört med listor\nVarje teckenläge i en sträng har ett index. Det går att nå ett tecken med hjälp av detta index.\n\nmy_string = \"Hello, world\"\nprint(f\"Strängkonstanten är: {my_string}\")\nprint(f\"Strängkonstantens första tecken är: {my_string[0]}\")\nprint(f\"Tecknet \\\"o\\\" finns första gången på index: {my_string.index('o')}\")\n\nSträngkonstanten är: Hello, world\nSträngkonstantens första tecken är: H\nTecknet \"o\" finns första gången på index: 4\n\n\nEn skillnad mot listor är att strängar inte går att förändra. Vi kan inte lägga till ett tecken med något som liknar append() eller ta bort ett tecken med något som liknar remove().\nInnehållet i en sträng kallas som sagt strängkonstant."
  },
  {
    "objectID": "pr1/python/strangar/presentation/strangar-pres.html#delsträngar",
    "href": "pr1/python/strangar/presentation/strangar-pres.html#delsträngar",
    "title": "Strängar i Python",
    "section": "Delsträngar",
    "text": "Delsträngar\n\n\n\nPå samma sätt som med listor går det att ta fram en delsträng enligt följande.\n\nmy_str = \"Detta är en sträng som består av 42 tecken\"\nprint(my_str[:8])\nprint(my_str[19:29])\nprint(my_str[33:])\n\nDetta är\nsom består\n42 tecken"
  },
  {
    "objectID": "pr1/python/strangar/presentation/strangar-pres.html#loopa-genom-strängar",
    "href": "pr1/python/strangar/presentation/strangar-pres.html#loopa-genom-strängar",
    "title": "Strängar i Python",
    "section": "Loopa genom strängar",
    "text": "Loopa genom strängar\n\n\n\nDet går att loopa genom en sträng och på så sätt gå igenom tecken för tecken. I följande exempel skrivs vokalerna ut i en sträng samtidigt som övriga tecken maskeras.\n\nvowels = \"aeiouyåäö\"\nchars = \"Hello, world\"\nfor char in chars:\n    if char.lower() in vowels:\n        print(char, end=\"\")\n    else:\n        print(\"*\", end=\"\")\n\n*e**o***o***"
  },
  {
    "objectID": "pr1/python/strangar/presentation/strangar-pres.html#skapa-en-ny-sträng-utifrån-ett-original",
    "href": "pr1/python/strangar/presentation/strangar-pres.html#skapa-en-ny-sträng-utifrån-ett-original",
    "title": "Strängar i Python",
    "section": "Skapa en ny sträng utifrån ett original",
    "text": "Skapa en ny sträng utifrån ett original\nExempel: skriva ut vokalerna i en sträng.\n\nvowels = \"aeiouyåäö\"\nsource = \"Hello, world\"\ndestination = \"\"\nfor char in source:\n    if char.lower() in vowels:\n        destination += char\n    else:\n        destination += \"*\"\nprint(destination)\n\n*e**o***o***\n\n\nEffekten är bl a att valda delar av source kopieras till destination med additionsoperatorn."
  },
  {
    "objectID": "pr1/python/strangar/presentation/strangar-pres.html#strängmetoder",
    "href": "pr1/python/strangar/presentation/strangar-pres.html#strängmetoder",
    "title": "Strängar i Python",
    "section": "Strängmetoder",
    "text": "Strängmetoder\nVi har redan sett exempel på strängmetoder: .index(), som returnerar indexnumret för första förekomsten av ett tecken i en sträng, och .lower(), vilken returnerar samma sträng som vi tillämpar metoden på, men alla alfanumeriska tecken blir gemener (“små bokstäver”).\nFler exempel på användbara strängmetoder finns på detta “cheat sheet”."
  },
  {
    "objectID": "pr1/python/strangar/presentation/strangar-pres.html#fejka-förändring",
    "href": "pr1/python/strangar/presentation/strangar-pres.html#fejka-förändring",
    "title": "Strängar i Python",
    "section": "Fejka förändring",
    "text": "Fejka förändring\nSträngmetoder förändrar inte strängen.\n\nmy_str = \"Detta är en sträng som består av 42 tecken\"\nmy_upper_str = my_str.upper()\nprint(my_str)\nprint(my_upper_str)\n\nDetta är en sträng som består av 42 tecken\nDETTA ÄR EN STRÄNG SOM BESTÅR AV 42 TECKEN\n\n\n\n\n\nDet går också att tilldela den gamla strängens namn det nya värdet.\n\nmy_str = \"Detta är en sträng som består av 42 tecken\"\nmy_str = my_str.upper()\nprint(my_str)\n\nDETTA ÄR EN STRÄNG SOM BESTÅR AV 42 TECKEN"
  },
  {
    "objectID": "pr1/python/strangar/presentation/strangar-pres.html#sammanfattning",
    "href": "pr1/python/strangar/presentation/strangar-pres.html#sammanfattning",
    "title": "Strängar i Python",
    "section": "Sammanfattning",
    "text": "Sammanfattning\n\nSträngar i ett datorprogram är en följd av tecken\nPå samma sätt som listor så kan enskilda tecken kommas åt med sitt indexnummer\nTill skillnad från listor så kan strängen inte förändras…\n… men vi kan få en “effekt” av en förändring t ex genom användning av additionsoperatorn (den gamla strängen skrivs då över)\nDet finns strängmetoder med vars hjälp det går att utföra olika operationer på strängar"
  },
  {
    "objectID": "pr1/python/klasser-och-metoder/presentation/index.html#uppgifter",
    "href": "pr1/python/klasser-och-metoder/presentation/index.html#uppgifter",
    "title": "Presentation: Klasser och metoder",
    "section": "Uppgifter",
    "text": "Uppgifter\nUppgifterna i dokumentet Uppgifter Pr1, Klasser och metoder",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Presentationer, Python",
      "Presentation: Klasser och metoder"
    ]
  },
  {
    "objectID": "pr1/python/egna-datatyper/presentation/egna-datyper.html#dagens-mål",
    "href": "pr1/python/egna-datatyper/presentation/egna-datyper.html#dagens-mål",
    "title": "Egna datatyper i Python",
    "section": "Dagens mål",
    "text": "Dagens mål\n\nAtt kunna skapa egna datatyper\nAtt känna till skillnaden mellan datatyp och objekt\nAtt läsa och tilldela datatypen attribut\nAtt kunna skicka objekt för vidare process i funktioner"
  },
  {
    "objectID": "pr1/python/egna-datatyper/presentation/egna-datyper.html#grundläggande-datatyper",
    "href": "pr1/python/egna-datatyper/presentation/egna-datyper.html#grundläggande-datatyper",
    "title": "Egna datatyper i Python",
    "section": "Grundläggande datatyper",
    "text": "Grundläggande datatyper\n\n\n\n\nVi har tidigare använt datatyperna heltal, flyttal, listor mm.\nDessa deklareras t ex som\nmy_int = 5 # Heltal\nmy_str = \"Hello, world\" # sträng\nI programmering behövs ofta variabler som representerar något ‘’riktigt’’, t ex en bil, en person eller en avatar som har olika egenskaper."
  },
  {
    "objectID": "pr1/python/egna-datatyper/presentation/egna-datyper.html#deklarera-en-egen-datatyp",
    "href": "pr1/python/egna-datatyper/presentation/egna-datyper.html#deklarera-en-egen-datatyp",
    "title": "Egna datatyper i Python",
    "section": "Deklarera en egen datatyp",
    "text": "Deklarera en egen datatyp\n\n\n\nVi kan deklarera en variabeltyp Car på det här sättet:\n\nclass Car:\n    brand = \"\"  # Tom sträng för bilmärket, så länge\n    color = \"\"  # Tom sträng för färgen, så länge\n    model_year = 0  # Aktuell årsmodell sätts senare\n\n\n\n\nNu har vi tillgång till datatypen Car, och kan skapa variabler av denna typ. I var och en av dessa variabler ingår de olika attributen (brand, color och model_year)."
  },
  {
    "objectID": "pr1/python/egna-datatyper/presentation/egna-datyper.html#skapa-objekt",
    "href": "pr1/python/egna-datatyper/presentation/egna-datyper.html#skapa-objekt",
    "title": "Egna datatyper i Python",
    "section": "Skapa objekt",
    "text": "Skapa objekt\nNär en variabel skapas av en viss datatyp kallas det för att ett objekt, eller en instans av denna typ skapas.\n\n# Här skaps objekten a_car och b_car\na_car = Car()\nb_car = Car()\n\nNu kan vi sätta respektive objekts attribut.\n\na_car.brand = \"Volvo\"\na_car.color = \"Blue\"\na_car.model_year = 2005\nb_car.brand = \"Tesla\"\nb_car.color = \"White\"\nb_car.model_year = 2020\n\nNu innehåller a_car och b_car sin aktuella information."
  },
  {
    "objectID": "pr1/python/egna-datatyper/presentation/egna-datyper.html#använda-attribut",
    "href": "pr1/python/egna-datatyper/presentation/egna-datyper.html#använda-attribut",
    "title": "Egna datatyper i Python",
    "section": "Använda attribut",
    "text": "Använda attribut\nVi använder samma syntax för att extrahera information från ett objekt som vi gjorde när vi satte det.\n\nprint(f\"a_car årsmodell: {a_car.model_year}\")\nprint(f\"a_car märke: {a_car.brand}\")\nprint(f\"b_car årsmodell: {b_car.model_year}\")\nprint(\"a_car är älde än b_car\") if b_car.model_year &gt; a_car.model_year else print(\"a_car är äldre än b_car\")\n\na_car årsmodell: 2005\na_car märke: Volvo\nb_car årsmodell: 2020\na_car är älde än b_car\n\n\nPå det här sättet kan många variabler skapas av en och samma typ, som alla innehåller sin unika information. Det är användbart i t ex register och spel."
  },
  {
    "objectID": "pr1/python/egna-datatyper/presentation/egna-datyper.html#exempel-en-spelares-position",
    "href": "pr1/python/egna-datatyper/presentation/egna-datyper.html#exempel-en-spelares-position",
    "title": "Egna datatyper i Python",
    "section": "Exempel: en spelares position",
    "text": "Exempel: en spelares position\n\nimport random as rand\nclass Player():\n  position_x = 0\n  position_y = 0\n\ndef set_position(current_player): # En funktion som slumpar fram ett läge\n  x = rand.randint(0, 10)\n  y = rand.randint(0, 10)\n  current_player.position_x = x   # Sätt den aktuella instansens läge\n  current_player.position_y = y\n\nplayer_1 = Player() # Skapar två instanser av Player\nplayer_2 = Player()\n\nset_position(player_1) # Sätter ett slumpvis valt läge för player_1\nset_position(player_2) # Sätter ett slumpvis valt läge för player_2\nprint(f\"Player 1 at ({player_1.position_x}, {player_1.position_y})\")\nprint(f\"Player 2 at ({player_2.position_x}, {player_2.position_y})\")\n\nPlayer 1 at (8, 4)\nPlayer 2 at (4, 4)"
  },
  {
    "objectID": "pr1/python/egna-datatyper/presentation/egna-datyper.html#referenser",
    "href": "pr1/python/egna-datatyper/presentation/egna-datyper.html#referenser",
    "title": "Egna datatyper i Python",
    "section": "Referenser",
    "text": "Referenser\nVi tittar på funktionen set_position(player) igen\n\ndef set_position(current_player): # En funktion som slumpar fram ett läge\n  x = rand.randint(0, 10)\n  y = rand.randint(0, 10)\n  player.position_x = x   # Sätt den aktuella instansens läge\n  player.position_y = y\n\nNär current_player är av en egendefinierad datatyp, som t ex Player, så opererar funktionen på just detta objekt. Man säger att current_player är en referens, ett alias, till det objekt som funktionen anropas med.\nNär en funktion tar emot t ex ett tal så kommer istället en kopia av den variabeln att skapas i funktionen, och det ursprungliga värdet ändras inte."
  },
  {
    "objectID": "pr1/python/egna-datatyper/presentation/egna-datyper.html#sammanfattning",
    "href": "pr1/python/egna-datatyper/presentation/egna-datyper.html#sammanfattning",
    "title": "Egna datatyper i Python",
    "section": "Sammanfattning",
    "text": "Sammanfattning\n\nEgendefinierade datatyper deklareras med hjälp av nyckelordet class\nVariablerna i klassen kallas för attribut\nEn instans av en sådan datyp skapas enligt syntaxen my_var = My_type()\nAttribut kan kommas åt med punkt-operatorn, enligt syntaxen my_var.x\nNär en funktion tar emot en egendefinierad datatyp så opererar den på originalobjektet"
  },
  {
    "objectID": "pr1/python/listor/presentation/listor-pres.html#dagens-mål",
    "href": "pr1/python/listor/presentation/listor-pres.html#dagens-mål",
    "title": "Listor i Python",
    "section": "Dagens mål",
    "text": "Dagens mål\n\nAtt känna till datatypen list\nAtt kunna skapa listor med element av olika datatyper\nAtt kunna komma åt enskilda element i en lista"
  },
  {
    "objectID": "pr1/python/listor/presentation/listor-pres.html#vad-är-en-lista",
    "href": "pr1/python/listor/presentation/listor-pres.html#vad-är-en-lista",
    "title": "Listor i Python",
    "section": "Vad är en lista?",
    "text": "Vad är en lista?\n\n\n\n\nEn lista är en s.k datastruktur som organiserar värden i en följd. Listan är också en variabel, som alltså består av en samling värden. Dessa värden kan man komma åt ett och ett, men istället för att ha ett stort antal variabler kan man alltså ha en enda lista som innehåller många värden.\nEtt exempel som kan motivera en lista i programmeringen är då ett namnregister ska hanteras."
  },
  {
    "objectID": "pr1/python/listor/presentation/listor-pres.html#exempel-på-en-lista",
    "href": "pr1/python/listor/presentation/listor-pres.html#exempel-på-en-lista",
    "title": "Listor i Python",
    "section": "Exempel på en lista",
    "text": "Exempel på en lista\n\n\n\nExempel på en lista som lagrar temperaturer:\n           -----------------------\nInnehåll   | 10 | 12 | 8 | 9 | 7 |   &lt;- Här är temperaturerna\n           -----------------------\nIndexnr.     0    1    2   3   4     &lt;- Ett index är ett ordningstal\n\n\n\nVariabeldeklaration:\n\ntemperaturer = [10, 12, 8, 9, 7] # EN variabel för FEM temperaturer\n\n\n\n\n\nprint(temperaturer[0]) # Skriver ut innehållet av index 0\nprint(temperaturer[4]) # Skriver ut innehållet av index 4\n\n10\n7"
  },
  {
    "objectID": "pr1/python/listor/presentation/listor-pres.html#vad-var-nu-en-lista",
    "href": "pr1/python/listor/presentation/listor-pres.html#vad-var-nu-en-lista",
    "title": "Listor i Python",
    "section": "Vad var nu en lista?",
    "text": "Vad var nu en lista?\n\nEn lista är alltså en variabel som innehåller flera olika värden. Värdena finns i “fack”, vart och ett med ett index (ordningsnummer).\nIndexet börjar med 0. Om det t ex finns 10 värden i en lista kommer man åt innehållet i “facken” genom index 0 - 9.\nAlla olika typer av variabler är tillåtna i en lista."
  },
  {
    "objectID": "pr1/python/listor/presentation/listor-pres.html#att-skapa-listor",
    "href": "pr1/python/listor/presentation/listor-pres.html#att-skapa-listor",
    "title": "Listor i Python",
    "section": "Att skapa listor",
    "text": "Att skapa listor\n\n\n\nOm du vet vilka värden som ska vara med från början:\nmin_lista = [10, -2, 6, 3]\n\n\n\nOm du behöver lägga till värden i efterhand:\nscores = []       # Skapar en tom lista\nscores.append(42) # Lägger till talet 42 i den från början tomma listan\n\n\n\nÄven om listan inte är tom går det att lägga till värden med hjälp av append."
  },
  {
    "objectID": "pr1/python/listor/presentation/listor-pres.html#att-skapa-listor-forts",
    "href": "pr1/python/listor/presentation/listor-pres.html#att-skapa-listor-forts",
    "title": "Listor i Python",
    "section": "Att skapa listor (forts)",
    "text": "Att skapa listor (forts)\n\n\n\nVi har redan tidigare gått igenom funktionen range. Här skapas en lista med talen -4, -1, 2 och 5:\n\n\n\n\nlst = list(range(-4, 6, 3))\nprint(lst)\n\n[-4, -1, 2, 5]"
  },
  {
    "objectID": "pr1/python/listor/presentation/listor-pres.html#loopa-genom-listor",
    "href": "pr1/python/listor/presentation/listor-pres.html#loopa-genom-listor",
    "title": "Listor i Python",
    "section": "Loopa genom listor",
    "text": "Loopa genom listor\n\n\n\nVi har också tidigare gått igenom for-loopar, som kan användas då man behöver gå igenom ett listelement i taget.\nFöljande exempel fanns i presentationen om for-loopar.\n\n\n\nitems = [\"Klocka\", \"Kikare\", \"Termometer\"]\nfor item in items:\n    if item.is_boostable:\n      item.boost()\n      print(f\"Din {item} är nu boostad ✅\")\n    else:\n      print(f\"{item} gick inte att boosta ❌\")"
  },
  {
    "objectID": "pr1/python/listor/presentation/listor-pres.html#listors-funktioner-och-metoder",
    "href": "pr1/python/listor/presentation/listor-pres.html#listors-funktioner-och-metoder",
    "title": "Listor i Python",
    "section": "Listors funktioner och metoder",
    "text": "Listors funktioner och metoder\n\nDet finns många funktioner för att hantera listor. Det går bl.a att sortera element, ta bort element, räkna antalet element, reversera listan, summera element och välja ut en delmängd av elementen. Exempel på detta påvisas i övningarna."
  },
  {
    "objectID": "pr1/python/listor/presentation/listor-pres.html#sammanfattning",
    "href": "pr1/python/listor/presentation/listor-pres.html#sammanfattning",
    "title": "Listor i Python",
    "section": "Sammanfattning",
    "text": "Sammanfattning\n\nListor används för att samla flera värden under ett enda variabelnamn\nMan kommer åt de enskilda elementen med dess index\nIndex-räkningen börjar på noll\nDet finns funktionalitet för att göra olika operationer på en lista"
  },
  {
    "objectID": "pr1/python/villkor/presentation/villkor-pres.html#vad-är-ett-villkor",
    "href": "pr1/python/villkor/presentation/villkor-pres.html#vad-är-ett-villkor",
    "title": "Villkor i Python",
    "section": "Vad är ett villkor?",
    "text": "Vad är ett villkor?\n\nEtt datorprogram är en följd av instruktioner. Dessa instruktioner kan baseras på indata. Beroende på vilka indata som ges kan programmet behöva ta olika vägar.\nDet som avgör vilken väg programmet ska ta ka kallas villkor."
  },
  {
    "objectID": "pr1/python/villkor/presentation/villkor-pres.html#dagens-mål",
    "href": "pr1/python/villkor/presentation/villkor-pres.html#dagens-mål",
    "title": "Villkor i Python",
    "section": "Dagens mål",
    "text": "Dagens mål\n\nAtt förstå hur villkor tecknas i Python med hjälp av if-satser och kunna skriva egna, enkla sådana villkor i kod.\nAtt kunna använda jämförelsoperatorerna.\nAtt känna till innebörden av booleska variabler och kunna använda sådana.\nAtt börja lära sig att tolka, och även skapa egna, flödesscheman för program som innehåller villkor."
  },
  {
    "objectID": "pr1/python/villkor/presentation/villkor-pres.html#ett-enkelt-villkor",
    "href": "pr1/python/villkor/presentation/villkor-pres.html#ett-enkelt-villkor",
    "title": "Villkor i Python",
    "section": "Ett enkelt villkor",
    "text": "Ett enkelt villkor\nI Python så avgörs ett villkor med hjälp av det reserverade ordet if.\n\n\n\n\na = 1\nif a &gt; 0:\n   print(\"a är större än 0\")\n\na är större än 0\n\n\n\n\n\n\na = -1\nif a &gt; 0:\n   print(\"a är större än noll\")\nelse:\n   print(\"a är inte större än noll\")\n\na är inte större än noll"
  },
  {
    "objectID": "pr1/python/villkor/presentation/villkor-pres.html#exempel-godkänt",
    "href": "pr1/python/villkor/presentation/villkor-pres.html#exempel-godkänt",
    "title": "Villkor i Python",
    "section": "Exempel: Godkänt?",
    "text": "Exempel: Godkänt?\n\n\n\n\n\nflowchart LR\n    start[/Inmatning\\n poäng/]\n    cond{Är poäng över\\nE-gräns?}\n    ja[/Skriv ut\\nGodkänt/]\n    nej(Programmet\\navslutas)\n    start--&gt;cond\n    cond--&gt;|Ja|ja\n    cond--&gt;|Nej|nej\n    ja--&gt;nej\n\n\n\n\n\n\n\ne_gräns = 15\npoäng = int(input('Ange din provpoäng -&gt; '))\nif poäng &gt;= e_gräns:\n   print('Godkänt')\nprint('Programmet avslutas')\n\n\nResultatet av input är en sträng; denna kan göras om till ett heltal med int enligt rad 2 ovan."
  },
  {
    "objectID": "pr1/python/villkor/presentation/villkor-pres.html#exempel-godkänt-eller-ej",
    "href": "pr1/python/villkor/presentation/villkor-pres.html#exempel-godkänt-eller-ej",
    "title": "Villkor i Python",
    "section": "Exempel: Godkänt eller ej?",
    "text": "Exempel: Godkänt eller ej?\n\n\n\n\n\nflowchart LR\n    start[/Inmatning\\n poäng/]\n    cond{Är poäng över\\nE-gräns?}\n    ja[/Skriv ut\\nGodkänt/]\n    nej[/Skriv ut\\nEj godkänt/]\n    slut(Programmet\\navslutas)\n    start--&gt;cond\n    cond--&gt;|Ja|ja\n    cond--&gt;|Nej|nej\n    ja--&gt;slut\n    nej--&gt;slut\n\n\n\n\n\n\n\ne_gräns = 15\npoäng = int(input('Ange din provpoäng -&gt; '))\nif poäng &gt;= e_gräns:\n   print('Godkänt')\nelse:\n  print('Ej godkänt')\nprint('Programmet avslutas')"
  },
  {
    "objectID": "pr1/python/villkor/presentation/villkor-pres.html#jämförelseoperatorer",
    "href": "pr1/python/villkor/presentation/villkor-pres.html#jämförelseoperatorer",
    "title": "Villkor i Python",
    "section": "Jämförelseoperatorer",
    "text": "Jämförelseoperatorer\n\n\n\n&gt;\n&lt;\n&gt;=\n&lt;=\n==\n!=\n\nStörre än\nMindre än\nStörre än eller lika med\nMindre än eller lika med\nLika med\nSkilt från\n\n\nObservera skillnaden mellan tilldelande likhetstecken och jämförande likhetstecken!\n\n\n\n\n\nprint(3 == 3)\nprint(3 &lt;= 3)\nprint(3 != 3)\nprint(3 != 4)\n\nTrue\nTrue\nFalse\nTrue\n\n\n\na = 3  # Tilldelande\nb = 8  # Tilldelande\na == b # Jämförande\n# Rad 3 evalueras till False\nTilldelning sker från höger till vänster."
  },
  {
    "objectID": "pr1/python/villkor/presentation/villkor-pres.html#booleska-värden",
    "href": "pr1/python/villkor/presentation/villkor-pres.html#booleska-värden",
    "title": "Villkor i Python",
    "section": "Booleska värden",
    "text": "Booleska värden\nVärdena True och  False kallas för booleska värden (efter George Boole, 1815 – 1864).\nVariabler som antar denna typ av värden kallas för booleska variabler.\n\n\nmy_boolean = True\nif (my_boolean):\n   print(\"Den booleska variabelns värde var True\")\n\nDen booleska variabelns värde var True\n\n\n\n\n\nmy_second_boolean = False\nif (not my_second_boolean):\n   print(\"Den booleska variabelns värde var inte True\")\n\nDen booleska variabelns värde var inte True"
  },
  {
    "objectID": "pr1/python/villkor/presentation/villkor-pres.html#sammansättning-av-booleska-värden",
    "href": "pr1/python/villkor/presentation/villkor-pres.html#sammansättning-av-booleska-värden",
    "title": "Villkor i Python",
    "section": "Sammansättning av booleska värden",
    "text": "Sammansättning av booleska värden\nBooleska värden går att ‘’sätta ihop’’ med operatorerna or och  and .\n\n\na = True\nb = False\nprint(a and b)\nprint(a or b)\nprint((a or b) and a)\nprint(not a)\nprint(not b)\n\nFalse\nTrue\nTrue\nFalse\nTrue"
  },
  {
    "objectID": "pr1/python/villkor/presentation/villkor-pres.html#exempel-kategorisera-talet",
    "href": "pr1/python/villkor/presentation/villkor-pres.html#exempel-kategorisera-talet",
    "title": "Villkor i Python",
    "section": "Exempel: Kategorisera talet",
    "text": "Exempel: Kategorisera talet\n\n\n\n\n\nflowchart LR\nstart[/Inmatning\\n av tal/]\nslut(Programmet\\navslutas)\ncondGeq0{\"Tal ≥ 0?\"}\ncondNoll{\"Är talet 0?\"}\nneg[/Skriv ut\\n negativt/]\nnoll[/Skriv ut\\n noll/]\npos[/Skriv ut\\n positivt/]\nstart--&gt;condGeq0\ncondGeq0--&gt;|Ja|condNoll\ncondGeq0--&gt;|Nej|neg--&gt;slut\ncondNoll--&gt;|Ja|noll--&gt;slut\ncondNoll--&gt;|Nej|pos--&gt;slut\n\n\n\n\n\n\ntal = int(input('Ange valfritt heltal -&gt;'))\nif tal &gt;= 0:\n   if tal == 0:\n      print('Noll')\n   else:\n      print('Positivt')\nelse:\n   print('Negativt')\n\nprint('Programmet avslutas')"
  },
  {
    "objectID": "pr1/python/intro/pres-version-online-python/index.html#uppgifter",
    "href": "pr1/python/intro/pres-version-online-python/index.html#uppgifter",
    "title": "Introduktion (Chromebook)",
    "section": "Uppgifter",
    "text": "Uppgifter\nUppgifterna 1 – 6 i dokumentet Uppgifter Pr1, utskrift och villkor",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Presentationer, Python",
      "Introduktion (Chromebook)"
    ]
  },
  {
    "objectID": "pr1/python/intro/pres-version-installerad-python/index.html#uppgifter",
    "href": "pr1/python/intro/pres-version-installerad-python/index.html#uppgifter",
    "title": "Introduktion (PC)",
    "section": "Uppgifter",
    "text": "Uppgifter\nUppgifterna 1 – 6 i dokumentet Uppgifter Pr1, utskrift och villkor",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Presentationer, Python",
      "Introduktion (PC)"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/utskrift-och-villkor/index.html",
    "href": "pr1/python/uppgifter/utskrift-och-villkor/index.html",
    "title": "Uppgifter: Utskrift och villkor",
    "section": "",
    "text": "Nedanstående uppgifter ska göras i Python-konsolen, dvs du ska inte skapa en fil som sparas, om det inte framgår något annat i uppgiften. —\n\n\nMata in följande rader i Python-konsolen och reflektera över resultatet:\n\nprint(\"2 + 2\")\nprint(\"2\" + \"2\")\nprint(2 + 2)\nprint(2.0 + 2)\nprint(0.1 + 0.2)\n\n\n\n\n\n\n\nKommentarer uppgift 1\n\n\n\n\n\n\nTecken inom citationstecken (\" \" ) skrivs ut precis som de är, det är ingenting som beräknas även om det är ett uttryck innanför citationstecknen. Det som står innanför citationstecken kallas för en sträng. Två strängar kan adderas, med resultatet att det blir en ny sträng som består av de båda ingående strängarna i en följd. Därav gäller att \"2\" + \"2\" blir 22 (där 22 är en sträng och inte ett tal).\nUttrycket 2 är ett heltal och 2.0 är ett flyttal. Om ett flyttal används i en beräkning kommer svaret att bli ett flyttal, även om det finns heltal med i andra delar av uttrycket.\n0.1 + 0.2 beräknas inte till exakt 0.3 eftersom Python lagrar tal i binär form (basen 2 till skillnad från basen 10). I denna binära representation kommer termerna att vara avrundade, och summan blir ett närmevärde.\n\n\n\n\n\n\n\nAnvänd en enda print-sats som skriver ut följande (byt ut namnet mot ditt eget). Observera att utskriften är på två rader!\n\n\n\n\n\n\n\n\nJag heter\nAnders Andersson\n\n\n\n\n\n\n\n\n\n\n\nSvar uppgift 2\n\n\n\n\n\nprint(\"Jag heter\\nAnders Andersson\")\n\n\n\n\n\n\nSkapa en Python-fil i Idle där du deklarerar följande strängvariabler (som du kan själv kan anpassa innehållet i):\nAnvänd en print-sats, där du skriver ut variablerna som en fstring, så att utskriften blir:\n\n\n\n\n\n\n\n\nHej, jag heter Anders och är 17 år.\n\n\n\n\n\n(Resten av variablerna ska användas i en senare uppgift, så deklarera dessa även om de inte används här.)\n\n\n\n\n\n\nLösningsförslag uppgift 3\n\n\n\n\n\nfnamn = \"Anders\"\nenamn = \"Andersson\"\nadr = \"Storgatan 1\"\npostnr = \"999 99\"\nort = \"Storstad\"\nålder = 17\n\nprint(f\"Hej, jag heter {fnamn} och är {ålder} år\")\n\n\n\n\n\n\nDeklarera följande variabler, och spara i en fil i Idle:\nsträcka = 103 # Sträcka i meter\ntid = 13.2    # Tiden i sekunder\nfart = sträcka / tid\nSkapa en print-sats som skriver ut farten på det aktuella föremålet avrundat till en decimal.\n\n\n\n\n\n\nLösningsförslag uppgift 4\n\n\n\n\n\nsträcka = 103 # Sträcka i meter\ntid = 13.2    # Tiden i sekunder\nfart = sträcka / tid\n\nprint(f\"Farten är {(sträcka / tid):.1f} m/s\")\n\n\n\n\n\n\nDeklarera följande variabler i Python:\n\na = 1.5\nb = 21.32\n\nAnvänd därefter en (enda) print-sats med lämpliga formateringstecken för att skriva ut, och göra, följande beräkning. Du ska inte använda flera på varandra följande mellanslag inne i print-satsen.\n\n\n\n\n\n\n\n\n   1.50\n+ 21.32\n-------\n  22.82\n\n\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 5\n\n\n\n\n\na = 1.5\nb = 21.32\nprint(f\"{a:&gt;7.2f}\\n+{b:&gt;6.2f}\\n-------\\n{(a+b):&gt;7.2f}\")\n\n\n\n\n\n\nAnvänd filen med strängvariablerna från Uppgift 3 för att med en (enda) print-sats med lämpliga formateringstecken för att skriva ut strängarna, högerjusterade enligt nedan. Du ska inte använda flera på varandra följande mellanslag inne i print-satsen.\n\n\n\n\n\n\n\n\nAnders Andersson\n     Storgatan 1\n 999 99 Storstad\n\n\n\n\n\n\n\n\n\n\n\nSvar uppgift 6\n\n\n\n\n\nprint(f\"{fnamn:&lt;6} {enamn}\\n{adr:&gt;16}\\n{postnr :&gt;7} {ort:&gt;2}\")\n\n\n\n\n\n\n\nRespektive programmeringsuppgift nedan ska sparas i en fil\n\n\n\nSkapa ett program som ber dig mata in ett belopp med pengar. Programmet ska avgöra om det räcker till att köpa ett smycke av järn, silver eller guld. Skapa även ett flödesschema för programmet.\nPriset för respektive typ av smycke deklareras som variabler, där ett järnmycke kostar 200 kr, ett silversmycke 500 kr och ett guldsmycke 1000 kr. Deklarera variabler för dessa priser och använd dessa i programmet.\n\n\n\n\n\n\n# Exempelkörning 1\nAnge belopp (i kr.) att handla för -&gt; 300\nBeloppet räcker till ett järnsmycke!\n\n# Exempelkörning 2\nAnge belopp (i kr.) att handla för -&gt; 800\nBeloppet räcker till ett ett silversmycke!\n\n# Exempelkörning 3\nAnge belopp (i kr.) att handla för -&gt; 100\nBeloppet räcker inte till något smycke.\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 7\n\n\n\n\n\nSe flödesschema här\nLösningsförslag för typavgörandet (första deluppgiften)\n# Detta program demonstrerar hur en if-sats\n# kan vare uppbyggd med elif och else.\npris_järn = 200\npris_silver = 500\npris_guld = 1000\n\nbelopp = int(input(\"Ange belopp (i kr.) att handla för -&gt; \"))\n\nif belopp &gt;= pris_guld:\n  print(\"Beloppet räcker till ett guldsmycke!\")\n    \nelif belopp &gt;= pris_silver: # Om inte tidigare villkor är uppfyllt så prövas detta villkor\n  print(\"Beloppet räcker till ett silversmycke!\")\n\nelif belopp &gt;= pris_järn:   # Om inte tidigare villkor är uppfyllt så prövas detta villkor\n  print(\"Beloppet räcker till ett järnsmycke!\")\n\nelse:                       # Om inget av villkoren är uppfyllda så körs nedanstående sats\n  print(\"Beloppet räcker inte till något smycke.\")\n\nprint(\"Programmet avslutas\")# Denna sats ligger utanför villkorssatsen\n\n\n\n\n\n\nFör de booleska variablerna a, b och c gäller\n\na = True\nb = True\nc = False\n\nFundera ut vilket booleskt värde respektive uttryck nedan kommer att anta, och kontrollera det därefter i Python-konsolen:\n\n(a and b) and c\n\n\n\n\n\n\n\nSvar uppgift 8a\n\n\n\n\n\nFalse\n\n\n\n\na and b and c\n\n\n\n\n\n\n\nSvar uppgift 8b\n\n\n\n\n\nFalse\n\n\n\n\n(a and c) or b\n\n\n\n\n\n\n\nSvar uppgift 8c\n\n\n\n\n\nTrue\n\n\n\n\na and b or c\n\n\n\n\n\n\n\nSvar uppgift 8d\n\n\n\n\n\nTrue\n\n\n\n\n\n\nSkapa ett program som läser in längderna på tre sidor. Programmet ska sedan avgöra om dessa sidor är sidorna i en rätvinklig triangel.\n\n\n\n\n\n\n# Exempelkörning 1\nAnge längden på sida 1 -&gt; 3\nAnge längden på sida 2 -&gt; 4\nAnge längden på sida 3 -&gt; 5\nDessa sidor kan bilda en rätvinklig triangel\n\n# Exempelkörning 2\nAnge längden på sida 1 -&gt; 3\nAnge längden på sida 2 -&gt; 4\nAnge längden på sida 3 -&gt; 6\nDessa sidor kan inte bilda inte en rätvinklig triangel\n\n\n\n\n\n\n\n\n\nTips\n\n\n\nFör att kvadrera ett tal används exponentoperatorn **. T ex gäller att om a = 2**3 så antar a värdet 8.\n\n\nUtmanande uppgift: Utöka programmet så att det även avgör om sidorna bildar en triangel över huvud taget.\n\n\n\n\n\n\n# Exempelkörning 3\nAnge längden på sida 1 -&gt; 7\nAnge längden på sida 2 -&gt; 5\nAnge längden på sida 3 -&gt; 1\nDessa sidor kan inte bilda en triangel\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 9\n\n\n\n\n\n# Detta program avgör om tre sidor med given längd kan bilda en rätvinklig\n# triangel, en triangel som inte är rätvinklig eller om de inte kan bilda\n# en triangel över huvud taget.\n# Framförallt demonstrerar programmet användadet av de booleska satserna\n# \"and\" och \"or\", jämförande likheter och exponmenter.\n\na = int(input(\"Ange sida a -&gt; \"))\nb = int(input(\"Ange sida b -&gt; \"))\nc = int(input(\"Ange sida c -&gt; \"))\n\n# Kontrollerar om Pythagoras sats gäller för någon kombination av sidorna\nif (a**2 + b**2 == c**2) or (a**2 + c**2 == b**2) or (b**2 + c**2 == a**2):\n    print(f\"Sidorna {a}, {b} och {c} kan bilda en rätvinklig triangel\")\n\n# Kontrollerar om triangelolikheten gäller\nelif (a + b &gt; c) and (a + c &gt; b) and (b + c &gt; a):\n    print(f\"Sidorna {a}, {b} och {c} kan bilda en triangel som inte är rätvinklig\")\n\nelse:\n    print(f\"Sidorna {a}, {b} och {c} kan inte bilda en triangel\")\n\nprint(\"Programmet avslutas\")\n\n\n\n\n\n\nEtt program som skriver ut vilket betyg en viss provpoäng motsvarar skulle kunna se ut så här:\ne_gräns = 15; c_gräns = 25; a_gräns = 35\npoäng = int(input('Ange din provpoäng -&gt; '))\nif poäng &gt;= a_gräns:\n   print('A')\nelif poäng &gt;= c_gräns:\n   print('C')\nelif poäng &gt;= e_gräns:\n   print('E')\nelse:\n   print('F')\nprint('Programmet avslutas')\n\nGör ett flödesschema för programmet.\nSkriv om programmet så att det använder de booleska operatorerna not, and och or i villkoren.\n\n\n\n\n\n\n\nLösningsförslag uppgift 10\n\n\n\n\n\nSe flödesschema här\nOmskrivning av givet proghram med booleska operatorer\n# Program som skriver ut ett erhållet betyg baserat på\n# givna gränser. Programmet demonstrerar användandet av\n# de booleska operatorerna and och not.\n\ne_gräns = 15\nc_gräns = 25\na_gräns = 35\n\npoäng = int(input('Ange din provpoäng -&gt; '))\n\nif poäng &gt;= e_gräns and not poäng &gt;= c_gräns:\n    print(\"E\")\nelif poäng &gt;= c_gräns and not poäng &gt;= a_gräns:\n    print(\"C\")\nelif poäng &gt;= a_gräns:\n    print(\"A\")\nelse:\n    print(\"F\")\n\n\n\n\n\n\nSkapa ett program som ber dig mata in ett årtal. Programmet avgör om året är ett skottår. Ett årtal som inte är delbart med 4 är inte ett skottår. Är årtalet dessutom delbart 100 måste det också vara delbart med 400 för att vara ett skottår.\n\n\n\n\n\n\n# Exempelkörning 1\nAnge ett årtal -&gt;  2020\nÅr 2020 är ett skottår\n\n# Exempelkörning 2\nAnge ett årtal -&gt;  2021\nÅr 2021 är inte ett skottår\n\n# Exempelkörning 3\nAnge ett årtal -&gt;  1800\nÅr 1800 är inte ett skottår\n\n# Exempelkörning 4\nAnge ett årtal -&gt;  2000\nÅr 2000 är ett skottår\n\n\n\n\n\n\n\n\n\nTips\n\n\n\nModulooperatorn (%) ger resultatet noll om ett tal är jämnt delbart med ett annat.\n# Exempel 1, delbart\n# (21 är delbart med 3)\n21 % 3\n0\n# Exempel 2, ej delbart\n# (21 är ej delbart med 2)\n21 % 2\n1\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 11\n\n\n\n\n\nVariant 1, med sammansättande and-sats och villkor som skrivs ut i sin helhet:\n# Program som avgör om ett år är skottår.\n# Programmet demonstrerar villkor där modulooperatorn\n# används. Här används egenskapen att om tal a är jämnt\n# delbart med tal b så gäller att a % b är noll.\n# Denna version använder en sammansättande boolesk\n# operator (and) istället för nästlad if-sats.\n\nårtal = int(input(\"Ange ett årtal -&gt; \"))\nif årtal % 400 == 0:                         # Årtal jämnt delbart med 400\n    print(f\"År {årtal} är ett skottår\")\nelif årtal % 4 == 0 and årtal % 100 == 0:    # Årtal jämnt delbart med 4 och 100 men inte med 400\n    print(f\"År {årtal} är inte ett skottår\")\nelif årtal % 4 == 0:                         # Årtal jämnt delbart med 4, men inte med 100\n    print(f\"År {årtal} är ett skottår\")\nelse:                                        # Årtal inte jämnt delbart med 4\n    print(f\"År {årtal} är inte ett skottår\")\nVariant 2, samma uppbyggnad som Variant 1. Istället för att jämföra resultatet resultatet av modulo med noll med hjälp av jämförelseoperatorn == så används den booleska operatorn not.\n# Program som avgör om ett år är skottår.\n# Programmet demonstrerar villkor där modulooperatorn\n# används. Här används egenskapen att om tal a är jämnt\n# delbart med tal b så gäller att a % b är noll (eller False).\n# Denna version använder en sammansättande boolesk\n# operator istället för nästlad if-sats. Istället för\n# skriva ut nolljämförelsen så används `not`-operatorn.\n\nårtal = int(input(\"Ange ett årtal -&gt; \"))\nif not årtal % 400:                      # Årtal jämnt delbart med 400\n    print(f\"År {årtal} är ett skottår\")\nelif not årtal % 4 and not årtal % 100:  # Årtal jämnt delbart med 4 och 100 men inte med 400\n    print(f\"År {årtal} är inte ett skottår\")\nelif not årtal % 4:                      # Årtal jämnt delbart med 4, men inte med 100\n    print(f\"År {årtal} är ett skottår\")\nelse:                                    # Årtal inte jämnt delbart med 4\n    print(f\"År {årtal} är inte ett skottår\")\nVariant 3, uppbyggnad av programmet med nästlade if-satser istället för booleska operatorer och jämförelseoperatorer.\n# Program som avgör om ett år är skottår.\n# Programmet demonstrerar villkor där modulooperatorn\n# används. Här används egenskapen att om tal a är jämnt\n# delbart med tal b så gäller att a % b är noll (eller False).\n# Istället för booleska operatorer så använder programmet\n# nästlade if-sats.\n\nårtal = int(input(\"Ange ett årtal -&gt; \"))\n\nif årtal % 4:           # Årtal är inte jämnt delbart med 4\n    print(f\"År {årtal} är inte ett skottår\")\nelse:                   # Årtal är jämnt delbart med 4\n    if årtal % 100:     # Årtal jämnt delbart med 4, men inte med 100\n        print(f\"År {årtal} är ett skottår\")\n    else:               # Årtal jämnt delbart med 4 och med 100\n        if årtal % 400: # Årtal jämnt delbart med 4 och 100, men inte med 400\n            print(f\"År {årtal} är inte ett skottår\")\n        else:           # Årtal jämnt delbart med 4, 100 och 400\n            print(f\"År {årtal} är ett skottår\")\n\n\n\n\n\n\n\n\n\nDu ska formatera ett (typ) kassakvitto enligt nedan:\n\n\n       Vara     Pris per kg   Vikt [kg]   Belopp [kr]\n-------------------------------------------------------\n      Äpple        25.00        1.20         30.00\n     Papaya       139.90        0.72        100.73\nVattenmelon        19.99        3.51         70.16\n-------------------------------------------------------\n                                   Summa:   200.89\n\n\nDetta ska göras med enbart följande deklarerade variabler:\navskiljare = \"-\"\ntab_rub_1 = \"Vara\"\ntab_rub_2 = \"Pris per kg\"\ntab_rub_3 = \"Vikt [kg]\"\ntab_rub_4 = \"Belopp [kr]\"\nfrukt_1 = \"Äpple\"\nfrukt_2 = \"Papaya\"\nfrukt_3 = \"Vattenmelon\"\nvikt_1 = 1.2\nvikt_2 = 0.72\nvikt_3 = 3.51\npris_1 = 25.0\npris_2 = 139.9\npris_3 = 19.99\nbelopp_1 = pris_1 * vikt_1\nbelopp_2 = pris_2 * vikt_2\nbelopp_3 = pris_3 * vikt_3\nsum_str = \"Summa:\"\nDu ska alltså inte använda mellanslag eller upprepade tecken (t ex flera “-” för radmarkeringar). Ett tips är att titta slajden om formaterad utskrift.\n\n\n\nDenna uppgift bygger på Uppgift 7. Förbättra programmet så att det skriver ut det maximala antalet smycken av respektive sort smycke som du kan köpa för ett angivet belopp. Programmet ska prioritera de dyraste smyckena.\n\n\n\n\n\n\n# Exempelkörning\nAnge belopp (i kr.) att handla för -&gt; 2950\nBeloppet räcker till:\nAntal guldsmycken:  2\nAntal silvermycken: 1\nAntal järnsmycken:  2\nBelopp kvar: 50 kr\nSiffrorna som anger antalet ska vara högerjusterade!\n\n\n\n\n\n\n\n\n\nTips\n\n\n\nAnvänd heltalsdivision, den ger heltalsdelen vid division. Exempel:\n15 // 7 # Ger resultatet 2\n20 // 7 # Ger resultatet 2",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: Utskrift och villkor"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/utskrift-och-villkor/index.html#utskrifter",
    "href": "pr1/python/uppgifter/utskrift-och-villkor/index.html#utskrifter",
    "title": "Uppgifter: Utskrift och villkor",
    "section": "",
    "text": "Nedanstående uppgifter ska göras i Python-konsolen, dvs du ska inte skapa en fil som sparas, om det inte framgår något annat i uppgiften. —\n\n\nMata in följande rader i Python-konsolen och reflektera över resultatet:\n\nprint(\"2 + 2\")\nprint(\"2\" + \"2\")\nprint(2 + 2)\nprint(2.0 + 2)\nprint(0.1 + 0.2)\n\n\n\n\n\n\n\nKommentarer uppgift 1\n\n\n\n\n\n\nTecken inom citationstecken (\" \" ) skrivs ut precis som de är, det är ingenting som beräknas även om det är ett uttryck innanför citationstecknen. Det som står innanför citationstecken kallas för en sträng. Två strängar kan adderas, med resultatet att det blir en ny sträng som består av de båda ingående strängarna i en följd. Därav gäller att \"2\" + \"2\" blir 22 (där 22 är en sträng och inte ett tal).\nUttrycket 2 är ett heltal och 2.0 är ett flyttal. Om ett flyttal används i en beräkning kommer svaret att bli ett flyttal, även om det finns heltal med i andra delar av uttrycket.\n0.1 + 0.2 beräknas inte till exakt 0.3 eftersom Python lagrar tal i binär form (basen 2 till skillnad från basen 10). I denna binära representation kommer termerna att vara avrundade, och summan blir ett närmevärde.\n\n\n\n\n\n\n\nAnvänd en enda print-sats som skriver ut följande (byt ut namnet mot ditt eget). Observera att utskriften är på två rader!\n\n\n\n\n\n\n\n\nJag heter\nAnders Andersson\n\n\n\n\n\n\n\n\n\n\n\nSvar uppgift 2\n\n\n\n\n\nprint(\"Jag heter\\nAnders Andersson\")\n\n\n\n\n\n\nSkapa en Python-fil i Idle där du deklarerar följande strängvariabler (som du kan själv kan anpassa innehållet i):\nAnvänd en print-sats, där du skriver ut variablerna som en fstring, så att utskriften blir:\n\n\n\n\n\n\n\n\nHej, jag heter Anders och är 17 år.\n\n\n\n\n\n(Resten av variablerna ska användas i en senare uppgift, så deklarera dessa även om de inte används här.)\n\n\n\n\n\n\nLösningsförslag uppgift 3\n\n\n\n\n\nfnamn = \"Anders\"\nenamn = \"Andersson\"\nadr = \"Storgatan 1\"\npostnr = \"999 99\"\nort = \"Storstad\"\nålder = 17\n\nprint(f\"Hej, jag heter {fnamn} och är {ålder} år\")\n\n\n\n\n\n\nDeklarera följande variabler, och spara i en fil i Idle:\nsträcka = 103 # Sträcka i meter\ntid = 13.2    # Tiden i sekunder\nfart = sträcka / tid\nSkapa en print-sats som skriver ut farten på det aktuella föremålet avrundat till en decimal.\n\n\n\n\n\n\nLösningsförslag uppgift 4\n\n\n\n\n\nsträcka = 103 # Sträcka i meter\ntid = 13.2    # Tiden i sekunder\nfart = sträcka / tid\n\nprint(f\"Farten är {(sträcka / tid):.1f} m/s\")\n\n\n\n\n\n\nDeklarera följande variabler i Python:\n\na = 1.5\nb = 21.32\n\nAnvänd därefter en (enda) print-sats med lämpliga formateringstecken för att skriva ut, och göra, följande beräkning. Du ska inte använda flera på varandra följande mellanslag inne i print-satsen.\n\n\n\n\n\n\n\n\n   1.50\n+ 21.32\n-------\n  22.82\n\n\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 5\n\n\n\n\n\na = 1.5\nb = 21.32\nprint(f\"{a:&gt;7.2f}\\n+{b:&gt;6.2f}\\n-------\\n{(a+b):&gt;7.2f}\")\n\n\n\n\n\n\nAnvänd filen med strängvariablerna från Uppgift 3 för att med en (enda) print-sats med lämpliga formateringstecken för att skriva ut strängarna, högerjusterade enligt nedan. Du ska inte använda flera på varandra följande mellanslag inne i print-satsen.\n\n\n\n\n\n\n\n\nAnders Andersson\n     Storgatan 1\n 999 99 Storstad\n\n\n\n\n\n\n\n\n\n\n\nSvar uppgift 6\n\n\n\n\n\nprint(f\"{fnamn:&lt;6} {enamn}\\n{adr:&gt;16}\\n{postnr :&gt;7} {ort:&gt;2}\")",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: Utskrift och villkor"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/utskrift-och-villkor/index.html#villkor-i-python",
    "href": "pr1/python/uppgifter/utskrift-och-villkor/index.html#villkor-i-python",
    "title": "Uppgifter: Utskrift och villkor",
    "section": "",
    "text": "Respektive programmeringsuppgift nedan ska sparas i en fil\n\n\n\nSkapa ett program som ber dig mata in ett belopp med pengar. Programmet ska avgöra om det räcker till att köpa ett smycke av järn, silver eller guld. Skapa även ett flödesschema för programmet.\nPriset för respektive typ av smycke deklareras som variabler, där ett järnmycke kostar 200 kr, ett silversmycke 500 kr och ett guldsmycke 1000 kr. Deklarera variabler för dessa priser och använd dessa i programmet.\n\n\n\n\n\n\n# Exempelkörning 1\nAnge belopp (i kr.) att handla för -&gt; 300\nBeloppet räcker till ett järnsmycke!\n\n# Exempelkörning 2\nAnge belopp (i kr.) att handla för -&gt; 800\nBeloppet räcker till ett ett silversmycke!\n\n# Exempelkörning 3\nAnge belopp (i kr.) att handla för -&gt; 100\nBeloppet räcker inte till något smycke.\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 7\n\n\n\n\n\nSe flödesschema här\nLösningsförslag för typavgörandet (första deluppgiften)\n# Detta program demonstrerar hur en if-sats\n# kan vare uppbyggd med elif och else.\npris_järn = 200\npris_silver = 500\npris_guld = 1000\n\nbelopp = int(input(\"Ange belopp (i kr.) att handla för -&gt; \"))\n\nif belopp &gt;= pris_guld:\n  print(\"Beloppet räcker till ett guldsmycke!\")\n    \nelif belopp &gt;= pris_silver: # Om inte tidigare villkor är uppfyllt så prövas detta villkor\n  print(\"Beloppet räcker till ett silversmycke!\")\n\nelif belopp &gt;= pris_järn:   # Om inte tidigare villkor är uppfyllt så prövas detta villkor\n  print(\"Beloppet räcker till ett järnsmycke!\")\n\nelse:                       # Om inget av villkoren är uppfyllda så körs nedanstående sats\n  print(\"Beloppet räcker inte till något smycke.\")\n\nprint(\"Programmet avslutas\")# Denna sats ligger utanför villkorssatsen\n\n\n\n\n\n\nFör de booleska variablerna a, b och c gäller\n\na = True\nb = True\nc = False\n\nFundera ut vilket booleskt värde respektive uttryck nedan kommer att anta, och kontrollera det därefter i Python-konsolen:\n\n(a and b) and c\n\n\n\n\n\n\n\nSvar uppgift 8a\n\n\n\n\n\nFalse\n\n\n\n\na and b and c\n\n\n\n\n\n\n\nSvar uppgift 8b\n\n\n\n\n\nFalse\n\n\n\n\n(a and c) or b\n\n\n\n\n\n\n\nSvar uppgift 8c\n\n\n\n\n\nTrue\n\n\n\n\na and b or c\n\n\n\n\n\n\n\nSvar uppgift 8d\n\n\n\n\n\nTrue\n\n\n\n\n\n\nSkapa ett program som läser in längderna på tre sidor. Programmet ska sedan avgöra om dessa sidor är sidorna i en rätvinklig triangel.\n\n\n\n\n\n\n# Exempelkörning 1\nAnge längden på sida 1 -&gt; 3\nAnge längden på sida 2 -&gt; 4\nAnge längden på sida 3 -&gt; 5\nDessa sidor kan bilda en rätvinklig triangel\n\n# Exempelkörning 2\nAnge längden på sida 1 -&gt; 3\nAnge längden på sida 2 -&gt; 4\nAnge längden på sida 3 -&gt; 6\nDessa sidor kan inte bilda inte en rätvinklig triangel\n\n\n\n\n\n\n\n\n\nTips\n\n\n\nFör att kvadrera ett tal används exponentoperatorn **. T ex gäller att om a = 2**3 så antar a värdet 8.\n\n\nUtmanande uppgift: Utöka programmet så att det även avgör om sidorna bildar en triangel över huvud taget.\n\n\n\n\n\n\n# Exempelkörning 3\nAnge längden på sida 1 -&gt; 7\nAnge längden på sida 2 -&gt; 5\nAnge längden på sida 3 -&gt; 1\nDessa sidor kan inte bilda en triangel\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 9\n\n\n\n\n\n# Detta program avgör om tre sidor med given längd kan bilda en rätvinklig\n# triangel, en triangel som inte är rätvinklig eller om de inte kan bilda\n# en triangel över huvud taget.\n# Framförallt demonstrerar programmet användadet av de booleska satserna\n# \"and\" och \"or\", jämförande likheter och exponmenter.\n\na = int(input(\"Ange sida a -&gt; \"))\nb = int(input(\"Ange sida b -&gt; \"))\nc = int(input(\"Ange sida c -&gt; \"))\n\n# Kontrollerar om Pythagoras sats gäller för någon kombination av sidorna\nif (a**2 + b**2 == c**2) or (a**2 + c**2 == b**2) or (b**2 + c**2 == a**2):\n    print(f\"Sidorna {a}, {b} och {c} kan bilda en rätvinklig triangel\")\n\n# Kontrollerar om triangelolikheten gäller\nelif (a + b &gt; c) and (a + c &gt; b) and (b + c &gt; a):\n    print(f\"Sidorna {a}, {b} och {c} kan bilda en triangel som inte är rätvinklig\")\n\nelse:\n    print(f\"Sidorna {a}, {b} och {c} kan inte bilda en triangel\")\n\nprint(\"Programmet avslutas\")\n\n\n\n\n\n\nEtt program som skriver ut vilket betyg en viss provpoäng motsvarar skulle kunna se ut så här:\ne_gräns = 15; c_gräns = 25; a_gräns = 35\npoäng = int(input('Ange din provpoäng -&gt; '))\nif poäng &gt;= a_gräns:\n   print('A')\nelif poäng &gt;= c_gräns:\n   print('C')\nelif poäng &gt;= e_gräns:\n   print('E')\nelse:\n   print('F')\nprint('Programmet avslutas')\n\nGör ett flödesschema för programmet.\nSkriv om programmet så att det använder de booleska operatorerna not, and och or i villkoren.\n\n\n\n\n\n\n\nLösningsförslag uppgift 10\n\n\n\n\n\nSe flödesschema här\nOmskrivning av givet proghram med booleska operatorer\n# Program som skriver ut ett erhållet betyg baserat på\n# givna gränser. Programmet demonstrerar användandet av\n# de booleska operatorerna and och not.\n\ne_gräns = 15\nc_gräns = 25\na_gräns = 35\n\npoäng = int(input('Ange din provpoäng -&gt; '))\n\nif poäng &gt;= e_gräns and not poäng &gt;= c_gräns:\n    print(\"E\")\nelif poäng &gt;= c_gräns and not poäng &gt;= a_gräns:\n    print(\"C\")\nelif poäng &gt;= a_gräns:\n    print(\"A\")\nelse:\n    print(\"F\")\n\n\n\n\n\n\nSkapa ett program som ber dig mata in ett årtal. Programmet avgör om året är ett skottår. Ett årtal som inte är delbart med 4 är inte ett skottår. Är årtalet dessutom delbart 100 måste det också vara delbart med 400 för att vara ett skottår.\n\n\n\n\n\n\n# Exempelkörning 1\nAnge ett årtal -&gt;  2020\nÅr 2020 är ett skottår\n\n# Exempelkörning 2\nAnge ett årtal -&gt;  2021\nÅr 2021 är inte ett skottår\n\n# Exempelkörning 3\nAnge ett årtal -&gt;  1800\nÅr 1800 är inte ett skottår\n\n# Exempelkörning 4\nAnge ett årtal -&gt;  2000\nÅr 2000 är ett skottår\n\n\n\n\n\n\n\n\n\nTips\n\n\n\nModulooperatorn (%) ger resultatet noll om ett tal är jämnt delbart med ett annat.\n# Exempel 1, delbart\n# (21 är delbart med 3)\n21 % 3\n0\n# Exempel 2, ej delbart\n# (21 är ej delbart med 2)\n21 % 2\n1\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 11\n\n\n\n\n\nVariant 1, med sammansättande and-sats och villkor som skrivs ut i sin helhet:\n# Program som avgör om ett år är skottår.\n# Programmet demonstrerar villkor där modulooperatorn\n# används. Här används egenskapen att om tal a är jämnt\n# delbart med tal b så gäller att a % b är noll.\n# Denna version använder en sammansättande boolesk\n# operator (and) istället för nästlad if-sats.\n\nårtal = int(input(\"Ange ett årtal -&gt; \"))\nif årtal % 400 == 0:                         # Årtal jämnt delbart med 400\n    print(f\"År {årtal} är ett skottår\")\nelif årtal % 4 == 0 and årtal % 100 == 0:    # Årtal jämnt delbart med 4 och 100 men inte med 400\n    print(f\"År {årtal} är inte ett skottår\")\nelif årtal % 4 == 0:                         # Årtal jämnt delbart med 4, men inte med 100\n    print(f\"År {årtal} är ett skottår\")\nelse:                                        # Årtal inte jämnt delbart med 4\n    print(f\"År {årtal} är inte ett skottår\")\nVariant 2, samma uppbyggnad som Variant 1. Istället för att jämföra resultatet resultatet av modulo med noll med hjälp av jämförelseoperatorn == så används den booleska operatorn not.\n# Program som avgör om ett år är skottår.\n# Programmet demonstrerar villkor där modulooperatorn\n# används. Här används egenskapen att om tal a är jämnt\n# delbart med tal b så gäller att a % b är noll (eller False).\n# Denna version använder en sammansättande boolesk\n# operator istället för nästlad if-sats. Istället för\n# skriva ut nolljämförelsen så används `not`-operatorn.\n\nårtal = int(input(\"Ange ett årtal -&gt; \"))\nif not årtal % 400:                      # Årtal jämnt delbart med 400\n    print(f\"År {årtal} är ett skottår\")\nelif not årtal % 4 and not årtal % 100:  # Årtal jämnt delbart med 4 och 100 men inte med 400\n    print(f\"År {årtal} är inte ett skottår\")\nelif not årtal % 4:                      # Årtal jämnt delbart med 4, men inte med 100\n    print(f\"År {årtal} är ett skottår\")\nelse:                                    # Årtal inte jämnt delbart med 4\n    print(f\"År {årtal} är inte ett skottår\")\nVariant 3, uppbyggnad av programmet med nästlade if-satser istället för booleska operatorer och jämförelseoperatorer.\n# Program som avgör om ett år är skottår.\n# Programmet demonstrerar villkor där modulooperatorn\n# används. Här används egenskapen att om tal a är jämnt\n# delbart med tal b så gäller att a % b är noll (eller False).\n# Istället för booleska operatorer så använder programmet\n# nästlade if-sats.\n\nårtal = int(input(\"Ange ett årtal -&gt; \"))\n\nif årtal % 4:           # Årtal är inte jämnt delbart med 4\n    print(f\"År {årtal} är inte ett skottår\")\nelse:                   # Årtal är jämnt delbart med 4\n    if årtal % 100:     # Årtal jämnt delbart med 4, men inte med 100\n        print(f\"År {årtal} är ett skottår\")\n    else:               # Årtal jämnt delbart med 4 och med 100\n        if årtal % 400: # Årtal jämnt delbart med 4 och 100, men inte med 400\n            print(f\"År {årtal} är inte ett skottår\")\n        else:           # Årtal jämnt delbart med 4, 100 och 400\n            print(f\"År {årtal} är ett skottår\")",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: Utskrift och villkor"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/utskrift-och-villkor/index.html#uppgifter-utan-lösningsförslag",
    "href": "pr1/python/uppgifter/utskrift-och-villkor/index.html#uppgifter-utan-lösningsförslag",
    "title": "Uppgifter: Utskrift och villkor",
    "section": "",
    "text": "Du ska formatera ett (typ) kassakvitto enligt nedan:\n\n\n       Vara     Pris per kg   Vikt [kg]   Belopp [kr]\n-------------------------------------------------------\n      Äpple        25.00        1.20         30.00\n     Papaya       139.90        0.72        100.73\nVattenmelon        19.99        3.51         70.16\n-------------------------------------------------------\n                                   Summa:   200.89\n\n\nDetta ska göras med enbart följande deklarerade variabler:\navskiljare = \"-\"\ntab_rub_1 = \"Vara\"\ntab_rub_2 = \"Pris per kg\"\ntab_rub_3 = \"Vikt [kg]\"\ntab_rub_4 = \"Belopp [kr]\"\nfrukt_1 = \"Äpple\"\nfrukt_2 = \"Papaya\"\nfrukt_3 = \"Vattenmelon\"\nvikt_1 = 1.2\nvikt_2 = 0.72\nvikt_3 = 3.51\npris_1 = 25.0\npris_2 = 139.9\npris_3 = 19.99\nbelopp_1 = pris_1 * vikt_1\nbelopp_2 = pris_2 * vikt_2\nbelopp_3 = pris_3 * vikt_3\nsum_str = \"Summa:\"\nDu ska alltså inte använda mellanslag eller upprepade tecken (t ex flera “-” för radmarkeringar). Ett tips är att titta slajden om formaterad utskrift.\n\n\n\nDenna uppgift bygger på Uppgift 7. Förbättra programmet så att det skriver ut det maximala antalet smycken av respektive sort smycke som du kan köpa för ett angivet belopp. Programmet ska prioritera de dyraste smyckena.\n\n\n\n\n\n\n# Exempelkörning\nAnge belopp (i kr.) att handla för -&gt; 2950\nBeloppet räcker till:\nAntal guldsmycken:  2\nAntal silvermycken: 1\nAntal järnsmycken:  2\nBelopp kvar: 50 kr\nSiffrorna som anger antalet ska vara högerjusterade!\n\n\n\n\n\n\n\n\n\nTips\n\n\n\nAnvänd heltalsdivision, den ger heltalsdelen vid division. Exempel:\n15 // 7 # Ger resultatet 2\n20 // 7 # Ger resultatet 2",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: Utskrift och villkor"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/diverse/index.html",
    "href": "pr1/python/uppgifter/diverse/index.html",
    "title": "Uppgifter: Diverse",
    "section": "",
    "text": "I en lek som kan användas när man lär sig division sitter deltagarna i en ring. Den första personen i ringen säger “Ett” och den andra “Två”. När en person ska säga ett tal som är jämnt delbart med tre, så säger den “Fizz”. Den tredje personen säger alltså “Fizz” istället för tre, eftersom tre är jämnt delbart med tre, detsamma gäller den person som skulle säga “Sex” och “Nio” osv. När en person ska säga ett tal som är jämnt delbart med fem så ska den istället säga “Buzz”. När talet femton ska uttalas så ska den personen som står på tur säga “FizzBuzz”, eftersom femton är jämnt delbart med både tre och fem. I ringleken så åker personer som säger fel ut, och spelet går vidare med en mindre ring.\nSkriv ett program som gör en uppräkning av heltal från 1 till 100, och på lämpligt sätt skriver ut talen (när de ska skrivas ut), Fizz (istället för tal som är jämnt delbara med tre), Buzz (istället för tal som är jämnt delbara med fem) och FizzBuzz (istället för tal som är jämnt delbara med såväl tre som fem).\nFörsök att skriva två varianter på lösning:\n\nEn som innehåller booleska operatorer i villkoren\nEn som inte innehåller booleska operatorer i villkoren\n\nSe lösningsförslag till uppgift 11 på sidan Utskrifter och villkor för att få en idé om uppbyggnaden.\n\n\n\n\n\n\nNär matematikern Leonardo Pisano Fibonacci på 1200-talet skulle beskriva tillväxten hos kaniner, så kom han fram till talföljden \\(1, 1, 2, 3, 5, 8, 13,..., n\\) (denna följd kallas för Fibonaccis talföljd). Varje tal beskriver antalet kaninpar efter \\(n\\) månader enligt följande förutsättningar:\n\ndet endast finns ett par nyfödda kaniner den första månaden.\nnyfödda kaniner blir könsmogna vid två månaders ålder.\ndet inte uppstår genetiska problem på grund av inavel.\ndet varje månad föds en unge per könsmogen kanin.\ningen av kaninerna dör. \n\nSkriv en funktion fib(n) som returnerar en lista med följden av fibonaccital för ett givet värde på \\(n\\). Exempel:\nT ex ska print(fib(10)) ge utskriften [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\nDet finns mer intressant information om fibonaccitalen på denna Wikipediasida.\n\n\n\nMatematikern och fysikern Blaise Pascal (1623 – 1662) skapade ett triangelmönster av tal som är användbara i vissa sammanhang:\n         1\n       1   1\n     1   2   1\n   1   3   3   1\n 1   4   6   4   1\nDetta mönster kallas för Pascals triangel, och varje rad byggs upp med hjälp av summan av två tal i raden ovanför (respektive yttre tal i varje rad är alltid en etta).\nSkapa en funktion pascal(n) som returnerar en lista av listor innehållande talen i Pascals triangel t.o.m rad \\(n\\).\nExempel: print(pascal(6)) ska ge utskriften [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1]].\nDet finns flera sätt att lösa denna uppgift på (den är inte helt enkel). En metod är att skapa listorna row och rows, där listan row innehåller en rad (som skrivs om om vartannat) och listan rows är listan som innehåller alla row. Det går att lägga till en row i rows med hjälp av metoden append.\nNär själva algoritmen är klar så kan man gå vidare med att skriva ut de beräknade talen på triangelform."
  },
  {
    "objectID": "pr1/python/uppgifter/diverse/index.html#villkor-och-loopar",
    "href": "pr1/python/uppgifter/diverse/index.html#villkor-och-loopar",
    "title": "Uppgifter: Diverse",
    "section": "",
    "text": "I en lek som kan användas när man lär sig division sitter deltagarna i en ring. Den första personen i ringen säger “Ett” och den andra “Två”. När en person ska säga ett tal som är jämnt delbart med tre, så säger den “Fizz”. Den tredje personen säger alltså “Fizz” istället för tre, eftersom tre är jämnt delbart med tre, detsamma gäller den person som skulle säga “Sex” och “Nio” osv. När en person ska säga ett tal som är jämnt delbart med fem så ska den istället säga “Buzz”. När talet femton ska uttalas så ska den personen som står på tur säga “FizzBuzz”, eftersom femton är jämnt delbart med både tre och fem. I ringleken så åker personer som säger fel ut, och spelet går vidare med en mindre ring.\nSkriv ett program som gör en uppräkning av heltal från 1 till 100, och på lämpligt sätt skriver ut talen (när de ska skrivas ut), Fizz (istället för tal som är jämnt delbara med tre), Buzz (istället för tal som är jämnt delbara med fem) och FizzBuzz (istället för tal som är jämnt delbara med såväl tre som fem).\nFörsök att skriva två varianter på lösning:\n\nEn som innehåller booleska operatorer i villkoren\nEn som inte innehåller booleska operatorer i villkoren\n\nSe lösningsförslag till uppgift 11 på sidan Utskrifter och villkor för att få en idé om uppbyggnaden."
  },
  {
    "objectID": "pr1/python/uppgifter/diverse/index.html#listor",
    "href": "pr1/python/uppgifter/diverse/index.html#listor",
    "title": "Uppgifter: Diverse",
    "section": "",
    "text": "När matematikern Leonardo Pisano Fibonacci på 1200-talet skulle beskriva tillväxten hos kaniner, så kom han fram till talföljden \\(1, 1, 2, 3, 5, 8, 13,..., n\\) (denna följd kallas för Fibonaccis talföljd). Varje tal beskriver antalet kaninpar efter \\(n\\) månader enligt följande förutsättningar:\n\ndet endast finns ett par nyfödda kaniner den första månaden.\nnyfödda kaniner blir könsmogna vid två månaders ålder.\ndet inte uppstår genetiska problem på grund av inavel.\ndet varje månad föds en unge per könsmogen kanin.\ningen av kaninerna dör. \n\nSkriv en funktion fib(n) som returnerar en lista med följden av fibonaccital för ett givet värde på \\(n\\). Exempel:\nT ex ska print(fib(10)) ge utskriften [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\nDet finns mer intressant information om fibonaccitalen på denna Wikipediasida.\n\n\n\nMatematikern och fysikern Blaise Pascal (1623 – 1662) skapade ett triangelmönster av tal som är användbara i vissa sammanhang:\n         1\n       1   1\n     1   2   1\n   1   3   3   1\n 1   4   6   4   1\nDetta mönster kallas för Pascals triangel, och varje rad byggs upp med hjälp av summan av två tal i raden ovanför (respektive yttre tal i varje rad är alltid en etta).\nSkapa en funktion pascal(n) som returnerar en lista av listor innehållande talen i Pascals triangel t.o.m rad \\(n\\).\nExempel: print(pascal(6)) ska ge utskriften [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1]].\nDet finns flera sätt att lösa denna uppgift på (den är inte helt enkel). En metod är att skapa listorna row och rows, där listan row innehåller en rad (som skrivs om om vartannat) och listan rows är listan som innehåller alla row. Det går att lägga till en row i rows med hjälp av metoden append.\nNär själva algoritmen är klar så kan man gå vidare med att skriva ut de beräknade talen på triangelform."
  },
  {
    "objectID": "pr1/python/uppgifter/binarsokning/index.html",
    "href": "pr1/python/uppgifter/binarsokning/index.html",
    "title": "Binärsökning",
    "section": "",
    "text": "Förstå problemet: Binärsökning är en effektiv algoritm för att hitta ett specifikt element i en sorterad lista. Den fungerar genom att kontinuerligt dela listan i hälften tills det sökta elementet hittas eller tills det inte finns några element kvar att söka igenom.\nIdentifiera indata: Funktionen behöver fyra indata: en sorterad lista, ett sökt tal och två index som representerar den undre och övre gränsen för sökningen.\nBeräkna mitten: För varje sökning, beräkna mitten av listan (eller den aktuella delen av listan) genom att addera det undre och övre indexet och dela med två.\nJämför mitten med målet: Kontrollera om det sökta talet är lika med, mindre än eller större än elementet i mitten av listan. Om det är lika, returnera index för mitten av den aktuella delen av listan.\nUppdatera gränserna: Om det sökta talet är mindre än elementet i mitten, uppdatera det övre indexet till att vara ett mindre än mittenindex. Om det sökta talet är större, uppdatera det undre indexet till att vara ett större än mittenindex.\nUpprepa sökningen med den mindre listan, dvs gå tillbaka till punkt 3. Om det övre indexet är ett tal som är mindre än det undre indexet finns inte talet i listan; returnera då None.\n\n\n\n\nHär är en lista med tal. Låt oss söka efter ett tal med hjälp av algoritmen.\n  Tal: 2  4  6  8  10 12 14 16 18 20\n       |  |  |  |  |  |  |  |  |  |\nIndex: 0  1  2  3  4  5  6  7  8  9\n\n\n\nFörst beräknar vi mitten av listan. I det här fallet är mittenindexet 4 (värdet 10).\n\n        2 4 6 8 [10] 12 14 16 18 20\n\nEftersom 14 är större än 10, fortsätter vi att söka i den högra halvan av listan. Det undre index sätts till 1 mer än mittenindex (4 + 1 = 5) och det övre indexet står kvar (9).\n\n        12 14 16 18 20\n\nVi beräknar mitten av den nya listan, vilket är index 7 (värdet 16).\n\n        12 14 [16] 18 20\n\nEftersom 14 är mindre än 16, fortsätter vi att söka i den vänstra halvan av den kvarvarande listan. Det undre indexet ändras då inte (5) och det övre indexet blir 1 mindre än mittenindex (7 - 1 = 6)\n\n        12 14\n\nMitten på denna lista är index 5 (värdet 12).\nEftersom 14 är större än 12 så fortsätter sökningen till höger om mitten i den ytterligare reducerade listan. Det undre indexet blir 1 mer än mittenindexet (5 + 1 = 6) och det övre indexet står kvar (6).\nEftersom det sökta värdet finns på mittenindexet så returnerar funktionen detta index.\n\n\n\n\n\nFörst beräknar vi mitten av listan. I det här fallet är mittenindexet 4 (värdet 12).\n\n        2 4 6 8 [10] 12 14 16 18 20\n\nEftersom 11 är större än 10, fortsätter vi att söka i den högra halvan av listan. Undre index: 5 (mittenindex + 1). Övre index: 9 (tidigare slutindex).\n\n        12 14 16 18 20\n\nVi beräknar mitten av den nya listan, vilket är index 7 (värdet 16).\n\n        12 14 [16] 18 20\n\nEftersom 11 är mindre än 16, fortsätter vi att söka i den vänstra halvan av listan. Undre index: 5 (tidigare startindex), övre index: 6 (mittenindex - 1).\n\n        12 14\n\nVi beräknar mitten av den nya listan, vilket är index 5 (värdet 12).\n\n        [12] 14\n\nEftersom 11 är mindre än 12, fortsätter vi att söka i den vänstra halvan av listan. Då sökningen ska ske till vänster ska det lägre indexet (5) stå kvar och det övre indexet ska vara 1 under mittenindex (5 - 1 = 4). Det gör att det övre indexet är lägre än det undre. När det läget är nått så har algoritmen visat att det sökta talet inte finns i listan.\n\n\n\n\n\ndef bin_search(lst, item, lower_i, upper_i):\n    # lst är den sorterade listan som sökningen sker i\n    # item är det som söks\n    # lower_i är det index där sökningen börjar\n    # upper_i är det index där sökningen slutar\n    \n    # LOOPA under villkoret upper_i &gt;= lower_i:\n        # SKAPA en variabel mid_i, som utgör indexet i mitten\n        # (avrundat nedåt). Använd heltalsdivision för denna beräkning.\n\n        # OM talet på indexet mid_i är det sökta talet\n            # returnera mid_i.\n        \n        # ANNARS OM talet på indexet mid_i är större än item\n            # ändra upper_i till mid_i - 1 (vänster del av lista ska sökas)\n        \n        # ANNARS, ändra lower_i till mid_i + 1 (höger del av lista ska sökas)\n    \n    # Returnera None (talet finns inte i listan)\n\n\n\n\n\nSkapa funktionen bin_search enligt pseudokoden ovan. Testa den med några olika listor. Exempel på testprogram till funktionen:\n\n\n\n\nlst = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n\nval_1 = 12 # Ett värde som finns i listan\nval_2 = 25 # Ett värde som saknas i listan\n\nresult_1 = bin_search(lst, val_1, lower_i=0, upper_i=len(lst)-1)\nresult_2 = bin_search(lst, val_2, lower_i=0, upper_i=len(lst)-1)\n\nprint(result_1) # 5 (dvs värdet 12 finns på index 5)\nprint(result_2) # None (dvs värdet 5 saknas i listan)\n\n5\nNone\n\n\n\n\n\n\nUtveckla programmet så att det skriver ut i vilken partition av listan som genomsöks och antalet sökningar som gjorts. Exempel på utmatning:\n\n\n\nSöker efter talet 12 i listan [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\nSöker efter talet 12 i listan [12, 14, 16, 18, 20]\nSöker efter talet 12 i listan [12, 14]\nTalet 12 finns på index 5, hittades efter 3 sökningar\n\nSöker efter talet 25 i listan [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\nSöker efter talet 25 i listan [12, 14, 16, 18, 20]\nSöker efter talet 25 i listan [18, 20]\nSöker efter talet 25 i listan [20]\nTalet 25 saknas i listan, konstaterades efter 4 sökningar\n\n\n\n\n\n\nSkapa en (sorterad) lista med \\(1\\,000\\) element med spridda heltalsvärden mellan \\(1\\) och \\(2\\,000\\). Ta reda på med hjälp av funktionen hur många iterationer det\n\nmaximalt som är tvunget att göras\ni genomsnitt görs (såväl i de fall när talet saknas i listan och de fall där talet finns, se exemplet nedan).\n\nför att hitta ett tal som finns i listan alternativt utesluta förekomsten av det? (Här bör du söka efter vart och ett av alla tal mellan \\(1\\) och \\(2\\,000\\) för att få ett tillförlitligt resultat; vissa tal kommer att hittas medan andra naturligtvis saknas i listan.)\nGör sedan om samma undesökning med en lista på \\(10\\,000\\) element (med spridda heltalsvärden mellan 1 och \\(20\\,000\\)). Kommentera resultatet (antalet element har ökat med en faktor 10, men med vilken faktor har det genomsnittliga antalet sökningar förändrats?).\nTips: En lista lst kan sorteras med hjälp av metoden sort enligt lst.sort(). Det går alltså att skapa en lista med slumpmässiga heltal och därefter sortera den.\nNedan finns ett exempel. Antalet sökningar som gjorts i exemplet är dubbelt så många som listans storlek. T ex så baserar sig den första raden på en sökning i en lista på 100 slumpade heltal mellan 1 och 200, där vart och ett av talen 1, 2, 3,..., 200 eftersöks.\n\n\n\nListans    Antal iterationer    Antal iterationer    Maximalt antal\nstorlek    vid bom              vid träff            iterationer\n-------------------------------------------------------------------\n  100        6.84                   5.56                   7\n  200        7.77                   6.55                   8\n  300        8.30                   7.11                   9\n  400        8.78                   7.50                   9\n-------------------------------------------------------------------\nAntalet iterationer vid bom respektive träff är det genomsnittliga\nantalet för att konstatera att talet saknas i listan respektive\nhitta det index som det återfinns på.",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Binärsökning"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/binarsokning/index.html#beskrivning-av-algoritmen",
    "href": "pr1/python/uppgifter/binarsokning/index.html#beskrivning-av-algoritmen",
    "title": "Binärsökning",
    "section": "",
    "text": "Förstå problemet: Binärsökning är en effektiv algoritm för att hitta ett specifikt element i en sorterad lista. Den fungerar genom att kontinuerligt dela listan i hälften tills det sökta elementet hittas eller tills det inte finns några element kvar att söka igenom.\nIdentifiera indata: Funktionen behöver fyra indata: en sorterad lista, ett sökt tal och två index som representerar den undre och övre gränsen för sökningen.\nBeräkna mitten: För varje sökning, beräkna mitten av listan (eller den aktuella delen av listan) genom att addera det undre och övre indexet och dela med två.\nJämför mitten med målet: Kontrollera om det sökta talet är lika med, mindre än eller större än elementet i mitten av listan. Om det är lika, returnera index för mitten av den aktuella delen av listan.\nUppdatera gränserna: Om det sökta talet är mindre än elementet i mitten, uppdatera det övre indexet till att vara ett mindre än mittenindex. Om det sökta talet är större, uppdatera det undre indexet till att vara ett större än mittenindex.\nUpprepa sökningen med den mindre listan, dvs gå tillbaka till punkt 3. Om det övre indexet är ett tal som är mindre än det undre indexet finns inte talet i listan; returnera då None.",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Binärsökning"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/binarsokning/index.html#exempel",
    "href": "pr1/python/uppgifter/binarsokning/index.html#exempel",
    "title": "Binärsökning",
    "section": "",
    "text": "Här är en lista med tal. Låt oss söka efter ett tal med hjälp av algoritmen.\n  Tal: 2  4  6  8  10 12 14 16 18 20\n       |  |  |  |  |  |  |  |  |  |\nIndex: 0  1  2  3  4  5  6  7  8  9\n\n\n\nFörst beräknar vi mitten av listan. I det här fallet är mittenindexet 4 (värdet 10).\n\n        2 4 6 8 [10] 12 14 16 18 20\n\nEftersom 14 är större än 10, fortsätter vi att söka i den högra halvan av listan. Det undre index sätts till 1 mer än mittenindex (4 + 1 = 5) och det övre indexet står kvar (9).\n\n        12 14 16 18 20\n\nVi beräknar mitten av den nya listan, vilket är index 7 (värdet 16).\n\n        12 14 [16] 18 20\n\nEftersom 14 är mindre än 16, fortsätter vi att söka i den vänstra halvan av den kvarvarande listan. Det undre indexet ändras då inte (5) och det övre indexet blir 1 mindre än mittenindex (7 - 1 = 6)\n\n        12 14\n\nMitten på denna lista är index 5 (värdet 12).\nEftersom 14 är större än 12 så fortsätter sökningen till höger om mitten i den ytterligare reducerade listan. Det undre indexet blir 1 mer än mittenindexet (5 + 1 = 6) och det övre indexet står kvar (6).\nEftersom det sökta värdet finns på mittenindexet så returnerar funktionen detta index.\n\n\n\n\n\nFörst beräknar vi mitten av listan. I det här fallet är mittenindexet 4 (värdet 12).\n\n        2 4 6 8 [10] 12 14 16 18 20\n\nEftersom 11 är större än 10, fortsätter vi att söka i den högra halvan av listan. Undre index: 5 (mittenindex + 1). Övre index: 9 (tidigare slutindex).\n\n        12 14 16 18 20\n\nVi beräknar mitten av den nya listan, vilket är index 7 (värdet 16).\n\n        12 14 [16] 18 20\n\nEftersom 11 är mindre än 16, fortsätter vi att söka i den vänstra halvan av listan. Undre index: 5 (tidigare startindex), övre index: 6 (mittenindex - 1).\n\n        12 14\n\nVi beräknar mitten av den nya listan, vilket är index 5 (värdet 12).\n\n        [12] 14\n\nEftersom 11 är mindre än 12, fortsätter vi att söka i den vänstra halvan av listan. Då sökningen ska ske till vänster ska det lägre indexet (5) stå kvar och det övre indexet ska vara 1 under mittenindex (5 - 1 = 4). Det gör att det övre indexet är lägre än det undre. När det läget är nått så har algoritmen visat att det sökta talet inte finns i listan.",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Binärsökning"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/binarsokning/index.html#algoritmen-i-pseudokod",
    "href": "pr1/python/uppgifter/binarsokning/index.html#algoritmen-i-pseudokod",
    "title": "Binärsökning",
    "section": "",
    "text": "def bin_search(lst, item, lower_i, upper_i):\n    # lst är den sorterade listan som sökningen sker i\n    # item är det som söks\n    # lower_i är det index där sökningen börjar\n    # upper_i är det index där sökningen slutar\n    \n    # LOOPA under villkoret upper_i &gt;= lower_i:\n        # SKAPA en variabel mid_i, som utgör indexet i mitten\n        # (avrundat nedåt). Använd heltalsdivision för denna beräkning.\n\n        # OM talet på indexet mid_i är det sökta talet\n            # returnera mid_i.\n        \n        # ANNARS OM talet på indexet mid_i är större än item\n            # ändra upper_i till mid_i - 1 (vänster del av lista ska sökas)\n        \n        # ANNARS, ändra lower_i till mid_i + 1 (höger del av lista ska sökas)\n    \n    # Returnera None (talet finns inte i listan)",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Binärsökning"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/binarsokning/index.html#uppgifter",
    "href": "pr1/python/uppgifter/binarsokning/index.html#uppgifter",
    "title": "Binärsökning",
    "section": "",
    "text": "Skapa funktionen bin_search enligt pseudokoden ovan. Testa den med några olika listor. Exempel på testprogram till funktionen:\n\n\n\n\nlst = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n\nval_1 = 12 # Ett värde som finns i listan\nval_2 = 25 # Ett värde som saknas i listan\n\nresult_1 = bin_search(lst, val_1, lower_i=0, upper_i=len(lst)-1)\nresult_2 = bin_search(lst, val_2, lower_i=0, upper_i=len(lst)-1)\n\nprint(result_1) # 5 (dvs värdet 12 finns på index 5)\nprint(result_2) # None (dvs värdet 5 saknas i listan)\n\n5\nNone\n\n\n\n\n\n\nUtveckla programmet så att det skriver ut i vilken partition av listan som genomsöks och antalet sökningar som gjorts. Exempel på utmatning:\n\n\n\nSöker efter talet 12 i listan [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\nSöker efter talet 12 i listan [12, 14, 16, 18, 20]\nSöker efter talet 12 i listan [12, 14]\nTalet 12 finns på index 5, hittades efter 3 sökningar\n\nSöker efter talet 25 i listan [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\nSöker efter talet 25 i listan [12, 14, 16, 18, 20]\nSöker efter talet 25 i listan [18, 20]\nSöker efter talet 25 i listan [20]\nTalet 25 saknas i listan, konstaterades efter 4 sökningar\n\n\n\n\n\n\nSkapa en (sorterad) lista med \\(1\\,000\\) element med spridda heltalsvärden mellan \\(1\\) och \\(2\\,000\\). Ta reda på med hjälp av funktionen hur många iterationer det\n\nmaximalt som är tvunget att göras\ni genomsnitt görs (såväl i de fall när talet saknas i listan och de fall där talet finns, se exemplet nedan).\n\nför att hitta ett tal som finns i listan alternativt utesluta förekomsten av det? (Här bör du söka efter vart och ett av alla tal mellan \\(1\\) och \\(2\\,000\\) för att få ett tillförlitligt resultat; vissa tal kommer att hittas medan andra naturligtvis saknas i listan.)\nGör sedan om samma undesökning med en lista på \\(10\\,000\\) element (med spridda heltalsvärden mellan 1 och \\(20\\,000\\)). Kommentera resultatet (antalet element har ökat med en faktor 10, men med vilken faktor har det genomsnittliga antalet sökningar förändrats?).\nTips: En lista lst kan sorteras med hjälp av metoden sort enligt lst.sort(). Det går alltså att skapa en lista med slumpmässiga heltal och därefter sortera den.\nNedan finns ett exempel. Antalet sökningar som gjorts i exemplet är dubbelt så många som listans storlek. T ex så baserar sig den första raden på en sökning i en lista på 100 slumpade heltal mellan 1 och 200, där vart och ett av talen 1, 2, 3,..., 200 eftersöks.\n\n\n\nListans    Antal iterationer    Antal iterationer    Maximalt antal\nstorlek    vid bom              vid träff            iterationer\n-------------------------------------------------------------------\n  100        6.84                   5.56                   7\n  200        7.77                   6.55                   8\n  300        8.30                   7.11                   9\n  400        8.78                   7.50                   9\n-------------------------------------------------------------------\nAntalet iterationer vid bom respektive träff är det genomsnittliga\nantalet för att konstatera att talet saknas i listan respektive\nhitta det index som det återfinns på.",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Binärsökning"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/sortering/index.html",
    "href": "pr1/python/uppgifter/sortering/index.html",
    "title": "Uppgifter: Sortering",
    "section": "",
    "text": "Det finns flera olika sorteringsalgoritmer, här ska vi titta på en som heter Bubble sort. Den går ut på att listan som ska sorteras itereras flera gånger och närliggande tal i den jämförs parvis. När två närliggande tal står i en följd som inte motsvarar storleksordning så byts plats på dessa tal.\nHär följer en illustration över av sortering av en specifik lista.\nListan [5, 7, 3, 6] ska sorteras i stigande nummerordning.\nDet görs genom listan gås igenom tal för tal flera gånger\noch att tal bredvid varandra byter plats om de inte står i\nrätt ordning. Det kräver två loopar: en yttre loop (loop-\nvariabel i) och en inre loop (loopvariabel j). I den inre\nloopen jämförs två närliggande tal parvis och den yttre\nloopen håller reda på antalet omstarter av den inre.\nEfter det första yttre varvet kommer det största talet att\nvara på rätt plats.\n\nLista, där index\nj och (j+1) jämförs    Kommentar\n----------------------------------------------------------\n5    7    3    6    |  i=0, j=0.\n^    ^              |  Jämför 5 och 7. Rätt ordning.\nj  (j+1)            |  \n----------------------------------------------------------\n5    7    3    6    |  i=0, j=1.\n     ^    ^         |  Jämför 7 och 3. Platsbyte ger\n     j  (j+1)       |  5    3    7    6\n----------------------------------------------------------\n                    |  i=0, j=2.\n5    3    7    6&gt;   |  Jämför 7 och 6. Platsbyte ger\n          ^    ^    |  5    3    6    7\n          j   (j+1) |  När det sista talet ingått i jäm-\n                    |  förelsen är det störst i listan.\n----------------------------------------------------------\n5    3    6    7    |  i=1, j=0. Omstart av inre loop.\n^    ^              |  Jämför 5 och 3. Platsbyte ger\nj  (j+1)            |  3    5    6    7\n----------------------------------------------------------\n                    |  i=1, j=1\n3    5    6&gt;    7   |  Jämför 5 och 6. Rätt ordning.\n     ^    ^         |  Det största talet står redan\n     j  (j+1)       |  sist. Nu är det näst största\n                    |  talet på rätt plats.\n----------------------------------------------------------\n3    5&gt;    6    7   |  i=2, j=0.\n^    ^              |  Jämför 3 och 5. Rätt ordning.\nj  (j+1)            |  När de båda första talen är på\n                    |  rätt plats är algoritmen klar.\n----------------------------------------------------------\nOrsaken till att denna algoritm kallas för Bubble sort är att de större talen “bubblar upp” mot slutet av listan. Efter den första iterationen så står det största talet sist, i nästa iteration ska alltså inte detta tal ingå i någon jämförelse.\n\n\n\nSom vi såg i beskrivningen av algoritm så bygger sorteringen på att byta plats på elementen parvis. Skriv en funktion swap(lst, i, j), där lst är en lista och i och j är de index vars tal ska byta plats. Eftersom lst är en lista, som funktionen hanterar som en referens så behöver inget returneras, listan i funktionen är samma lista som den utanför funktionen.\nKörningsexempel\n\nlst = [7, 5, 4, 6]\nprint(f\"Listan före platsbytet: {lst}\")\nswap(lst, 1, 2)\nprint(f\"Listan efter platsbytet: {lst}\")\n\nListan före platsbytet: [7, 5, 4, 6]\nListan efter platsbytet: [7, 4, 5, 6]\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 1\n\n\n\n\n\nNedanstående lösning är en generell lösningsmtod, själva metoden fungerar i många programeringsspråk:\ndef swap(lst, i, j):\n    tmp = lst[i]\n    lst[i] = lst[j]\n    lst[j] = tmp\nNedanstående lösning är en lösning i lösning som fungerar i Python, men metoden fungerar i allmänhet inte i övriga programmeringsspråk.\ndef swap(lst, i, j):\n    lst[i], lst[j] = lst[j], lst[i]\nDet som är typiskt för Python, och även många andra programspråk, är att listor skickas som referens till funktioner. Det betyder att funktionen verkar på den lista som faktiskt skickades till den, inte på en kopia.\nVidare skickas även alla egendefinierade datatyper som referens till funktioner, däremot inte andra variabeltyper (som t ex int, str m.fl.); där måste ett värde returneras för att den del av programmet som anropade funktionen ska få del av resultatet.\n\n\n\n\n\n\nSkriv nu en funktion sortera som implementerar algoritm som är beskriven ovan. Denna funktion kommer att behöva anropa funktionen swap.\nAv samma orsak som funktionen swap inte returnerade något, ska heller inte sortera returnera något.\nKörningsexempel\n\nlst = [7, 5, 4, 6]\nprint(f\"Listan före sortering: {lst}\")\nsortera(lst)\nprint(f\"Listan efter sortering: {lst}\")\n\nListan före sortering: [7, 5, 4, 6]\nListan efter sortering: [4, 5, 6, 7]\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 2\n\n\n\n\n\ndef sortera(lst):\n    n = len(lst)\n    for i in range(n):\n        for j in range(n-i-1):\n            if lst[j] &gt; lst[j+1]:\n                swap(lst, j, j+1)\n\n\n\n\n\n\nEmellanåt kan behövas en funktion som kontrollerar om en lista är sorterad. Implementera en sådan funktion is_sorted; funktionen ska returnera det booleska värdet True om listan är sorterad och False om den inte är det.\nKörningsexempel\n\nlst = [7, 4, 5, 6]\nprint(f\"Är listan sorterad? {is_sorted(lst)}\")\nsortera(lst)\nprint(f\"Är listan sorterad nu då? {is_sorted(lst)}\")\n\nÄr listan sorterad? False\nÄr listan sorterad nu då? True\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 3\n\n\n\n\n\ndef is_sorted(lst):\n    for i in range(len(lst) - 1):\n        if lst[i] &gt; lst[i + 1]:\n            return False\n    return True\nKommentar: Det går direkt att jämföra listor med avseende på likhet enligt list_1 == list_2; det ger resultatet True om listorna är lika och annars False. Detta fungerar i allmänhet inte i andra programmeringsspråk, men ovanstående lösningsförslag gör det.\n\n\n\n\n\n\nDet går att mäta tiden det tar för en funktion att köra. Nedanstående exempel visar hur det kan göras (här mäts tiden för en loop som snurrar 1000 varv)\nExempel tidsmätning\n\nimport time\n\nstart_time = time.perf_counter()\nn = 0\nfor i in range(1000):\n    n += 1\nend_time = time.perf_counter()\n\nprint(f\"Antalet sekunder som krävdes för loopen: {(end_time - start_time):.2e}\")\n\nAntalet sekunder som krävdes för loopen: 4.47e-05\n\n\nSkapa en lista lst och lägg in ett antal heltal mellan \\(1\\) och \\(10\\,000\\) i slumpvis ordning. Mät tiden det tar för listan att sorteras med hjälp av din funktion sortera ovan om antalet element är\n\n\\(100\\)\n\\(1\\,000\\)\n\\(10\\,000\\)\n\\(100\\,000\\)\n\nGör samma sak med Pythons metod sort för att få en jämförelse av effektiviteten mellan vår algoritm och Pythons algoritm.\nExempel på användning av sort\n\nlst = [7, 5, 4, 6]\nprint(lst)\nlst.sort()  # Pythons inbyggda sorteringsmetod tillämpas\nprint(lst)\n\n[7, 5, 4, 6]\n[4, 5, 6, 7]\n\n\n\n\n\nSkriv en funktion custom_sort som sorterar listan så att de jämna talen sorteras i storleksordning före de uddas dito sortering. Funktionen ska inte använda någon av Pythons inbyggda list-funktioner, utan enbart bygga på loopar och platsbyten som är illustrerat i tidigare uppgifter.\nKörningsexempel:\n\nlst = [-5, 2, -8, 7, 9, 6]\ncustom_sort(lst)\nprint(lst) # Ska visa [-8, 2, 6, -5, 7, 9]\n\n[-8, 2, 6, -5, 7, 9]",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: Sortering"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/sortering/index.html#exempel-och-uppgifter",
    "href": "pr1/python/uppgifter/sortering/index.html#exempel-och-uppgifter",
    "title": "Uppgifter: Sortering",
    "section": "",
    "text": "Det finns flera olika sorteringsalgoritmer, här ska vi titta på en som heter Bubble sort. Den går ut på att listan som ska sorteras itereras flera gånger och närliggande tal i den jämförs parvis. När två närliggande tal står i en följd som inte motsvarar storleksordning så byts plats på dessa tal.\nHär följer en illustration över av sortering av en specifik lista.\nListan [5, 7, 3, 6] ska sorteras i stigande nummerordning.\nDet görs genom listan gås igenom tal för tal flera gånger\noch att tal bredvid varandra byter plats om de inte står i\nrätt ordning. Det kräver två loopar: en yttre loop (loop-\nvariabel i) och en inre loop (loopvariabel j). I den inre\nloopen jämförs två närliggande tal parvis och den yttre\nloopen håller reda på antalet omstarter av den inre.\nEfter det första yttre varvet kommer det största talet att\nvara på rätt plats.\n\nLista, där index\nj och (j+1) jämförs    Kommentar\n----------------------------------------------------------\n5    7    3    6    |  i=0, j=0.\n^    ^              |  Jämför 5 och 7. Rätt ordning.\nj  (j+1)            |  \n----------------------------------------------------------\n5    7    3    6    |  i=0, j=1.\n     ^    ^         |  Jämför 7 och 3. Platsbyte ger\n     j  (j+1)       |  5    3    7    6\n----------------------------------------------------------\n                    |  i=0, j=2.\n5    3    7    6&gt;   |  Jämför 7 och 6. Platsbyte ger\n          ^    ^    |  5    3    6    7\n          j   (j+1) |  När det sista talet ingått i jäm-\n                    |  förelsen är det störst i listan.\n----------------------------------------------------------\n5    3    6    7    |  i=1, j=0. Omstart av inre loop.\n^    ^              |  Jämför 5 och 3. Platsbyte ger\nj  (j+1)            |  3    5    6    7\n----------------------------------------------------------\n                    |  i=1, j=1\n3    5    6&gt;    7   |  Jämför 5 och 6. Rätt ordning.\n     ^    ^         |  Det största talet står redan\n     j  (j+1)       |  sist. Nu är det näst största\n                    |  talet på rätt plats.\n----------------------------------------------------------\n3    5&gt;    6    7   |  i=2, j=0.\n^    ^              |  Jämför 3 och 5. Rätt ordning.\nj  (j+1)            |  När de båda första talen är på\n                    |  rätt plats är algoritmen klar.\n----------------------------------------------------------\nOrsaken till att denna algoritm kallas för Bubble sort är att de större talen “bubblar upp” mot slutet av listan. Efter den första iterationen så står det största talet sist, i nästa iteration ska alltså inte detta tal ingå i någon jämförelse.\n\n\n\nSom vi såg i beskrivningen av algoritm så bygger sorteringen på att byta plats på elementen parvis. Skriv en funktion swap(lst, i, j), där lst är en lista och i och j är de index vars tal ska byta plats. Eftersom lst är en lista, som funktionen hanterar som en referens så behöver inget returneras, listan i funktionen är samma lista som den utanför funktionen.\nKörningsexempel\n\nlst = [7, 5, 4, 6]\nprint(f\"Listan före platsbytet: {lst}\")\nswap(lst, 1, 2)\nprint(f\"Listan efter platsbytet: {lst}\")\n\nListan före platsbytet: [7, 5, 4, 6]\nListan efter platsbytet: [7, 4, 5, 6]\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 1\n\n\n\n\n\nNedanstående lösning är en generell lösningsmtod, själva metoden fungerar i många programeringsspråk:\ndef swap(lst, i, j):\n    tmp = lst[i]\n    lst[i] = lst[j]\n    lst[j] = tmp\nNedanstående lösning är en lösning i lösning som fungerar i Python, men metoden fungerar i allmänhet inte i övriga programmeringsspråk.\ndef swap(lst, i, j):\n    lst[i], lst[j] = lst[j], lst[i]\nDet som är typiskt för Python, och även många andra programspråk, är att listor skickas som referens till funktioner. Det betyder att funktionen verkar på den lista som faktiskt skickades till den, inte på en kopia.\nVidare skickas även alla egendefinierade datatyper som referens till funktioner, däremot inte andra variabeltyper (som t ex int, str m.fl.); där måste ett värde returneras för att den del av programmet som anropade funktionen ska få del av resultatet.\n\n\n\n\n\n\nSkriv nu en funktion sortera som implementerar algoritm som är beskriven ovan. Denna funktion kommer att behöva anropa funktionen swap.\nAv samma orsak som funktionen swap inte returnerade något, ska heller inte sortera returnera något.\nKörningsexempel\n\nlst = [7, 5, 4, 6]\nprint(f\"Listan före sortering: {lst}\")\nsortera(lst)\nprint(f\"Listan efter sortering: {lst}\")\n\nListan före sortering: [7, 5, 4, 6]\nListan efter sortering: [4, 5, 6, 7]\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 2\n\n\n\n\n\ndef sortera(lst):\n    n = len(lst)\n    for i in range(n):\n        for j in range(n-i-1):\n            if lst[j] &gt; lst[j+1]:\n                swap(lst, j, j+1)\n\n\n\n\n\n\nEmellanåt kan behövas en funktion som kontrollerar om en lista är sorterad. Implementera en sådan funktion is_sorted; funktionen ska returnera det booleska värdet True om listan är sorterad och False om den inte är det.\nKörningsexempel\n\nlst = [7, 4, 5, 6]\nprint(f\"Är listan sorterad? {is_sorted(lst)}\")\nsortera(lst)\nprint(f\"Är listan sorterad nu då? {is_sorted(lst)}\")\n\nÄr listan sorterad? False\nÄr listan sorterad nu då? True\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 3\n\n\n\n\n\ndef is_sorted(lst):\n    for i in range(len(lst) - 1):\n        if lst[i] &gt; lst[i + 1]:\n            return False\n    return True\nKommentar: Det går direkt att jämföra listor med avseende på likhet enligt list_1 == list_2; det ger resultatet True om listorna är lika och annars False. Detta fungerar i allmänhet inte i andra programmeringsspråk, men ovanstående lösningsförslag gör det.\n\n\n\n\n\n\nDet går att mäta tiden det tar för en funktion att köra. Nedanstående exempel visar hur det kan göras (här mäts tiden för en loop som snurrar 1000 varv)\nExempel tidsmätning\n\nimport time\n\nstart_time = time.perf_counter()\nn = 0\nfor i in range(1000):\n    n += 1\nend_time = time.perf_counter()\n\nprint(f\"Antalet sekunder som krävdes för loopen: {(end_time - start_time):.2e}\")\n\nAntalet sekunder som krävdes för loopen: 4.47e-05\n\n\nSkapa en lista lst och lägg in ett antal heltal mellan \\(1\\) och \\(10\\,000\\) i slumpvis ordning. Mät tiden det tar för listan att sorteras med hjälp av din funktion sortera ovan om antalet element är\n\n\\(100\\)\n\\(1\\,000\\)\n\\(10\\,000\\)\n\\(100\\,000\\)\n\nGör samma sak med Pythons metod sort för att få en jämförelse av effektiviteten mellan vår algoritm och Pythons algoritm.\nExempel på användning av sort\n\nlst = [7, 5, 4, 6]\nprint(lst)\nlst.sort()  # Pythons inbyggda sorteringsmetod tillämpas\nprint(lst)\n\n[7, 5, 4, 6]\n[4, 5, 6, 7]\n\n\n\n\n\nSkriv en funktion custom_sort som sorterar listan så att de jämna talen sorteras i storleksordning före de uddas dito sortering. Funktionen ska inte använda någon av Pythons inbyggda list-funktioner, utan enbart bygga på loopar och platsbyten som är illustrerat i tidigare uppgifter.\nKörningsexempel:\n\nlst = [-5, 2, -8, 7, 9, 6]\ncustom_sort(lst)\nprint(lst) # Ska visa [-8, 2, 6, -5, 7, 9]\n\n[-8, 2, 6, -5, 7, 9]",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: Sortering"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/listor/index.html",
    "href": "pr1/python/uppgifter/listor/index.html",
    "title": "Uppgifter: Listor",
    "section": "",
    "text": "Denna övning ska genomföras i konsolen, dvs inte sparas i någon fil\nSkapa listan lst. Lägg till tio stycken heltalsvärden; dessa ska inte vara i någon storleksordning. Utför därefter följande:\n\nprint(lst)\nprint(lst[0])\nprint(lst[2])\nprint(lst[-1])\n\nVad skrivs ut? Reflektera över varför resultatet blir det som det blir.\nPröva nu följande kommandon på lst:\n\nprint(len(lst))\nprint(sum(lst))\nprint(max(lst))\nprint(min(lst))\nprint(sorted(lst))\nprint(lst)\nlst.sort(reverse=True)\nprint(lst)\n\nVad skrivs ut? Reflektera speciellt över skillnaden mellan utskriften i j-uppgiften respektive l-uppgiften.\nPröva nu att utföra\n\nlst.pop()\n\nVad hände? Hur ser listan ut nu, och vad verkar pop() göra med listan?\nMetoden pop() kan också ta ett argument. Pröva att utföra\n\nlst.pop(5)\n\nSe vad som kommer ut och jämför hur listan ser ut efter utförandet av detta med hur den såg ut före.\nPröva nu att utföra\n\nlst.append(42)\n\nHur ser listan ut nu, och vad verkar append() göra med listan?\nSlutligen kan en del av en lista väljas ut, det kallas för slicing på engelska. Se till att du har minst 10 element i din lista (utför kommandot len(lst) för att se antalet element; om det är färre än 10 element kan du lägga till så många som behövs med append), och utför kommandona\n\nprint(lst[2:5])\nprint(lst[5:])\nprint(lst[:5])\n\nDessa ‘’slicar’’ förändrar inte variabeln lst. Däremot går det att skapa en annan variabel som innehåller de fem första värdena i lst genom lst2 = lst[:5]. Pröva detta, jämför därefter variabeln lst och lst2 med varandra.\n\n\n\n\n\n\nLösningsförslag uppgift 1\n\n\n\n\n\nDessa uppgifter är inte av karaktären att det finns lösningsförslag. Däremot kan det tryckas på att lst.sort(), lst.pop() och lst.append() förändrar listan lst; de är s.k metoder som opererar på listor.\nDe övriga operationerna i uppgifterna ger enbart en utmatning av det som önskas, t ex print(sorted(lst)) skriver ut en sorterad lista. (sorted är en funktion som returnerar en ny lista, men som inte förändrar den lista som den tog emot).\n\n\n\n\n\n\nDenna övning ska göras i en fil som sparas\nSkapa en lista med heltal från 1 till 100 och använd en for-loop för att beräkna summan av alla tal i listan. OBS! Du ska inte använda funktionen sum, men du bör kontrollera din beräknade summa med denna funktion.\n\n\n\n\n\n\nLösningsförslag uppgift 2\n\n\n\n\n\nlst = list(range(1, 101))\nsum = 0\nfor i in lst:\n  sum += i\nprint(sum)\n\n\n\n\n\n\nDenna övning ska göras i en fil som sparas\nSkapa listan heltal, som innehåller tio slumpade positiva heltal mellan 1 och 100.\nSkapa därefter de tomma listorna jämna och udda. Uppgiften är att kopiera över de jämna talen från listan heltal till listan jämna, och på motsvarande sätt kopiera över de udda talen till listan udda. Slutligen ska alla listor skrivas ut i storleksordning.\nModellen för att lösa uppgiften kan vara att man loopar genom alla tal i listan heltal, och testa om respektive tal är jämnt eller udda. Därefter så läggs talet till i rätt lista.\nKörningsexempel:\n\n\n\n\n\n\n\n\nDen framslumpade heltalslistan är:\n[1, 7, 52, 55, 60, 63, 68, 74, 90, 92]\n\nDet finns 6 jämna tal i listan. Dessa är:\n[52, 60, 68, 74, 90, 92]\n\nDet finns 4 udda tal i listan. Dessa är:\n[1, 7, 55, 63]\n\n\n\n\n\n\n\n\n\n\n\n\nTips\n\n\n\nFör att skapa en listan med slumpmässiga heltal måste random-modulen importeras överst i programmet. Därefter kan ett slumpat heltal skapas. Koden blir som följer:\nimport random as rand\nslumptal = rand.randint(1, 100)\nFör att lägga till ett tal en lista används metoden append (se Uppgift 1); detta måste förstås ske i en loop eftersom det är flera tal som ska läggas till. Förmodligen är det bästa sättet att använda två separata loopar: en loop för att skapa innehållet i listan heltal, och en annan loop för att skapa innehållet i listan jämna respektive udda.\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 3\n\n\n\n\n\nimport random as rand\n\nheltal = []\njämna = []\nudda = []\n\n# Heltalslistan med slumptal skapas\nfor i in range(0, 10):\n    slumptal = rand.randint(1, 100)\n    heltal.append(slumptal)\n\n# Loopa genom heltalslistan och kopiera jämna och udda tal\n# till respektive ny lista\nfor tal in heltal:\n    if tal % 2 == 0: # Kontroll om aktuellt tal är delbart med 2\n        jämna.append(tal)\n    else:\n        udda.append(tal)\n\n# Räkna antalet tal i respektive lista...\nantal_jämna = len(jämna)\nantal_udda = len(udda)\n\n# ...och skriv ut dessa\nprint(f\"Den framslumpade heltalslistan är:\\n{sorted(heltal)}\\n\")\nprint(f\"Det finns {antal_jämna} jämna tal i listan. Dessa är:\\n{sorted(jämna)}\\n\")\nprint(f\"Det finns {antal_udda} udda tal i listan. Dessa är:\\n{sorted(udda)}\\n\")\n\n\n\n\n\n\nDenna övning ska göras i en fil som sparas\nI Uppgift 2, Loopar i Python skapade du ett program som skulle slumpa fram en LOTTO-rad. Detta program har en stor brist: det finns risk för att ett och samma tal slumpas fram fler än en gång. Nu, när vi har tillgång till listor, kan vi korrigera denna brist!\nModell: Skapa först en lista (den kan kallas urna) som innehåller heltalen 1 – 35. Därefter så slumpas ett tal ur denna urna (och tar bort det), ett i taget, och lägger till i en annan lista (som t ex kan kallas lottorad). Det slumpade heltalet är alltså indexet för talet som slumpas fram ur urna.\nTänk på att när urnan innehåller 35 nummer ska indexet som slumpas fram vara mellan 0 och 34. Allteftersom urnan minskar i storlek måste indexets slumpomfång minskas för att undvika risk för programkrasch (som är följden av att man begär ett tal med ett index som är större än det maximala).\nKörningsexempel:\n\n\n\n\n\n\n\n\nBuggfri LOTTO-rad: [5, 19, 21, 26, 27, 29, 34]\n\n\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 4\n\n\n\n\n\nimport random as rand\nurna = list(range(1, 36))\nlottorad = []\n\nfor i in range(0, 7):\n    max_index = len(urna) - 1\n    slumpat_index = rand.randint(0, max_index)\n    lottotal = urna.pop(slumpat_index)\n    lottorad.append(lottotal)\nprint(f\"Buggfri LOTTO-rad: {sorted(lottorad)}\")\n\n\n\n\n\n\n\n\n\nDenna uppgift är lite större än de hittills givna uppgifterna. Här används villkor, loopar och listor. Även om inte egendefinierade funktioner behöver användas i detta program så kan det bli mer överskådligt om så görs. Arbeta gärna med det tillsammans med en kompis!\nDu ska skapa ett program som låter en användare sköta en lista genom en meny. Det ska likna följande:\n\n\n\n\n\n\nVad vill du göra?\n1. Titta på hela listan             2. Titta på ett givet läge i listan\n3. Lägga till ett värde i listan    4. Radera värdet på ett givet läge i listan\n5. Sortera listan                   6. Beräkna listans medelvärde\n7. Avsluta\n\nAnge ditt val -&gt; 3\nAnge det värde du vill lägga till -&gt; 10\n\nVad vill du göra?\n1. Titta på hela listan             2. Titta på ett givet läge i listan\n3. Lägga till ett värde i listan    4. Radera värdet på ett givet läge i listan\n5. Sortera listan                   6. Beräkna listans medelvärde\n7. Avsluta \n\nAnge ditt val -&gt; 1\nHär är hela listan just nu: [10] \n\nVad vill du göra?\n1. Titta på hela listan             2. Titta på ett givet läge i listan\n3. Lägga till ett värde i listan    4. Radera värdet på ett givet läge i listan\n5. Sortera listan                   6. Beräkna listans medelvärde\n7. Avsluta\n\nAnge ditt val -&gt; 3\nAnge det värde du vill lägga till -&gt; 5\n\nVad vill du göra?\n1. Titta på hela listan             2. Titta på ett givet läge i listan\n3. Lägga till ett värde i listan    4. Radera värdet på ett givet läge i listan\n5. Sortera listan                   6. Beräkna listans medelvärde\n7. Avsluta\n\nVad vill du göra?\n1. Titta på hela listan             2. Titta på ett givet läge i listan\n3. Lägga till ett värde i listan    4. Radera värdet på ett givet läge i listan\n5. Sortera listan                   6. Beräkna listans medelvärde\n7. Avsluta\n\nAnge ditt val -&gt; 1\nHär är hela listan just nu: [10, 5]\n\nVad vill du göra?\n1. Titta på hela listan             2. Titta på ett givet läge i listan\n3. Lägga till ett värde i listan    4. Radera värdet på ett givet läge i listan\n5. Sortera listan                   6. Beräkna listans medelvärde\n7. Avsluta\n\nAnge ditt val -&gt; 4\nAnge läget i listan med värdet som ska raderas (möjliga lägen: 1 till 2) -&gt; 1\n\nVad vill du göra?\n1. Titta på hela listan             2. Titta på ett givet läge i listan\n3. Lägga till ett värde i listan    4. Radera värdet på ett givet läge i listan\n5. Sortera listan                   6. Beräkna listans medelvärde\n7. Avsluta\n\nAnge ditt val -&gt; 1\n\nHär är hela listan just nu: [5] \n\n\n\nEtt läge i listan är ett heltal från 1 t o m det antal tal som finns där, medan ett värde i listan är ett heltal. Listan ska vara inmatningssäker, dvs felaktiga listval eller värden ska medföra att användaren får göra om inmatningen tills den är godtagbar. I Uppgift 3, Funktioner finns exempel på hur en inmatningssäker meny kan utformas (även om sammanhanget där är annorlunda).\nGlöm inte att skriva lämpliga kommentarer i koden. Om egendefinierade funktioner används ska respektive sådan dokumenteras med en docstring.\n\n\n\n\n\n\nTips\n\n\n\nOm strängar omgärdas av tre citationstecken så kan de enkelt radbrytas. Det kan användas för utskrift av menyn (även om det finns andra sätt).\n\nprint(\"\"\"Detta är\nen sträng på flera\nrader\"\"\")\n\nDetta är\nen sträng på flera\nrader",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: Listor"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/listor/index.html#uppgifter-med-kommentarer-och-lösningsförslag",
    "href": "pr1/python/uppgifter/listor/index.html#uppgifter-med-kommentarer-och-lösningsförslag",
    "title": "Uppgifter: Listor",
    "section": "",
    "text": "Denna övning ska genomföras i konsolen, dvs inte sparas i någon fil\nSkapa listan lst. Lägg till tio stycken heltalsvärden; dessa ska inte vara i någon storleksordning. Utför därefter följande:\n\nprint(lst)\nprint(lst[0])\nprint(lst[2])\nprint(lst[-1])\n\nVad skrivs ut? Reflektera över varför resultatet blir det som det blir.\nPröva nu följande kommandon på lst:\n\nprint(len(lst))\nprint(sum(lst))\nprint(max(lst))\nprint(min(lst))\nprint(sorted(lst))\nprint(lst)\nlst.sort(reverse=True)\nprint(lst)\n\nVad skrivs ut? Reflektera speciellt över skillnaden mellan utskriften i j-uppgiften respektive l-uppgiften.\nPröva nu att utföra\n\nlst.pop()\n\nVad hände? Hur ser listan ut nu, och vad verkar pop() göra med listan?\nMetoden pop() kan också ta ett argument. Pröva att utföra\n\nlst.pop(5)\n\nSe vad som kommer ut och jämför hur listan ser ut efter utförandet av detta med hur den såg ut före.\nPröva nu att utföra\n\nlst.append(42)\n\nHur ser listan ut nu, och vad verkar append() göra med listan?\nSlutligen kan en del av en lista väljas ut, det kallas för slicing på engelska. Se till att du har minst 10 element i din lista (utför kommandot len(lst) för att se antalet element; om det är färre än 10 element kan du lägga till så många som behövs med append), och utför kommandona\n\nprint(lst[2:5])\nprint(lst[5:])\nprint(lst[:5])\n\nDessa ‘’slicar’’ förändrar inte variabeln lst. Däremot går det att skapa en annan variabel som innehåller de fem första värdena i lst genom lst2 = lst[:5]. Pröva detta, jämför därefter variabeln lst och lst2 med varandra.\n\n\n\n\n\n\nLösningsförslag uppgift 1\n\n\n\n\n\nDessa uppgifter är inte av karaktären att det finns lösningsförslag. Däremot kan det tryckas på att lst.sort(), lst.pop() och lst.append() förändrar listan lst; de är s.k metoder som opererar på listor.\nDe övriga operationerna i uppgifterna ger enbart en utmatning av det som önskas, t ex print(sorted(lst)) skriver ut en sorterad lista. (sorted är en funktion som returnerar en ny lista, men som inte förändrar den lista som den tog emot).\n\n\n\n\n\n\nDenna övning ska göras i en fil som sparas\nSkapa en lista med heltal från 1 till 100 och använd en for-loop för att beräkna summan av alla tal i listan. OBS! Du ska inte använda funktionen sum, men du bör kontrollera din beräknade summa med denna funktion.\n\n\n\n\n\n\nLösningsförslag uppgift 2\n\n\n\n\n\nlst = list(range(1, 101))\nsum = 0\nfor i in lst:\n  sum += i\nprint(sum)\n\n\n\n\n\n\nDenna övning ska göras i en fil som sparas\nSkapa listan heltal, som innehåller tio slumpade positiva heltal mellan 1 och 100.\nSkapa därefter de tomma listorna jämna och udda. Uppgiften är att kopiera över de jämna talen från listan heltal till listan jämna, och på motsvarande sätt kopiera över de udda talen till listan udda. Slutligen ska alla listor skrivas ut i storleksordning.\nModellen för att lösa uppgiften kan vara att man loopar genom alla tal i listan heltal, och testa om respektive tal är jämnt eller udda. Därefter så läggs talet till i rätt lista.\nKörningsexempel:\n\n\n\n\n\n\n\n\nDen framslumpade heltalslistan är:\n[1, 7, 52, 55, 60, 63, 68, 74, 90, 92]\n\nDet finns 6 jämna tal i listan. Dessa är:\n[52, 60, 68, 74, 90, 92]\n\nDet finns 4 udda tal i listan. Dessa är:\n[1, 7, 55, 63]\n\n\n\n\n\n\n\n\n\n\n\n\nTips\n\n\n\nFör att skapa en listan med slumpmässiga heltal måste random-modulen importeras överst i programmet. Därefter kan ett slumpat heltal skapas. Koden blir som följer:\nimport random as rand\nslumptal = rand.randint(1, 100)\nFör att lägga till ett tal en lista används metoden append (se Uppgift 1); detta måste förstås ske i en loop eftersom det är flera tal som ska läggas till. Förmodligen är det bästa sättet att använda två separata loopar: en loop för att skapa innehållet i listan heltal, och en annan loop för att skapa innehållet i listan jämna respektive udda.\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 3\n\n\n\n\n\nimport random as rand\n\nheltal = []\njämna = []\nudda = []\n\n# Heltalslistan med slumptal skapas\nfor i in range(0, 10):\n    slumptal = rand.randint(1, 100)\n    heltal.append(slumptal)\n\n# Loopa genom heltalslistan och kopiera jämna och udda tal\n# till respektive ny lista\nfor tal in heltal:\n    if tal % 2 == 0: # Kontroll om aktuellt tal är delbart med 2\n        jämna.append(tal)\n    else:\n        udda.append(tal)\n\n# Räkna antalet tal i respektive lista...\nantal_jämna = len(jämna)\nantal_udda = len(udda)\n\n# ...och skriv ut dessa\nprint(f\"Den framslumpade heltalslistan är:\\n{sorted(heltal)}\\n\")\nprint(f\"Det finns {antal_jämna} jämna tal i listan. Dessa är:\\n{sorted(jämna)}\\n\")\nprint(f\"Det finns {antal_udda} udda tal i listan. Dessa är:\\n{sorted(udda)}\\n\")\n\n\n\n\n\n\nDenna övning ska göras i en fil som sparas\nI Uppgift 2, Loopar i Python skapade du ett program som skulle slumpa fram en LOTTO-rad. Detta program har en stor brist: det finns risk för att ett och samma tal slumpas fram fler än en gång. Nu, när vi har tillgång till listor, kan vi korrigera denna brist!\nModell: Skapa först en lista (den kan kallas urna) som innehåller heltalen 1 – 35. Därefter så slumpas ett tal ur denna urna (och tar bort det), ett i taget, och lägger till i en annan lista (som t ex kan kallas lottorad). Det slumpade heltalet är alltså indexet för talet som slumpas fram ur urna.\nTänk på att när urnan innehåller 35 nummer ska indexet som slumpas fram vara mellan 0 och 34. Allteftersom urnan minskar i storlek måste indexets slumpomfång minskas för att undvika risk för programkrasch (som är följden av att man begär ett tal med ett index som är större än det maximala).\nKörningsexempel:\n\n\n\n\n\n\n\n\nBuggfri LOTTO-rad: [5, 19, 21, 26, 27, 29, 34]\n\n\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 4\n\n\n\n\n\nimport random as rand\nurna = list(range(1, 36))\nlottorad = []\n\nfor i in range(0, 7):\n    max_index = len(urna) - 1\n    slumpat_index = rand.randint(0, max_index)\n    lottotal = urna.pop(slumpat_index)\n    lottorad.append(lottotal)\nprint(f\"Buggfri LOTTO-rad: {sorted(lottorad)}\")",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: Listor"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/listor/index.html#uppgift-utan-lösningsförslag",
    "href": "pr1/python/uppgifter/listor/index.html#uppgift-utan-lösningsförslag",
    "title": "Uppgifter: Listor",
    "section": "",
    "text": "Denna uppgift är lite större än de hittills givna uppgifterna. Här används villkor, loopar och listor. Även om inte egendefinierade funktioner behöver användas i detta program så kan det bli mer överskådligt om så görs. Arbeta gärna med det tillsammans med en kompis!\nDu ska skapa ett program som låter en användare sköta en lista genom en meny. Det ska likna följande:\n\n\n\n\n\n\nVad vill du göra?\n1. Titta på hela listan             2. Titta på ett givet läge i listan\n3. Lägga till ett värde i listan    4. Radera värdet på ett givet läge i listan\n5. Sortera listan                   6. Beräkna listans medelvärde\n7. Avsluta\n\nAnge ditt val -&gt; 3\nAnge det värde du vill lägga till -&gt; 10\n\nVad vill du göra?\n1. Titta på hela listan             2. Titta på ett givet läge i listan\n3. Lägga till ett värde i listan    4. Radera värdet på ett givet läge i listan\n5. Sortera listan                   6. Beräkna listans medelvärde\n7. Avsluta \n\nAnge ditt val -&gt; 1\nHär är hela listan just nu: [10] \n\nVad vill du göra?\n1. Titta på hela listan             2. Titta på ett givet läge i listan\n3. Lägga till ett värde i listan    4. Radera värdet på ett givet läge i listan\n5. Sortera listan                   6. Beräkna listans medelvärde\n7. Avsluta\n\nAnge ditt val -&gt; 3\nAnge det värde du vill lägga till -&gt; 5\n\nVad vill du göra?\n1. Titta på hela listan             2. Titta på ett givet läge i listan\n3. Lägga till ett värde i listan    4. Radera värdet på ett givet läge i listan\n5. Sortera listan                   6. Beräkna listans medelvärde\n7. Avsluta\n\nVad vill du göra?\n1. Titta på hela listan             2. Titta på ett givet läge i listan\n3. Lägga till ett värde i listan    4. Radera värdet på ett givet läge i listan\n5. Sortera listan                   6. Beräkna listans medelvärde\n7. Avsluta\n\nAnge ditt val -&gt; 1\nHär är hela listan just nu: [10, 5]\n\nVad vill du göra?\n1. Titta på hela listan             2. Titta på ett givet läge i listan\n3. Lägga till ett värde i listan    4. Radera värdet på ett givet läge i listan\n5. Sortera listan                   6. Beräkna listans medelvärde\n7. Avsluta\n\nAnge ditt val -&gt; 4\nAnge läget i listan med värdet som ska raderas (möjliga lägen: 1 till 2) -&gt; 1\n\nVad vill du göra?\n1. Titta på hela listan             2. Titta på ett givet läge i listan\n3. Lägga till ett värde i listan    4. Radera värdet på ett givet läge i listan\n5. Sortera listan                   6. Beräkna listans medelvärde\n7. Avsluta\n\nAnge ditt val -&gt; 1\n\nHär är hela listan just nu: [5] \n\n\n\nEtt läge i listan är ett heltal från 1 t o m det antal tal som finns där, medan ett värde i listan är ett heltal. Listan ska vara inmatningssäker, dvs felaktiga listval eller värden ska medföra att användaren får göra om inmatningen tills den är godtagbar. I Uppgift 3, Funktioner finns exempel på hur en inmatningssäker meny kan utformas (även om sammanhanget där är annorlunda).\nGlöm inte att skriva lämpliga kommentarer i koden. Om egendefinierade funktioner används ska respektive sådan dokumenteras med en docstring.\n\n\n\n\n\n\nTips\n\n\n\nOm strängar omgärdas av tre citationstecken så kan de enkelt radbrytas. Det kan användas för utskrift av menyn (även om det finns andra sätt).\n\nprint(\"\"\"Detta är\nen sträng på flera\nrader\"\"\")\n\nDetta är\nen sträng på flera\nrader",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: Listor"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/spara_objekt/index.html",
    "href": "pr1/python/uppgifter/spara_objekt/index.html",
    "title": "Spara objekt på fil",
    "section": "",
    "text": "Nedanstående kodexempel visar hur objekt kan sparas till fil, ändras på filen och läsas in från filen i programmet igen.\n\nimport json\nFILENAME = \"saved_avatars.json\"\n\n# Detta program kommer att läsa in några objekt av en egendefinierad datatyp i\n# en lista. Denna lista ska sparas på en fil som är läsbar för människor.\n# För att detta ska kunna göras måste respektive objekt konverterteras till\n# ett format som går att hantera på fil (serialiseras).\n# När datan i filen ska användas så läses den in i det serialiserade formatet,\n# varpå den återställs till objekt som datorn kan hantera (t ex göra\n# beräkningar på).\n\nclass Avatar:\n    def __init__(self, name, strength):\n        self.name = name\n        self.strength = strength\n\nav_1 = Avatar(\"Efelia\", 4)\nav_2 = Avatar(\"Ironfist\", 8)\nav_3 = Avatar(\"Mistwalker\", 2)\n\navatars = []\navatar_dicts = []\n\n# Lägg till avatarer i en lista\navatars.append(av_1)\navatars.append(av_2)\navatars.append(av_3)\n\n# Serialisera respektive objekt\nfor avatar in avatars:\n    avatar_dicts.append(avatar.__dict__)\n\nprint(\"Objekten representeras så här:\")\nprint(avatars)\nprint(\"(De är som synes ej läsbara för människor)\")\nprint()\nprint(\"De serialiserade objekten representeras så här:\")\nprint(avatar_dicts)\nprint(\"(Dessa går att få ut något av, och det är detta som sparas i filen)\")\nprint()\n\n# Skriv de serialiserade objekten på fil\nwith open(FILENAME, \"w\") as f:\n    json.dump(avatar_dicts, f)\n\n# Uppdatera. Listan med avatar-objekten förändras. Serialiseringen görs om. \navatars[0].strength = 6\navatar_dicts = []\n\n# Här gås alla objekten igenom igen, och skrivs om på filen. I det här fallet\n# så är Efelias styrka uppdaterad.\nfor avatar in avatars:\n    avatar_dicts.append(avatar.__dict__)\nwith open(FILENAME, \"w\") as f:\n    json.dump(avatar_dicts, f)\n\n# Töm listan med avatarobjekt och listan med de serialiserade objekten.\n# Snart ska de läsas tillbaka från filen.\n\navatars = []\navatar_dicts = {}\n\n# Läs in de serialiserade objekten från filen\nwith open(FILENAME, \"r\") as f:\n    avatar_dicts = json.load(f)\n\n# Återskapa listan med objekt av typen `Avatar`\nfor avatar in avatar_dicts:\n    avatars.append(Avatar(**avatar))\n\n# Nu kan listan `avatars` användas som vanligt i Pythonprogrammet!\nprint(\"Denna data har nu laddats i programmet:\")\nfor avatar in avatars:\n    print(f\"Namn: {avatar.name}. Styrka: {avatar.strength}\")\nprint(\"(Denna data går att hantera i programmet, t ex utföra beräkningar)\")\n\nObjekten representeras så här:\n[&lt;__main__.Avatar object at 0x107c27620&gt;, &lt;__main__.Avatar object at 0x107f834d0&gt;, &lt;__main__.Avatar object at 0x107f83610&gt;]\n(De är som synes ej läsbara för människor)\n\nDe serialiserade objekten representeras så här:\n[{'name': 'Efelia', 'strength': 4}, {'name': 'Ironfist', 'strength': 8}, {'name': 'Mistwalker', 'strength': 2}]\n(Dessa går att få ut något av, och det är detta som sparas i filen)\n\nDenna data har nu laddats i programmet:\nNamn: Efelia. Styrka: 6\nNamn: Ironfist. Styrka: 8\nNamn: Mistwalker. Styrka: 2\n(Denna data går att hantera i programmet, t ex utföra beräkningar)",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Spara objekt på fil"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/spara_objekt/index.html#kodexempel",
    "href": "pr1/python/uppgifter/spara_objekt/index.html#kodexempel",
    "title": "Spara objekt på fil",
    "section": "",
    "text": "Nedanstående kodexempel visar hur objekt kan sparas till fil, ändras på filen och läsas in från filen i programmet igen.\n\nimport json\nFILENAME = \"saved_avatars.json\"\n\n# Detta program kommer att läsa in några objekt av en egendefinierad datatyp i\n# en lista. Denna lista ska sparas på en fil som är läsbar för människor.\n# För att detta ska kunna göras måste respektive objekt konverterteras till\n# ett format som går att hantera på fil (serialiseras).\n# När datan i filen ska användas så läses den in i det serialiserade formatet,\n# varpå den återställs till objekt som datorn kan hantera (t ex göra\n# beräkningar på).\n\nclass Avatar:\n    def __init__(self, name, strength):\n        self.name = name\n        self.strength = strength\n\nav_1 = Avatar(\"Efelia\", 4)\nav_2 = Avatar(\"Ironfist\", 8)\nav_3 = Avatar(\"Mistwalker\", 2)\n\navatars = []\navatar_dicts = []\n\n# Lägg till avatarer i en lista\navatars.append(av_1)\navatars.append(av_2)\navatars.append(av_3)\n\n# Serialisera respektive objekt\nfor avatar in avatars:\n    avatar_dicts.append(avatar.__dict__)\n\nprint(\"Objekten representeras så här:\")\nprint(avatars)\nprint(\"(De är som synes ej läsbara för människor)\")\nprint()\nprint(\"De serialiserade objekten representeras så här:\")\nprint(avatar_dicts)\nprint(\"(Dessa går att få ut något av, och det är detta som sparas i filen)\")\nprint()\n\n# Skriv de serialiserade objekten på fil\nwith open(FILENAME, \"w\") as f:\n    json.dump(avatar_dicts, f)\n\n# Uppdatera. Listan med avatar-objekten förändras. Serialiseringen görs om. \navatars[0].strength = 6\navatar_dicts = []\n\n# Här gås alla objekten igenom igen, och skrivs om på filen. I det här fallet\n# så är Efelias styrka uppdaterad.\nfor avatar in avatars:\n    avatar_dicts.append(avatar.__dict__)\nwith open(FILENAME, \"w\") as f:\n    json.dump(avatar_dicts, f)\n\n# Töm listan med avatarobjekt och listan med de serialiserade objekten.\n# Snart ska de läsas tillbaka från filen.\n\navatars = []\navatar_dicts = {}\n\n# Läs in de serialiserade objekten från filen\nwith open(FILENAME, \"r\") as f:\n    avatar_dicts = json.load(f)\n\n# Återskapa listan med objekt av typen `Avatar`\nfor avatar in avatar_dicts:\n    avatars.append(Avatar(**avatar))\n\n# Nu kan listan `avatars` användas som vanligt i Pythonprogrammet!\nprint(\"Denna data har nu laddats i programmet:\")\nfor avatar in avatars:\n    print(f\"Namn: {avatar.name}. Styrka: {avatar.strength}\")\nprint(\"(Denna data går att hantera i programmet, t ex utföra beräkningar)\")\n\nObjekten representeras så här:\n[&lt;__main__.Avatar object at 0x107c27620&gt;, &lt;__main__.Avatar object at 0x107f834d0&gt;, &lt;__main__.Avatar object at 0x107f83610&gt;]\n(De är som synes ej läsbara för människor)\n\nDe serialiserade objekten representeras så här:\n[{'name': 'Efelia', 'strength': 4}, {'name': 'Ironfist', 'strength': 8}, {'name': 'Mistwalker', 'strength': 2}]\n(Dessa går att få ut något av, och det är detta som sparas i filen)\n\nDenna data har nu laddats i programmet:\nNamn: Efelia. Styrka: 6\nNamn: Ironfist. Styrka: 8\nNamn: Mistwalker. Styrka: 2\n(Denna data går att hantera i programmet, t ex utföra beräkningar)",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Spara objekt på fil"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/spara_objekt/index.html#uppgifter",
    "href": "pr1/python/uppgifter/spara_objekt/index.html#uppgifter",
    "title": "Spara objekt på fil",
    "section": "Uppgifter",
    "text": "Uppgifter\nNedanstående är förslag till uppgifter kring ovanstående kod. Syftet är att bli bekant med den typ av filhantering som demonstreras.\n\nLägg till fler egenskaper: Utveckla Avatar-klassen genom att lägga till fler attribut, till exempel level, skills (som en lista), och health.\nSpara flera olika typer av objekt: Skapa en ny klass, exempelvis Enemy, och implementera funktionalitet för att spara både Avatar och Enemy i olika JSON-filer.\nLäsa från flera filer: Skapa en funktion som läser in både Avatar- och Enemy-objekt och skriver ut en sammanställning av alla objekt som laddats in.\nInteraktiv användning: Utveckla en konsolapplikation där användaren kan skapa nya avatarer genom att ange namn och styrka. Dessa avatarer ska sparas automatiskt i filen.\nMenynavigering: Implementera en meny där användaren kan välja att:\n\nVisa alla sparade avatarer\nLägga till en ny avatar\nUppdatera en befintlig avatar\nTa bort en avatar",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Spara objekt på fil"
    ]
  },
  {
    "objectID": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#dagens-mål",
    "href": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#dagens-mål",
    "title": "En utblick till C",
    "section": "Dagens mål",
    "text": "Dagens mål\n\nAtt känna till några övergripande skillnader mellan Python och C\nAtt känna till några variabeltyper i C\nAtt skriva ett program i C som hanterar en inmatning och en utmatning\nAtt hantera enkla villkor i C"
  },
  {
    "objectID": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#en-stor-skillnad-mellan-python-och-c",
    "href": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#en-stor-skillnad-mellan-python-och-c",
    "title": "En utblick till C",
    "section": "En stor skillnad mellan Python och C",
    "text": "En stor skillnad mellan Python och C\n\n\n\n\nPython är ett interpreterat språk. Det för att köra ett Pythonprogram krävs att Python är installerat på datorn.\nC är ett kompilerat språk. Programmet körs direkt av operativsystemet (t ex Windows).\nPythonprogram har ett extra “lager” mellan program och operativsystem. Det gör att de körs långsammare."
  },
  {
    "objectID": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#variabler-i-c",
    "href": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#variabler-i-c",
    "title": "En utblick till C",
    "section": "Variabler i C",
    "text": "Variabler i C\nI Python behöver vi ofta inte tänka så mycket på datatypen som en variabel har.\nmy_number = 42\nmy_other_number = 3.14\nmy_number = 42.1 # Funkar fint\n\n\n\nI C så måste datatypen specificeras vid deklarationen, därefter kan den inte ändras.\nint my_number;\nmy_number = 42;\nfloat my_other_number;\nmy_other_number = 3.14;\n\nmy_number = 42.1; // Otillåtet, eftersom 42.1 är inte ett heltal"
  },
  {
    "objectID": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#utmatning-i-c",
    "href": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#utmatning-i-c",
    "title": "En utblick till C",
    "section": "Utmatning i C",
    "text": "Utmatning i C\nI C används ofta funktionen printf för textutmatning. Exempel:\nint my_int = 42;\nfloat my_float = 3.14;\nprintf(\"Mitt heltal är: %d\\n\", my_int);\nprintf(\"Mitt flyttal är: %f\\n\", my_float);\n\n\n\nTecknen %d och %f är formatangivare, som anger vilken typ av variabel som ska skrivas ut. Vi måste även lägga till radframmatning manuellt i printf-satsen i form av \\n (detta fungerar även i Python)."
  },
  {
    "objectID": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#ett-c-program",
    "href": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#ett-c-program",
    "title": "En utblick till C",
    "section": "Ett C-program",
    "text": "Ett C-program\nEtt Pythonprogram kan bestå av en enda rad, t ex print(\"Hello, world\"). I C, däremot, måste man inkludera vilka bibliotek som ska ingå i programmet och dessutom deklarera en funktion som programmet startar i. Den funktion som ett program startar i är alltid main.\n#include &lt;stdio.h&gt; // I detta bibliotek finns t ex `printf`\n\n// Här deklareras main, som är av typen `int`,\n// som inte tar någon parameter:\nint main(void) {\n    float pi = 3.14;\n    printf(\"Hello, my favourite number is %f\\n\", pi);\n    return 0;\n}"
  },
  {
    "objectID": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#inmatning",
    "href": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#inmatning",
    "title": "En utblick till C",
    "section": "Inmatning",
    "text": "Inmatning\nInmatning av data kan ske med funktionen scanf. Även den använder formatangivare för att avgöra vilken typ av data som förväntas.\n// In function main\nint a;\nfloat b;\nprintf(\"Enter two numbers separated by a space -&gt; \");\nscanf(\"%d %f\", &a, &b);\nprintf(\"You entered %d and %f\\n\", a, b);\n// ... Function continous\nTecknet &, en ampersand, används här för att skicka variablerna a och b som referenser till scanf. Det betyder att scanf får mandat att ändra dem, alltså tilldela dem värden."
  },
  {
    "objectID": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#division",
    "href": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#division",
    "title": "En utblick till C",
    "section": "Division",
    "text": "Division\nI Python används / för division och // för heltalsdivision. I C så ger division (/) med heltal ett heltal, och division med flyttal ett flyttal.\nint a = 15;\nint b = 5;\nint c = 6;\nprintf(\"Heltal: %d / %d = %d\\n\", a, b, a / b);\nprintf(\"Heltal: %d / %d = %d\\n\", a, c, a / c);\nprintf(\"Flyttal: %d / %d = %f\\n\", a, c, (float)a / (float)c);\n\n\n\nHeltal: 15 / 5 = 3\nHeltal: 15 / 6 = 2\nFlyttal: 15 / 6 = 2.500000\n\n\n\n\nFormatangivaren måste matcha variabeltypen. Det som görs på rad 6 kallas för en typkonver-tering."
  },
  {
    "objectID": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#villkor",
    "href": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#villkor",
    "title": "En utblick till C",
    "section": "Villkor",
    "text": "Villkor\nPrecis som i Python finns if-satser för att styra programmet med hjälp av jämförelser.\nint a = 10, b = 20;\nif (a &gt; b) {\n    printf(\"a &gt; b\");\n} else if (a &lt; b) {\n    printf(\"b &gt; a\");\n}\n  else {\n    printf(\"a är lika med b\");\n}\nI Python så används radindrag för att markera vad som hör till if-satsen, i C används “måsvingar” (braces). Radindragen är enbart estetiska."
  },
  {
    "objectID": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#lite-matematik",
    "href": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#lite-matematik",
    "title": "En utblick till C",
    "section": "Lite matematik",
    "text": "Lite matematik\nI biblioteket math.h finns många matematiska funktioner och konstanter definierade.\n#include &lt;math.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int a = 2, b = 3;\n    int c = pow(a, b);   // 8\n    float d = sqrt(a);   // 1.414214\n    float e = sin(M_PI); // 0.000000\n    int r = b % a;       // 1 (resten vid heltalsdivision)\n    return 0;\n}\nEn lista på ingående funktioner och konstanter finns här."
  },
  {
    "objectID": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#loopar",
    "href": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#loopar",
    "title": "En utblick till C",
    "section": "Loopar",
    "text": "Loopar\nDet finns tre varianter loopar i C:\n\nwhile-loopar\ndo while-loopar\nfor-loopar\n\nTill alla loopar finns styrsatsatserna break och continue, vilka verkar på på liknande sätt som i Python."
  },
  {
    "objectID": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#while-loopen",
    "href": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#while-loopen",
    "title": "En utblick till C",
    "section": "while-loopen",
    "text": "while-loopen\nStrukturmässigt så fungerar den på samma sätt som i Python, koden i loopen körs tills så länge ett villkor uppfylls.\nExempel:\nint i = 0;\n\n// Skriver ut 0 1 2 3 4\nwhile (i &lt; 5) {\n    printf(\"%d \", i);\n    i++; // Ökar i med 1\n}\nÄven här ser vi “måsvingarna” runt det som ska utföras. Vi ser också inkrementeringsoperatorn, ++, den ökar talet i fråga med 1."
  },
  {
    "objectID": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#do-while-loopen",
    "href": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#do-while-loopen",
    "title": "En utblick till C",
    "section": "do while-loopen",
    "text": "do while-loopen\nDenna loop har ingen direkt motsvarighet i Python, men fungerar ungefär som while-loopen. Medan while-loopen testar villkoret i början av varje varv, kommer do while-loopen att testa det i slutet.\nint i = 0;\ndo {\n    printf(\"%d \", i);\n    i++;\n} while (i &lt; 5);\nDet innebär att koden alltid kommer att köras minst en gång."
  },
  {
    "objectID": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#for-loopen",
    "href": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#for-loopen",
    "title": "En utblick till C",
    "section": "for-loopen",
    "text": "for-loopen\nI Python kan en for-loop användas för att iterera över en lista, men den egenskapen har inte for-loopar i C.\nint sum = 0;\nfor (int i = 0; i &lt; 5; i++) {\n  sum += i;\n  printf(\"i: %d\\t Summa: %2d\\n\", i, sum);\n}\n\n\n\ni: 0    Summa:  0\ni: 1    Summa:  1\ni: 2    Summa:  3\ni: 3    Summa:  6\ni: 4    Summa: 10\n\n\n\n\nLoopvariabeln i C är typiskt ett heltal (int), till skillnad från i Python där den kan vara vilket objekt som helst från en itererbar sekvens. for-loopen används ofta för att iterera över index i arrayer."
  },
  {
    "objectID": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#arrayer",
    "href": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#arrayer",
    "title": "En utblick till C",
    "section": "Arrayer",
    "text": "Arrayer\n\nI Python: listor. Elementen kan vara av olika datatyper.\nI C: Arrayer. Elementen måste vara av samma datatyp. Måste dessutom ange storlek i deklarationen.\n\nExempel på deklaration av array:\nint arr[5] = {0, 1, 2, 3, 4}; // Valfri initiering\narr[0] = 42;\nfor (int i = 0; i &lt; 5; i++) {\n    printf(\"%d \", arr[i]);\n} \n\n\n\n42 1 2 3 4\n\n\n\n\nArrayen manipuleras med sina index, det finns t ex inget append."
  },
  {
    "objectID": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#funktioner-i-c",
    "href": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#funktioner-i-c",
    "title": "En utblick till C",
    "section": "Funktioner i C",
    "text": "Funktioner i C\n\nFunktioner i C används för att organisera kod och återanvända logik, precis som i Python.\nTvå viktiga skillnader mot Python:\n\nFunktionen måste deklareras innan den anropas i koden.\nMan måste ange vilken datatyp som funktionen returnerar (eller void om inget returneras).\n\nI funktionsdefinitionen finns koden för vad funktionen gör."
  },
  {
    "objectID": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#exempel-på-funktioner",
    "href": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#exempel-på-funktioner",
    "title": "En utblick till C",
    "section": "Exempel på funktioner",
    "text": "Exempel på funktioner\n#include &lt;stdio.h&gt;\n\nvoid say_hi();         // Funktionerna\nint add(int a, int b); // deklareras\n\nint main(void) {\n    say_hi();                    // Funktionerna\n    int s = add(2, 3);           // anropas\n    printf(\"Summan är %d\\n\", s); // Returvärdet används\n    return 0;\n}\n\nvoid say_hi(void) {        // Implementering av say_hi\n    printf(\"Hi!\\n\");       // Inget returvärde\n}\n\nint add(int a, int b) {    // Implementering av add\n    int sum = a + b;\n    return sum;            // Returnerar ett värde\n}\n\n\n\nHi!\nSumman är 5"
  },
  {
    "objectID": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#strängar",
    "href": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#strängar",
    "title": "En utblick till C",
    "section": "Strängar",
    "text": "Strängar\nI C så finns ingen strängdatatyp, utan en sträng är en array av datatypen char.\nchar str[13] = \"Hello, world\"; // Strängdeklaration\nprintf(\"%s\\n\", str);           // Utskrift av sträng\n// str = \"C rules!\\n\";         // Otillåtet!\nAtt ändra en sträng genom en tilldelning, som i rad 3 ovan, är inte tillåtet i C. Istället så kan funktionen strcpy användas.\nstrcpy(str, \"C rules!\\n\"); // Nu är str ändrad\nSträngen får inte överskrida 12 tecken plus nollterminatorn '\\0'.\nstrcpy finns i string.h, som alltså måste inkluderas."
  },
  {
    "objectID": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#strängar-i-funktioner",
    "href": "pr1/python/en-utblick-till-c/presentation/python-vs-c.html#strängar-i-funktioner",
    "title": "En utblick till C",
    "section": "Strängar i funktioner",
    "text": "Strängar i funktioner\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt; // För strcpy\n\nvoid greet(char name[]) { // Notera parametern för strängen!\n    printf(\"Hej, %s!\\n\", name);\n}\n\nint main(void) {\n    char my_name[10] = \"Anna\"; // Initial tilldelning\n    strcpy(my_name, \"Kalle\");  // Kopierar ny sträng\n    greet(my_name);\n    return 0;\n}\n\n\n\nHej, Kalle!\n\n\n\n\nSträngen tas emot som parameter, och funktionen definieras direkt utan separat deklaration."
  },
  {
    "objectID": "pr1/python/uppgifter/en-utblick-till-c/index.html",
    "href": "pr1/python/uppgifter/en-utblick-till-c/index.html",
    "title": "Uppgifter: En utblick till C",
    "section": "",
    "text": "Skapa ett program som innehåller en heltalsvariabel my_int och en flyttalsvariabel my_float. Ansätt ett valfritt värde till var och en av dessa (direkt i programmet, du ska inte ange några värden under körning) och skriv ut dessa värden.\nExempel på utmatning:\nVärdet på my_int: 42\nVärdet på my_float: 3.14\n\n\n\nSkapa ett program som tar emot två heltal från en inmatning. Programmet ska skriva ut summan, differensen, produkten och kvoten av dessa.\nExempel på en programkörning (pröva även att ansätta det tal som blir nämnare i divisionen till noll):\nAnge tal 1-&gt; 10\nAnge tal 2-&gt; 20\n---------------------\nTalens summa: 30\nTalens differens: -10\nTalens produkt: 200\nTalens kvot: 0.500000\n\n\n\nFörr i tiden så handlade de flesta kunder i butikerna med kontanter. Hade inte kunden jämna pengar så utgavs växel. Växeln kunde ges i olika valörer, t ex tiokronor, femkronor och enkronor. Skriv ett program som tar emot två inmatningar: ett pris och en betalning. Därefter ska programmet ange växeln och förslag på valörer i växeln, förslaget ska prioritera så höga valörer som möjligt. Valörerna i denna övning begränsas till enkronor, femmor och tior. Endast de valörer som ingår i växeln ska skrivas ut.\nExempel på tre programkörningar:\nAnge pris i kronor-&gt; 63                Ange pris i kronor-&gt; 91\nAnge belopp som kunden ger-&gt; 100       Ange belopp som kunden ger-&gt; 100\n---------------------------------      ---------------------------------\nVäxel: 37 kr.                          Växel: 9 kr.\nValörer i växeln                       Valörer i växeln\nAntal tior: 3                          Antal femmor: 1\nAntal femmor: 1                        Antal enkronor: 4\nAntal enkronor: 2\n\n\nAnge pris i kronor-&gt; 45\nAnge belopp som kunden ger-&gt; 45\n---------------------------------\nJämna pengar, tackar :-)\n\n\n\nFormeln för att lösa en allmän andragradsekvation lyder\n\\[\nax^2+bx+c=0\\Leftrightarrow x_1=\\frac{-b-\\sqrt{b^2-4ac}}{2a},\\hspace{5mm}\nx_2=\\frac{-b+\\sqrt{b^2-4ac}}{2a}\n\\]\nSkriv ett program som tar emot de tre parametrarna \\(a,b\\) och \\(c\\) och skriver ut lösningarna till ekvationen förutsatt att de är reella.\nExempelkörningar:\nAnge parametrarna a, b och c separerade med mellanslag-&gt; 2 4 -6\nx1 = -3.000000\nx2 = 1.000000\n\nAnge parametrarna a, b och c separerade med mellanslag-&gt; 1 2 3\nReella lösningar saknas.\n\n\n\nSkriv ett program som deklarerar en array med fem heltal, fyller den med värdena 10, 20, 30, 40, 50 och skriver ut dem i ordning och i omvänd ordning med hjälp av for-loopar.\nExempelkörning\nUrsprunglig ordning: 10 20 30 40 50 \nOmvänd ordning: 50 40 30 20 10\n\n\n\nSkriv en funktion multiply som tar två heltal som parametrar och returnerar deras produkt. Låt användaren ange talen i main och skriv ut resultatet därifrån.\nExempelkörning\nAnge första faktorn: 4\nAnge andra faktorn: 5\nProdukten av 4 och 5 är 20\n\n\n\nDeklarera en sträng med plats för minst tio tecken och tilldela den initialt värdet “Sol”. Ändra sedan strängen till “Måne” med hjälp av funktionen strcpy (tänk på att inkludera string.h).\nExempelkörning\nUrsprunglig sträng: Sol\nUppdaterad sträng: Måne\n\n\n\nSkriv en funktion welcome som tar en sträng som parameter och skriver ut “Välkommen sträng!”. Anropa funktionen med strängen “Staffan”.\nExempelkörning\nVälkommen Staffan!\n\n\n\nI ett program deklareras en array med fyra heltal: 1, 3, 5, 7. Skriv en funktion sum_array som tar en array och dess storlek som parametrar och returnerar summan av dess element (varför måste storleken anges som parameter?). Anropa funktionen från main och skriv ut resultatet därifrån.\nExempelkörning\nSumman är: 16",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: En utblick till C"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/en-utblick-till-c/index.html#uppgift-1",
    "href": "pr1/python/uppgifter/en-utblick-till-c/index.html#uppgift-1",
    "title": "Uppgifter: En utblick till C",
    "section": "",
    "text": "Skapa ett program som innehåller en heltalsvariabel my_int och en flyttalsvariabel my_float. Ansätt ett valfritt värde till var och en av dessa (direkt i programmet, du ska inte ange några värden under körning) och skriv ut dessa värden.\nExempel på utmatning:\nVärdet på my_int: 42\nVärdet på my_float: 3.14",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: En utblick till C"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/en-utblick-till-c/index.html#uppgift-2",
    "href": "pr1/python/uppgifter/en-utblick-till-c/index.html#uppgift-2",
    "title": "Uppgifter: En utblick till C",
    "section": "",
    "text": "Skapa ett program som tar emot två heltal från en inmatning. Programmet ska skriva ut summan, differensen, produkten och kvoten av dessa.\nExempel på en programkörning (pröva även att ansätta det tal som blir nämnare i divisionen till noll):\nAnge tal 1-&gt; 10\nAnge tal 2-&gt; 20\n---------------------\nTalens summa: 30\nTalens differens: -10\nTalens produkt: 200\nTalens kvot: 0.500000",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: En utblick till C"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/en-utblick-till-c/index.html#uppgift-3",
    "href": "pr1/python/uppgifter/en-utblick-till-c/index.html#uppgift-3",
    "title": "Uppgifter: En utblick till C",
    "section": "",
    "text": "Förr i tiden så handlade de flesta kunder i butikerna med kontanter. Hade inte kunden jämna pengar så utgavs växel. Växeln kunde ges i olika valörer, t ex tiokronor, femkronor och enkronor. Skriv ett program som tar emot två inmatningar: ett pris och en betalning. Därefter ska programmet ange växeln och förslag på valörer i växeln, förslaget ska prioritera så höga valörer som möjligt. Valörerna i denna övning begränsas till enkronor, femmor och tior. Endast de valörer som ingår i växeln ska skrivas ut.\nExempel på tre programkörningar:\nAnge pris i kronor-&gt; 63                Ange pris i kronor-&gt; 91\nAnge belopp som kunden ger-&gt; 100       Ange belopp som kunden ger-&gt; 100\n---------------------------------      ---------------------------------\nVäxel: 37 kr.                          Växel: 9 kr.\nValörer i växeln                       Valörer i växeln\nAntal tior: 3                          Antal femmor: 1\nAntal femmor: 1                        Antal enkronor: 4\nAntal enkronor: 2\n\n\nAnge pris i kronor-&gt; 45\nAnge belopp som kunden ger-&gt; 45\n---------------------------------\nJämna pengar, tackar :-)",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: En utblick till C"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/en-utblick-till-c/index.html#uppgift-4",
    "href": "pr1/python/uppgifter/en-utblick-till-c/index.html#uppgift-4",
    "title": "Uppgifter: En utblick till C",
    "section": "",
    "text": "Formeln för att lösa en allmän andragradsekvation lyder\n\\[\nax^2+bx+c=0\\Leftrightarrow x_1=\\frac{-b-\\sqrt{b^2-4ac}}{2a},\\hspace{5mm}\nx_2=\\frac{-b+\\sqrt{b^2-4ac}}{2a}\n\\]\nSkriv ett program som tar emot de tre parametrarna \\(a,b\\) och \\(c\\) och skriver ut lösningarna till ekvationen förutsatt att de är reella.\nExempelkörningar:\nAnge parametrarna a, b och c separerade med mellanslag-&gt; 2 4 -6\nx1 = -3.000000\nx2 = 1.000000\n\nAnge parametrarna a, b och c separerade med mellanslag-&gt; 1 2 3\nReella lösningar saknas.",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: En utblick till C"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/en-utblick-till-c/index.html#uppgift-5",
    "href": "pr1/python/uppgifter/en-utblick-till-c/index.html#uppgift-5",
    "title": "Uppgifter: En utblick till C",
    "section": "",
    "text": "Skriv ett program som deklarerar en array med fem heltal, fyller den med värdena 10, 20, 30, 40, 50 och skriver ut dem i ordning och i omvänd ordning med hjälp av for-loopar.\nExempelkörning\nUrsprunglig ordning: 10 20 30 40 50 \nOmvänd ordning: 50 40 30 20 10",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: En utblick till C"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/en-utblick-till-c/index.html#uppgift-6",
    "href": "pr1/python/uppgifter/en-utblick-till-c/index.html#uppgift-6",
    "title": "Uppgifter: En utblick till C",
    "section": "",
    "text": "Skriv en funktion multiply som tar två heltal som parametrar och returnerar deras produkt. Låt användaren ange talen i main och skriv ut resultatet därifrån.\nExempelkörning\nAnge första faktorn: 4\nAnge andra faktorn: 5\nProdukten av 4 och 5 är 20",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: En utblick till C"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/en-utblick-till-c/index.html#uppgift-7",
    "href": "pr1/python/uppgifter/en-utblick-till-c/index.html#uppgift-7",
    "title": "Uppgifter: En utblick till C",
    "section": "",
    "text": "Deklarera en sträng med plats för minst tio tecken och tilldela den initialt värdet “Sol”. Ändra sedan strängen till “Måne” med hjälp av funktionen strcpy (tänk på att inkludera string.h).\nExempelkörning\nUrsprunglig sträng: Sol\nUppdaterad sträng: Måne",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: En utblick till C"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/en-utblick-till-c/index.html#uppgift-8",
    "href": "pr1/python/uppgifter/en-utblick-till-c/index.html#uppgift-8",
    "title": "Uppgifter: En utblick till C",
    "section": "",
    "text": "Skriv en funktion welcome som tar en sträng som parameter och skriver ut “Välkommen sträng!”. Anropa funktionen med strängen “Staffan”.\nExempelkörning\nVälkommen Staffan!",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: En utblick till C"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/en-utblick-till-c/index.html#uppgift-9",
    "href": "pr1/python/uppgifter/en-utblick-till-c/index.html#uppgift-9",
    "title": "Uppgifter: En utblick till C",
    "section": "",
    "text": "I ett program deklareras en array med fyra heltal: 1, 3, 5, 7. Skriv en funktion sum_array som tar en array och dess storlek som parametrar och returnerar summan av dess element (varför måste storleken anges som parameter?). Anropa funktionen från main och skriv ut resultatet därifrån.\nExempelkörning\nSumman är: 16",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: En utblick till C"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/loopar/index.html",
    "href": "pr1/python/uppgifter/loopar/index.html",
    "title": "Uppgifter: Loopar",
    "section": "",
    "text": "Skapa ett program som beräknar och skriver ut “tolvans multiplikatikonstabell” rad för rad enligt nedan:\n\n\n\n\n\n\n\n\n 1 * 12 =  12\n 2 * 12 =  24\n 3 * 12 =  36\n 4 * 12 =  48\n 5 * 12 =  60\n 6 * 12 =  72\n 7 * 12 =  84\n 8 * 12 =  96\n 9 * 12 = 108\n10 * 12 = 120\n11 * 12 = 132\n12 * 12 = 144\n\n\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 1\n\n\n\n\n\nEtt program som inte gör någon snygg formatering av tabellen ser ut så här:\ni = 1\nwhile i &lt;= 12:\n   print(f\"{i} * 12 = {i * 12}\")\n   i += 1\nEtt program som ger en utmatning enligt uppgiften, dvs som ställer ental över ental och tiotal över tiotal, ser ut så här:\ni = 1\nwhile i &lt;= 12:\n   print(f\"{i:2.0f} * 12 = {(i * 12):3.0f}\")\n   i += 1\n\n\n\n\n\n\nI spelet lotto ska man tippa 7 olika nummer mellan  1 och 35. Skriv ett program som slumpar fram 7 heltal mellan 1 och 35 under en körning.\n\n\n\n\n\n\nTips\n\n\n\nFör att skapa ett slumptal i Python behövs importeras slumptalsbiblioteket. Detta görs överst i koden, varpå ett slumpmässigt heltal skapas enligt följande:\nimport random as rand\nslumptal = rand.randint(1, 100) # Skapar ett slumptal mellan, och inklusive, 1 och 100\n\n\nI nuläget får vi acceptera att det kan uppstå flera nummer av samma värde, t ex två st. sjuor. Detta kommer att kunna undvikas efter att vi gått igenom listor i Python; då kommer vi också att sortera numren i storleksordning.\nKörningsexempel:\n\n\n\n\n\n\n\n\nDin LOTTO-rad: 12 33 5 18 19 1 24 \n\n\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 2\n\n\n\n\n\nimport random as rand\ni = 1\nprint(\"Din LOTTO-rad:\", end=\" \")\nwhile i &lt;= 7:\n    print(rand.randint(1,35), end=\" \")\n    i += 1\nprint-satsen tar en s.k parameter, end, vilken gör att radslutet blir det eller de tecken som anges i den tilldelande strängen (i det här fallet ett mellanslag). Utelämnas end-satsen så skapas en ny rad.\n\n\n\n\n\n\nI stryktipset är det 13 matcher som ska tippas med 1, X eller 2. Skriv ett program som slumpar fram 13 st. 1, X och 2 under en körning.\nKörningsexempel:\n\n\n\n\n\n\n\n\n  Match nr.    Resultat\n==========================\n     1            1\n--------------------------\n     2            X\n--------------------------\n     3            2\n--------------------------\n     4            1\n--------------------------\n     5            2\n--------------------------\n     6            2\n--------------------------\n     7            1\n--------------------------\n     8            X\n--------------------------\n     9            1\n--------------------------\n    10            2\n--------------------------\n    11            1\n--------------------------\n    12            2\n--------------------------\n    13            1\n--------------------------\n\n\n\n\n\nTips: Formatera utskriften först efter att du vet hur du gör för att få slumpvis 1, X eller 2.\n\n\n\n\n\n\nLösningsförslag uppgift 3\n\n\n\n\n\nMetoden går ut på att skapa ett slumptal 1, 2 eller 3, för att sedan skriva ut 1, X eller 2 beroende på utfallet.\nimport random as rand\ni = 1\nprint(f\"{'Match nr':&gt;10}. {'Resultat':&gt;11}\")\nprint(\"==========================\")\nwhile i &lt;= 13:\n    res = rand.randint(1, 3)\n    if res == 1:\n        res = \"1\"\n    elif res == 2:\n        res = \"X\"\n    else:\n        res = \"2\"\n    print(f\"{i:6.0f} {res:&gt;12}\")\n    print(\"--------------------------\")\n    i += 1\n\n\n\n\n\n\nSkriv ett program där man ska gissa ett heltal mellan, och inklusive, 1 och 10. Gissningarna ska göras tills man gissar rätt. Efter en gissning ska programmet säga om det gissade talet var för stort eller för litet. När rätt tal gissats så ska det skriva ut hur många gissningar som behövdes.\nKörningsexempel:\n\n\n\n\n\n\nGissa ett heltal mellan 1 och 10 -&gt; 5\nTalet 5 är för stort.\nGissa ett heltal mellan 1 och 10 -&gt; 3\nTalet 3 är för stort.\nGissa ett heltal mellan 1 och 10 -&gt; 1\nTalet 1 är för litet.\nGissa ett heltal mellan 1 och 10 -&gt; 2\nRÄTT GISSAT!\n\nDu klarade spelet på gissning nr. 4.\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 4\n\n\n\n\n\nimport random as rand\n\nhemligt_tal = rand.randint(1, 10)\nantal_gissningar = 0\n\nwhile True:\n    gissning = int(input(\"Gissa ett tal mellan 1 och 10 -&gt;\"))\n    antal_gissningar += 1\n    if gissning &gt; hemligt_tal:\n        print(f\"Talet {gissning} är för stort.\")\n    elif gissning &lt; hemligt_tal:\n        print(f\"Talet {gissning} är för litet.\")\n    else:\n        print(\"RÄTT GISSAT!\")\n        break\nprint(f\"Du klarade spelet på gissning nr. {antal_gissningar}.\")\nMetoden är att gissningarna sker i en loop vars enda villkor är True (en “oändlig” loop). När spelaren har gissat rätt så avbryts loopen med break.\n\n\n\n\n\n\nSkriv ett program som beräknar och skriver ut alla heltalslösningar till ekvationen \\(2x+3y=120\\) i intervallet \\(-50 \\leq x,y \\leq 50\\). T ex gäller att \\(x=30\\) och \\(y=20\\) är en lösning.\nTips: Låt programmet testa olika värden på \\(x\\) och \\(y\\) i en nästlad loop.\n\n\n\n\n\n\nLösningsförslag uppgift 5\n\n\n\n\n\nObservera att det är viktigt att uppdatera variablerna x och y på rätt ställen i den nästlade loopen.\nx = -50\n\nwhile x &lt;= 50:\n    y = -50\n    while y &lt;= 50:\n        if 2*x + 3*y == 120:\n            print(f\"En lösning: (x, y) = ({x}, {y})\")\n        y += 1\n    x += 1\n\n\n\n\n\n\nFörsök att skapa följande figurer med hjälp av nästlade loopar:\n\n\n\n\n\n\n\n\nFigur A\n\n*  *  *  *  *  *  *  \n*  *  *  *  *  *  *  \n*  *  *  *  *  *  *  \n*  *  *  *  *  *  *  \n*  *  *  *  *  *  *  \n*  *  *  *  *  *  *  \n*  *  *  *  *  *  *  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigur B\n\n*  *  *  *  *  *  *  \n*     *     *     *  \n*  *  *  *  *  *  *  \n*     *     *     *  \n*  *  *  *  *  *  *  \n*     *     *     *  \n*  *  *  *  *  *  *  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigur C\n\n*     *     *     *  \n   *     *     *     \n*     *     *     *  \n   *     *     *     \n*     *     *     *  \n   *     *     *     \n*     *     *     *  \n\n\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 6\n\n\n\n\n\nFigur A, en yttre loop skriver ut raderna (x-koordinaterna) och en inre loop skriver ut kolumnerna (y-koordinaterna).\nprint(\"Figur A\\n\")\nmax_rows = 6\nmax_cols = max_rows\ncurrent_row = 0\nwhile current_row &lt;= max_rows:\n    current_col = 0\n    while current_col &lt;= max_cols:\n        print(\"*\", end=\" \")\n        current_col += 1\n    print()\n    current_row += 1\nprint()\nFigur B, om såväl rad- och kolumnnumret är udda så ska det inte skrivas ut en * (utan ett mellanslag istället).\nmax_rows = 6\nmax_cols = max_rows\ncurrent_row = 0\nwhile current_row &lt;= max_rows:\n    current_col = 0\n    while current_col &lt;= max_cols:\n        if current_col % 2 != 0 and current_row % 2 != 0:\n            print(\" \", end = \" \")\n        else:\n            print(\"*\", end=\" \")\n        current_col += 1\n    print()\n    current_row += 1\nprint()\nFigur C, här blir villkoren olika beroende på om radnumret är jämnt eller udda:\n\nOm både rad- och kolumnnumret är jämnt så ska en * skrivas ut\nOm radnumret är jämnt och kolumnnumret är udda så ska ett mellanslag skrivas ut\nOm både rad- och kolumnnummer är udda så ska en * skrivas ut\nOm radnumret är udda och kolumnnumret är jämnt så ska ett mellanslag skrivas ut\n\nmax_rows = 6\nmax_cols = max_rows\ncurrent_row = 0\nwhile current_row &lt;= max_rows:\n    current_col = 0\n    while current_col &lt;= max_cols:\n        if current_row % 2 == 0:\n            if current_col % 2 == 0:\n                print(\"*\", end = \" \")\n            else:\n                print(\" \", end=\" \")\n        elif current_row % 2 != 0:\n            if current_col % 2 != 0:\n                print(\"*\", end = \" \")\n            else:\n                print(\" \", end=\" \")\n        current_col += 1\n    print()\n    current_row += 1\n\n\n\n\n\n\nSkriv ett program som genom en meny ger en avatar tre egenskaper plus ett namn:\n\nNamn, ska kunna sättas till godtycklig sträng\nFärg, ska kunna väljas gul (g), blå (b) eller röd (r)\nStyrka, ska kunna väljas som ett heltal mellan 1 och 10\nPronomen, ska kunna väljas han, hon eller hen\nMenyn ska vara inmatningssäker, dvs om användaren anger ett otillåtet värde så ska denna inmatning (och enbart denna inmatning) göras om.\n\nExempelkörning:\n\n\n\n\n\n\nAnge avatarens namn -&gt; Efelia\nAnge färgen för Efelia: Gul (g), Blå (b) eller Röd (r) -&gt; s\nOtillåtet val! Ange färgen Gul (g), Blå (b) eller Röd (r) -&gt; r\nAnge styrka (heltal 1 - 10) -&gt; 7\nAnge tilltalspronomen (han/hon/hen) -&gt; hon\n\n# Datorn skriver ut\nDet här är Efelia, hon är en röd avatar med styrkan 7.\nSnabbheten beräknas till 3.\n\n\n\nSnabbheten är det som saknas upp till 10 från den angivna styrkan.\n\n\n\n\n\n\nTips\n\n\n\nⓘ Tips 1 – fritextval\nOm det finns flera olika giltiga alternativ och man önskar filtrera bort ogiltiga inmatningar bland dessa alternativ, kan Pythons in-operator användas. Om vi vill att användaren ska skriva in “ÄPPLE” eller “BANAN” som ett svar på en fråga så kan vi deklarera en variabel enligt följande:\nfrukter = {\"ÄPPLE\", \"BANAN\"}\nfrukt = input(\"Ange antingen ÄPPLE eller BANAN -&gt; \")\nif frukt in frukter:\n    print(\"Tack för ditt val!\")\nelse:\n    print(\"Ogiltigt val\")\nⓘ Tips 2 – versaler och gemener\nPython gör ju skillnad på versaler och gemener (“stora” och “små” bokstäver), det gör att en inmatning t ex “hon”, “Hon” eller “HON” kommer att tolkas på olika sätt. Det kan man sätta villkor för, men det kan bli många varianter att hantera. Ett vanligare sätt är att göra om inmatningen till versaler, och sedan göra jämförelsen mot versaler. Det görs med den s.k strängmetoden upper.\nEx:\n\nmy_str = \"abc\"\nmy_upper_str = my_str.upper()\nprint(my_upper_str)\n\nABC\n\n\nDå kan en jämförelse bli:\n\n# Testar om användaren matar in abc, oberoende av skiftläge\nif my_upper_str == \"ABC\":\n    print(\"Du matade in rätt bokstäver i rätt ordning!\")\n    # Det spelar ingen roll om användaren matade in abc, aBc\n    # eller någon annan kombination av skiftlägen.\n\nDu matade in rätt bokstäver i rätt ordning!\n\n\nDet finns även en strängmetod som heter lower (vilken skriver ut en sträng med gemener, “små bokstäver”). Den kan användas enligt my_lower_str = my_str.lower()\n\n\n\nⓘ Tips 3 – tal i strängar\nFör att testa om en inmatning är ett positivt heltal kan strängmetoden isdigit användas (minns att input alltid ger en sträng). Om strängen utgörs av ett heltal går det att konvertera till typen int. Men om strängen inte utgörs av ett heltal kommer ett försök till konvertering att krascha programmet. Därför ska konvertering ske först efter att programmet har försäkrat sig om att det är möjligt med en konvertering.\nEx:\n\n# Testar om en sträng utgörs av ett heltal, och konverterar det till i så fall\n# till heltalstyp varpå det multipliceras med 2.\nmy_str = \"123\" # Ett tal i en sträng\nif my_str.isdigit():\n    my_number = int(my_str)\n    print(2*my_number)\nelse:\n    print(\"Strängen var inte ett heltal, och aritmetiken blir nonsens!\")\n\n246\n\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 7\n\n\n\n\n\nDetta Python-program fungerar som en sorts meny där användaren måste göra giltiga val. Om valet är ogiltigt kommer användaren att komma tillbaka till samma läge för att välja om. Här ser vi exempel på “oändliga loopar” och hur programmet kan avgöra om ett alternativ bland flera är giltigt.\n# Detta program ger egenskaper till en avatar.\n# Egenskaperna sparas i variabler, vars värden\n# redovisas i slutet av programmet.\n# Varje egenskap har en egen inmatningsloop\n# som i sin tur hanterar angivna alternativ\n# som inte finns i menyn.\n\nnamn = input(\"Ange avatarens namn -&gt; \")\nwhile True:\n    färg = input(f\"Ange färgen för {namn}: Gul [g], Blå [b] eller Röd [r] -&gt; \")\n    if färg in {\"g\", \"b\", \"r\", \"G\", \"B\", \"R\"}:\n        # Nedanstående konstruktion med if-sats kan skrivas snyggare med\n        # en s.k uppslagstabell; vi kommer att gå igenom detta senare i kursen.\n        if färg in {\"g\", \"G\"}:\n            färg = \"gul\"\n        elif färg in {\"b\", \"B\"}:\n            färg = \"blå\"\n        else:\n            färg = \"röd\"\n        break\n    print(\"Felaktigt val\")\n\nwhile True:\n    styrka = input(\"Ange styrka (heltal 1 - 10) -&gt; \")\n    if styrka.isnumeric():\n        styrka = int(styrka)\n        if (1 &lt;= styrka &lt;= 10):\n            break\n    print(\"Felaktigt val\")\n\nwhile True:\n    pronomen = input(\"Ange tilltalspronomen (han/hon/hen) -&gt; \")\n    # Oavsett skiftläge kommer pronomet att göras om till\n    # gemener (\"små bokstäver\")\n    pronomen = pronomen.lower()\n    if pronomen in {\"han\", \"hon\", \"hen\"}:\n        break\n    print(\"Felaktigt val\")\n\nprint(f\"Det här är {namn}, {pronomen} är en {färg} avatar med styrkan {styrka}.\")\nprint(f\"Snabbheten beräknas till {10 - styrka}.\")\n\n\n\n\n\n\n\n\n\n\n\n\nSkapa program, med hjälp av en eller flera loopar, som ger följande respektive utskrift:\nFigur A\n\n\n* \n* * \n* * * \n* * * * \n* * * * * \n* * * * * * \n* * * * * * * \n* * * * * * * * \n\n\n\n\n\n\n\n\nLösningsförslag uppgift 8A\n\n\n\n\n\nfor i in range(1, 9):\n    print(i * \"*\")\n\n\n\n\n\n\n\n\n\nFigur B\n\n\n* * * * * * * * \n* * * * * * * \n* * * * * * \n* * * * * \n* * * * \n* * * \n* * \n* \n\n\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 8B\n\n\n\n\n\nfor i in range(8, 0, -1):\n    print(i * \"*\")\n\n\n\n\n\n\n\n\n\nFigur C\n\n\n\n* \n* * \n* * * \n* * * * \n* * * * * \n* * * * * * \n* * * * * * * \n* * * * * * * * \n* * * * * * * \n* * * * * * \n* * * * * \n* * * * \n* * * \n* * \n* \n\n\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 8C\n\n\n\n\n\nfor i in range(1, 8):\n    print(i * \"*\")\nfor i in range(8, 0, -1):\n    print(i * \"*\")\n\n\n\n\n\n\n\n\n\nFigur D\n\n\n\n              *               \n            * * *             \n          * * * * *           \n        * * * * * * *         \n      * * * * * * * * *       \n    * * * * * * * * * * *     \n  * * * * * * * * * * * * *   \n* * * * * * * * * * * * * * * \n  * * * * * * * * * * * * *   \n    * * * * * * * * * * *     \n      * * * * * * * * *       \n        * * * * * * *         \n          * * * * *           \n            * * *             \n              *               \n\n\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 8D\n\n\n\n\n\nHär måste dels rätt antal tecken tas i anspråk (15 st per rad), dels måste dessa tecken centreras och slutligen måste en formel hittas för att beräkna antalet stjärnor på nästföljande rad.\nfor i in range(1, 9):\n    print(f\"{(2*i-1) * '*':^15}\")\nfor i in range(7, 0, -1):\n    print(f\"{(2*i-1) * '*':^15}\")\n\n\n\n\n\n\nSkapa en tabell som gör om en temperatur given °F till motsvarande temperatur i °C. Tabellen ska vara stegad i tiogradersintervall, se exempel nedan. Formeln för konvertering mellan °C och °F är \\[\nC = \\frac{5}{9}F-\\frac{160}{9}\n\\]\n\n\n\n\n\n\n\n\nGrader F      Grader C\n=======================\n  -10          -23.3\n    0          -17.8\n   10          -12.2\n   20           -6.7\n   30           -1.1\n   40            4.4\n   50           10.0\n   60           15.6\n   70           21.1\n   80           26.7\n   90           32.2\n  100           37.8\n  110           43.3\n\n\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 9\n\n\n\n\n\nprint(\"Grader F\".ljust(13), end=\" \")\nprint(\"Grader C\")\nprint(\"=======================\")\n\nfor F in range(-10, 120, 10):\n    C = 5/9 * F - 160/9\n    print(f\"{F:5.0f}\", end=\" \")\n    print(f\"{C:14.1f}\")\n\n\n\n\n\n\nI uppgift 4 skapade du ett program som lät en spelare gissa ett tal från 1 t o m 10. Modifiera detta program så att det startar om efter att spelaren har lyckats lista ut talet. Programmet ska totalt köras tre gånger, och när den tredje omgången är över ska det avslutas med att skriva ut medelvärdet på antalet gissningar som behövdes avrundat till en decimal. Använd en for-loop som kontrollstruktur för omstarten av programmet.\nKörningsexempel:\n\n\n\n\n\n\nSPELOMGÅNG 1\n----------------\nGissa ett tal mellan 1 och 10 -&gt; 5\nTalet 5 är för litet.\nGissa ett tal mellan 1 och 10 -&gt; 7\nTalet 7 är för litet.\nGissa ett tal mellan 1 och 10 -&gt; 9\nTalet 9 är för litet.\nGissa ett tal mellan 1 och 10 -&gt; 10\nRÄTT GISSAT!\nDu klarade spelet på gissning nr. 4.\n\nSPELOMGÅNG 2\n----------------\nGissa ett tal mellan 1 och 10 -&gt; 5\nTalet 5 är för stort.\nGissa ett tal mellan 1 och 10 -&gt; 3\nTalet 3 är för litet.\nGissa ett tal mellan 1 och 10 -&gt; 4\nRÄTT GISSAT!\nDu klarade spelet på gissning nr. 3.\n\nSPELOMGÅNG 3\n----------------\nGissa ett tal mellan 1 och 10 -&gt; 5\nTalet 5 är för stort.\nGissa ett tal mellan 1 och 10 -&gt; 2\nTalet 2 är för stort.\nGissa ett tal mellan 1 och 10 -&gt; 1\nRÄTT GISSAT!\nDu klarade spelet på gissning nr. 3.\n\nMedelvärdet för antalet gissningar per tal: 3.3\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 10\n\n\n\n\n\nLösningen görs med en yttre for-loop (där vi känner till antalet varv från början) och en inre while-loop (där antalet varv beror på hur många gissningar som krävs).\nimport random as rand\ntotalt_antal_gissningar = 0\n\nfor i in range(1, 4):\n    print(f\"SPELOMGÅNG {i}\")\n    print(\"----------------\")\n    hemligt_tal = rand.randint(1, 10)\n    antal_gissningar = 0\n\n    while True:\n        gissning = int(input(\"Gissa ett tal mellan 1 och 10 -&gt; \"))\n        antal_gissningar += 1\n        if gissning &gt; hemligt_tal:\n            print(f\"Talet {gissning} är för stort.\")\n        elif gissning &lt; hemligt_tal:\n            print(f\"Talet {gissning} är för litet.\")\n        else:\n            print(\"RÄTT GISSAT!\")\n            break\n    print(f\"Du klarade spelet på gissning nr. {antal_gissningar}.\")\n    print()\n    totalt_antal_gissningar += antal_gissningar\nprint(f\"Medelvärdet för antalet gissningar per tal: {(totalt_antal_gissningar / 3):.1f}\")\n\n\n\n\n\n\n\nDessa uppgifter är tänkta för att på egen hand testa förståelsen för loopar, och ska kunna lösas enbart med information från presentationer och information kring tidigare uppgifter. —\n\n\nSkriv ett program som simulerar hundra tärningskast med en sexsidig tärning. Innan programmet avslutas ska det på lämpligt sätt skriva ut antalet utfall av respektive sort (dvs antalet ettor, antalet tvåor osv) samt medelvärdet med en decimals noggrannhet.\nKanske går det också att vara kreativ och grafiskt visa antalet utfall av respektive sort som ett liggande stapeldiagram, där staplarna utgörs av ett antal stjärnor (*).\nSe tipset till Uppgift 2 ovan för att skapa slumpvisa heltal i ett intervall.\n\n\n\nI en lek som kan användas när man lär sig division sitter deltagarna i en ring. Den första personen i ringen säger “Ett” och den andra “Två”. När en person ska säga ett tal som är jämnt delbart med tre, så säger den “Fizz”. Den tredje personen säger alltså “Fizz” istället för tre, eftersom tre är jämnt delbart med tre, detsamma gäller den person som skulle säga “Sex” och “Nio” osv. När en person ska säga ett tal som är jämnt delbart med fem så ska den istället säga “Buzz”. När talet femton ska uttalas så ska den personen som står på tur säga “FizzBuzz”, eftersom femton är jämnt delbart med både tre och fem. I ringleken så åker personer som säger fel ut, och spelet går vidare med en mindre ring.\nSkriv ett program som gör en uppräkning av heltal från 1 till 100, och på lämpligt sätt skriver ut talen (när de ska skrivas ut), Fizz (istället för tal som är jämnt delbara med tre), Buzz (istället för tal som är jämnt delbara med fem) och FizzBuzz (istället för tal som är jämnt delbara med såväl tre som fem).\nFörsök att skriva två varianter på lösning:\n\nEn som innehåller booleska operatorer i villkoren\nEn som inte innehåller booleska operatorer i villkoren\n\nSe lösningsförslag till uppgift 11 på sidan Utskrifter och villkor för att få en idé om uppbyggnaden.",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: Loopar"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/loopar/index.html#i-uppgift-1-7-ska-du-använda-while-loopar-i-din-lösning.",
    "href": "pr1/python/uppgifter/loopar/index.html#i-uppgift-1-7-ska-du-använda-while-loopar-i-din-lösning.",
    "title": "Uppgifter: Loopar",
    "section": "",
    "text": "Skapa ett program som beräknar och skriver ut “tolvans multiplikatikonstabell” rad för rad enligt nedan:\n\n\n\n\n\n\n\n\n 1 * 12 =  12\n 2 * 12 =  24\n 3 * 12 =  36\n 4 * 12 =  48\n 5 * 12 =  60\n 6 * 12 =  72\n 7 * 12 =  84\n 8 * 12 =  96\n 9 * 12 = 108\n10 * 12 = 120\n11 * 12 = 132\n12 * 12 = 144\n\n\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 1\n\n\n\n\n\nEtt program som inte gör någon snygg formatering av tabellen ser ut så här:\ni = 1\nwhile i &lt;= 12:\n   print(f\"{i} * 12 = {i * 12}\")\n   i += 1\nEtt program som ger en utmatning enligt uppgiften, dvs som ställer ental över ental och tiotal över tiotal, ser ut så här:\ni = 1\nwhile i &lt;= 12:\n   print(f\"{i:2.0f} * 12 = {(i * 12):3.0f}\")\n   i += 1\n\n\n\n\n\n\nI spelet lotto ska man tippa 7 olika nummer mellan  1 och 35. Skriv ett program som slumpar fram 7 heltal mellan 1 och 35 under en körning.\n\n\n\n\n\n\nTips\n\n\n\nFör att skapa ett slumptal i Python behövs importeras slumptalsbiblioteket. Detta görs överst i koden, varpå ett slumpmässigt heltal skapas enligt följande:\nimport random as rand\nslumptal = rand.randint(1, 100) # Skapar ett slumptal mellan, och inklusive, 1 och 100\n\n\nI nuläget får vi acceptera att det kan uppstå flera nummer av samma värde, t ex två st. sjuor. Detta kommer att kunna undvikas efter att vi gått igenom listor i Python; då kommer vi också att sortera numren i storleksordning.\nKörningsexempel:\n\n\n\n\n\n\n\n\nDin LOTTO-rad: 12 33 5 18 19 1 24 \n\n\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 2\n\n\n\n\n\nimport random as rand\ni = 1\nprint(\"Din LOTTO-rad:\", end=\" \")\nwhile i &lt;= 7:\n    print(rand.randint(1,35), end=\" \")\n    i += 1\nprint-satsen tar en s.k parameter, end, vilken gör att radslutet blir det eller de tecken som anges i den tilldelande strängen (i det här fallet ett mellanslag). Utelämnas end-satsen så skapas en ny rad.\n\n\n\n\n\n\nI stryktipset är det 13 matcher som ska tippas med 1, X eller 2. Skriv ett program som slumpar fram 13 st. 1, X och 2 under en körning.\nKörningsexempel:\n\n\n\n\n\n\n\n\n  Match nr.    Resultat\n==========================\n     1            1\n--------------------------\n     2            X\n--------------------------\n     3            2\n--------------------------\n     4            1\n--------------------------\n     5            2\n--------------------------\n     6            2\n--------------------------\n     7            1\n--------------------------\n     8            X\n--------------------------\n     9            1\n--------------------------\n    10            2\n--------------------------\n    11            1\n--------------------------\n    12            2\n--------------------------\n    13            1\n--------------------------\n\n\n\n\n\nTips: Formatera utskriften först efter att du vet hur du gör för att få slumpvis 1, X eller 2.\n\n\n\n\n\n\nLösningsförslag uppgift 3\n\n\n\n\n\nMetoden går ut på att skapa ett slumptal 1, 2 eller 3, för att sedan skriva ut 1, X eller 2 beroende på utfallet.\nimport random as rand\ni = 1\nprint(f\"{'Match nr':&gt;10}. {'Resultat':&gt;11}\")\nprint(\"==========================\")\nwhile i &lt;= 13:\n    res = rand.randint(1, 3)\n    if res == 1:\n        res = \"1\"\n    elif res == 2:\n        res = \"X\"\n    else:\n        res = \"2\"\n    print(f\"{i:6.0f} {res:&gt;12}\")\n    print(\"--------------------------\")\n    i += 1\n\n\n\n\n\n\nSkriv ett program där man ska gissa ett heltal mellan, och inklusive, 1 och 10. Gissningarna ska göras tills man gissar rätt. Efter en gissning ska programmet säga om det gissade talet var för stort eller för litet. När rätt tal gissats så ska det skriva ut hur många gissningar som behövdes.\nKörningsexempel:\n\n\n\n\n\n\nGissa ett heltal mellan 1 och 10 -&gt; 5\nTalet 5 är för stort.\nGissa ett heltal mellan 1 och 10 -&gt; 3\nTalet 3 är för stort.\nGissa ett heltal mellan 1 och 10 -&gt; 1\nTalet 1 är för litet.\nGissa ett heltal mellan 1 och 10 -&gt; 2\nRÄTT GISSAT!\n\nDu klarade spelet på gissning nr. 4.\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 4\n\n\n\n\n\nimport random as rand\n\nhemligt_tal = rand.randint(1, 10)\nantal_gissningar = 0\n\nwhile True:\n    gissning = int(input(\"Gissa ett tal mellan 1 och 10 -&gt;\"))\n    antal_gissningar += 1\n    if gissning &gt; hemligt_tal:\n        print(f\"Talet {gissning} är för stort.\")\n    elif gissning &lt; hemligt_tal:\n        print(f\"Talet {gissning} är för litet.\")\n    else:\n        print(\"RÄTT GISSAT!\")\n        break\nprint(f\"Du klarade spelet på gissning nr. {antal_gissningar}.\")\nMetoden är att gissningarna sker i en loop vars enda villkor är True (en “oändlig” loop). När spelaren har gissat rätt så avbryts loopen med break.\n\n\n\n\n\n\nSkriv ett program som beräknar och skriver ut alla heltalslösningar till ekvationen \\(2x+3y=120\\) i intervallet \\(-50 \\leq x,y \\leq 50\\). T ex gäller att \\(x=30\\) och \\(y=20\\) är en lösning.\nTips: Låt programmet testa olika värden på \\(x\\) och \\(y\\) i en nästlad loop.\n\n\n\n\n\n\nLösningsförslag uppgift 5\n\n\n\n\n\nObservera att det är viktigt att uppdatera variablerna x och y på rätt ställen i den nästlade loopen.\nx = -50\n\nwhile x &lt;= 50:\n    y = -50\n    while y &lt;= 50:\n        if 2*x + 3*y == 120:\n            print(f\"En lösning: (x, y) = ({x}, {y})\")\n        y += 1\n    x += 1\n\n\n\n\n\n\nFörsök att skapa följande figurer med hjälp av nästlade loopar:\n\n\n\n\n\n\n\n\nFigur A\n\n*  *  *  *  *  *  *  \n*  *  *  *  *  *  *  \n*  *  *  *  *  *  *  \n*  *  *  *  *  *  *  \n*  *  *  *  *  *  *  \n*  *  *  *  *  *  *  \n*  *  *  *  *  *  *  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigur B\n\n*  *  *  *  *  *  *  \n*     *     *     *  \n*  *  *  *  *  *  *  \n*     *     *     *  \n*  *  *  *  *  *  *  \n*     *     *     *  \n*  *  *  *  *  *  *  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigur C\n\n*     *     *     *  \n   *     *     *     \n*     *     *     *  \n   *     *     *     \n*     *     *     *  \n   *     *     *     \n*     *     *     *  \n\n\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 6\n\n\n\n\n\nFigur A, en yttre loop skriver ut raderna (x-koordinaterna) och en inre loop skriver ut kolumnerna (y-koordinaterna).\nprint(\"Figur A\\n\")\nmax_rows = 6\nmax_cols = max_rows\ncurrent_row = 0\nwhile current_row &lt;= max_rows:\n    current_col = 0\n    while current_col &lt;= max_cols:\n        print(\"*\", end=\" \")\n        current_col += 1\n    print()\n    current_row += 1\nprint()\nFigur B, om såväl rad- och kolumnnumret är udda så ska det inte skrivas ut en * (utan ett mellanslag istället).\nmax_rows = 6\nmax_cols = max_rows\ncurrent_row = 0\nwhile current_row &lt;= max_rows:\n    current_col = 0\n    while current_col &lt;= max_cols:\n        if current_col % 2 != 0 and current_row % 2 != 0:\n            print(\" \", end = \" \")\n        else:\n            print(\"*\", end=\" \")\n        current_col += 1\n    print()\n    current_row += 1\nprint()\nFigur C, här blir villkoren olika beroende på om radnumret är jämnt eller udda:\n\nOm både rad- och kolumnnumret är jämnt så ska en * skrivas ut\nOm radnumret är jämnt och kolumnnumret är udda så ska ett mellanslag skrivas ut\nOm både rad- och kolumnnummer är udda så ska en * skrivas ut\nOm radnumret är udda och kolumnnumret är jämnt så ska ett mellanslag skrivas ut\n\nmax_rows = 6\nmax_cols = max_rows\ncurrent_row = 0\nwhile current_row &lt;= max_rows:\n    current_col = 0\n    while current_col &lt;= max_cols:\n        if current_row % 2 == 0:\n            if current_col % 2 == 0:\n                print(\"*\", end = \" \")\n            else:\n                print(\" \", end=\" \")\n        elif current_row % 2 != 0:\n            if current_col % 2 != 0:\n                print(\"*\", end = \" \")\n            else:\n                print(\" \", end=\" \")\n        current_col += 1\n    print()\n    current_row += 1\n\n\n\n\n\n\nSkriv ett program som genom en meny ger en avatar tre egenskaper plus ett namn:\n\nNamn, ska kunna sättas till godtycklig sträng\nFärg, ska kunna väljas gul (g), blå (b) eller röd (r)\nStyrka, ska kunna väljas som ett heltal mellan 1 och 10\nPronomen, ska kunna väljas han, hon eller hen\nMenyn ska vara inmatningssäker, dvs om användaren anger ett otillåtet värde så ska denna inmatning (och enbart denna inmatning) göras om.\n\nExempelkörning:\n\n\n\n\n\n\nAnge avatarens namn -&gt; Efelia\nAnge färgen för Efelia: Gul (g), Blå (b) eller Röd (r) -&gt; s\nOtillåtet val! Ange färgen Gul (g), Blå (b) eller Röd (r) -&gt; r\nAnge styrka (heltal 1 - 10) -&gt; 7\nAnge tilltalspronomen (han/hon/hen) -&gt; hon\n\n# Datorn skriver ut\nDet här är Efelia, hon är en röd avatar med styrkan 7.\nSnabbheten beräknas till 3.\n\n\n\nSnabbheten är det som saknas upp till 10 från den angivna styrkan.\n\n\n\n\n\n\nTips\n\n\n\nⓘ Tips 1 – fritextval\nOm det finns flera olika giltiga alternativ och man önskar filtrera bort ogiltiga inmatningar bland dessa alternativ, kan Pythons in-operator användas. Om vi vill att användaren ska skriva in “ÄPPLE” eller “BANAN” som ett svar på en fråga så kan vi deklarera en variabel enligt följande:\nfrukter = {\"ÄPPLE\", \"BANAN\"}\nfrukt = input(\"Ange antingen ÄPPLE eller BANAN -&gt; \")\nif frukt in frukter:\n    print(\"Tack för ditt val!\")\nelse:\n    print(\"Ogiltigt val\")\nⓘ Tips 2 – versaler och gemener\nPython gör ju skillnad på versaler och gemener (“stora” och “små” bokstäver), det gör att en inmatning t ex “hon”, “Hon” eller “HON” kommer att tolkas på olika sätt. Det kan man sätta villkor för, men det kan bli många varianter att hantera. Ett vanligare sätt är att göra om inmatningen till versaler, och sedan göra jämförelsen mot versaler. Det görs med den s.k strängmetoden upper.\nEx:\n\nmy_str = \"abc\"\nmy_upper_str = my_str.upper()\nprint(my_upper_str)\n\nABC\n\n\nDå kan en jämförelse bli:\n\n# Testar om användaren matar in abc, oberoende av skiftläge\nif my_upper_str == \"ABC\":\n    print(\"Du matade in rätt bokstäver i rätt ordning!\")\n    # Det spelar ingen roll om användaren matade in abc, aBc\n    # eller någon annan kombination av skiftlägen.\n\nDu matade in rätt bokstäver i rätt ordning!\n\n\nDet finns även en strängmetod som heter lower (vilken skriver ut en sträng med gemener, “små bokstäver”). Den kan användas enligt my_lower_str = my_str.lower()\n\n\n\nⓘ Tips 3 – tal i strängar\nFör att testa om en inmatning är ett positivt heltal kan strängmetoden isdigit användas (minns att input alltid ger en sträng). Om strängen utgörs av ett heltal går det att konvertera till typen int. Men om strängen inte utgörs av ett heltal kommer ett försök till konvertering att krascha programmet. Därför ska konvertering ske först efter att programmet har försäkrat sig om att det är möjligt med en konvertering.\nEx:\n\n# Testar om en sträng utgörs av ett heltal, och konverterar det till i så fall\n# till heltalstyp varpå det multipliceras med 2.\nmy_str = \"123\" # Ett tal i en sträng\nif my_str.isdigit():\n    my_number = int(my_str)\n    print(2*my_number)\nelse:\n    print(\"Strängen var inte ett heltal, och aritmetiken blir nonsens!\")\n\n246\n\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 7\n\n\n\n\n\nDetta Python-program fungerar som en sorts meny där användaren måste göra giltiga val. Om valet är ogiltigt kommer användaren att komma tillbaka till samma läge för att välja om. Här ser vi exempel på “oändliga loopar” och hur programmet kan avgöra om ett alternativ bland flera är giltigt.\n# Detta program ger egenskaper till en avatar.\n# Egenskaperna sparas i variabler, vars värden\n# redovisas i slutet av programmet.\n# Varje egenskap har en egen inmatningsloop\n# som i sin tur hanterar angivna alternativ\n# som inte finns i menyn.\n\nnamn = input(\"Ange avatarens namn -&gt; \")\nwhile True:\n    färg = input(f\"Ange färgen för {namn}: Gul [g], Blå [b] eller Röd [r] -&gt; \")\n    if färg in {\"g\", \"b\", \"r\", \"G\", \"B\", \"R\"}:\n        # Nedanstående konstruktion med if-sats kan skrivas snyggare med\n        # en s.k uppslagstabell; vi kommer att gå igenom detta senare i kursen.\n        if färg in {\"g\", \"G\"}:\n            färg = \"gul\"\n        elif färg in {\"b\", \"B\"}:\n            färg = \"blå\"\n        else:\n            färg = \"röd\"\n        break\n    print(\"Felaktigt val\")\n\nwhile True:\n    styrka = input(\"Ange styrka (heltal 1 - 10) -&gt; \")\n    if styrka.isnumeric():\n        styrka = int(styrka)\n        if (1 &lt;= styrka &lt;= 10):\n            break\n    print(\"Felaktigt val\")\n\nwhile True:\n    pronomen = input(\"Ange tilltalspronomen (han/hon/hen) -&gt; \")\n    # Oavsett skiftläge kommer pronomet att göras om till\n    # gemener (\"små bokstäver\")\n    pronomen = pronomen.lower()\n    if pronomen in {\"han\", \"hon\", \"hen\"}:\n        break\n    print(\"Felaktigt val\")\n\nprint(f\"Det här är {namn}, {pronomen} är en {färg} avatar med styrkan {styrka}.\")\nprint(f\"Snabbheten beräknas till {10 - styrka}.\")",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: Loopar"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/loopar/index.html#i-uppgift-8-10-ska-du-använda-for-loopar-i-din-lösning.",
    "href": "pr1/python/uppgifter/loopar/index.html#i-uppgift-8-10-ska-du-använda-for-loopar-i-din-lösning.",
    "title": "Uppgifter: Loopar",
    "section": "",
    "text": "Skapa program, med hjälp av en eller flera loopar, som ger följande respektive utskrift:\nFigur A\n\n\n* \n* * \n* * * \n* * * * \n* * * * * \n* * * * * * \n* * * * * * * \n* * * * * * * * \n\n\n\n\n\n\n\n\nLösningsförslag uppgift 8A\n\n\n\n\n\nfor i in range(1, 9):\n    print(i * \"*\")\n\n\n\n\n\n\n\n\n\nFigur B\n\n\n* * * * * * * * \n* * * * * * * \n* * * * * * \n* * * * * \n* * * * \n* * * \n* * \n* \n\n\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 8B\n\n\n\n\n\nfor i in range(8, 0, -1):\n    print(i * \"*\")\n\n\n\n\n\n\n\n\n\nFigur C\n\n\n\n* \n* * \n* * * \n* * * * \n* * * * * \n* * * * * * \n* * * * * * * \n* * * * * * * * \n* * * * * * * \n* * * * * * \n* * * * * \n* * * * \n* * * \n* * \n* \n\n\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 8C\n\n\n\n\n\nfor i in range(1, 8):\n    print(i * \"*\")\nfor i in range(8, 0, -1):\n    print(i * \"*\")\n\n\n\n\n\n\n\n\n\nFigur D\n\n\n\n              *               \n            * * *             \n          * * * * *           \n        * * * * * * *         \n      * * * * * * * * *       \n    * * * * * * * * * * *     \n  * * * * * * * * * * * * *   \n* * * * * * * * * * * * * * * \n  * * * * * * * * * * * * *   \n    * * * * * * * * * * *     \n      * * * * * * * * *       \n        * * * * * * *         \n          * * * * *           \n            * * *             \n              *               \n\n\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 8D\n\n\n\n\n\nHär måste dels rätt antal tecken tas i anspråk (15 st per rad), dels måste dessa tecken centreras och slutligen måste en formel hittas för att beräkna antalet stjärnor på nästföljande rad.\nfor i in range(1, 9):\n    print(f\"{(2*i-1) * '*':^15}\")\nfor i in range(7, 0, -1):\n    print(f\"{(2*i-1) * '*':^15}\")\n\n\n\n\n\n\nSkapa en tabell som gör om en temperatur given °F till motsvarande temperatur i °C. Tabellen ska vara stegad i tiogradersintervall, se exempel nedan. Formeln för konvertering mellan °C och °F är \\[\nC = \\frac{5}{9}F-\\frac{160}{9}\n\\]\n\n\n\n\n\n\n\n\nGrader F      Grader C\n=======================\n  -10          -23.3\n    0          -17.8\n   10          -12.2\n   20           -6.7\n   30           -1.1\n   40            4.4\n   50           10.0\n   60           15.6\n   70           21.1\n   80           26.7\n   90           32.2\n  100           37.8\n  110           43.3\n\n\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 9\n\n\n\n\n\nprint(\"Grader F\".ljust(13), end=\" \")\nprint(\"Grader C\")\nprint(\"=======================\")\n\nfor F in range(-10, 120, 10):\n    C = 5/9 * F - 160/9\n    print(f\"{F:5.0f}\", end=\" \")\n    print(f\"{C:14.1f}\")\n\n\n\n\n\n\nI uppgift 4 skapade du ett program som lät en spelare gissa ett tal från 1 t o m 10. Modifiera detta program så att det startar om efter att spelaren har lyckats lista ut talet. Programmet ska totalt köras tre gånger, och när den tredje omgången är över ska det avslutas med att skriva ut medelvärdet på antalet gissningar som behövdes avrundat till en decimal. Använd en for-loop som kontrollstruktur för omstarten av programmet.\nKörningsexempel:\n\n\n\n\n\n\nSPELOMGÅNG 1\n----------------\nGissa ett tal mellan 1 och 10 -&gt; 5\nTalet 5 är för litet.\nGissa ett tal mellan 1 och 10 -&gt; 7\nTalet 7 är för litet.\nGissa ett tal mellan 1 och 10 -&gt; 9\nTalet 9 är för litet.\nGissa ett tal mellan 1 och 10 -&gt; 10\nRÄTT GISSAT!\nDu klarade spelet på gissning nr. 4.\n\nSPELOMGÅNG 2\n----------------\nGissa ett tal mellan 1 och 10 -&gt; 5\nTalet 5 är för stort.\nGissa ett tal mellan 1 och 10 -&gt; 3\nTalet 3 är för litet.\nGissa ett tal mellan 1 och 10 -&gt; 4\nRÄTT GISSAT!\nDu klarade spelet på gissning nr. 3.\n\nSPELOMGÅNG 3\n----------------\nGissa ett tal mellan 1 och 10 -&gt; 5\nTalet 5 är för stort.\nGissa ett tal mellan 1 och 10 -&gt; 2\nTalet 2 är för stort.\nGissa ett tal mellan 1 och 10 -&gt; 1\nRÄTT GISSAT!\nDu klarade spelet på gissning nr. 3.\n\nMedelvärdet för antalet gissningar per tal: 3.3\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 10\n\n\n\n\n\nLösningen görs med en yttre for-loop (där vi känner till antalet varv från början) och en inre while-loop (där antalet varv beror på hur många gissningar som krävs).\nimport random as rand\ntotalt_antal_gissningar = 0\n\nfor i in range(1, 4):\n    print(f\"SPELOMGÅNG {i}\")\n    print(\"----------------\")\n    hemligt_tal = rand.randint(1, 10)\n    antal_gissningar = 0\n\n    while True:\n        gissning = int(input(\"Gissa ett tal mellan 1 och 10 -&gt; \"))\n        antal_gissningar += 1\n        if gissning &gt; hemligt_tal:\n            print(f\"Talet {gissning} är för stort.\")\n        elif gissning &lt; hemligt_tal:\n            print(f\"Talet {gissning} är för litet.\")\n        else:\n            print(\"RÄTT GISSAT!\")\n            break\n    print(f\"Du klarade spelet på gissning nr. {antal_gissningar}.\")\n    print()\n    totalt_antal_gissningar += antal_gissningar\nprint(f\"Medelvärdet för antalet gissningar per tal: {(totalt_antal_gissningar / 3):.1f}\")",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: Loopar"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/loopar/index.html#uppgifter-utan-lösningsförslag",
    "href": "pr1/python/uppgifter/loopar/index.html#uppgifter-utan-lösningsförslag",
    "title": "Uppgifter: Loopar",
    "section": "",
    "text": "Dessa uppgifter är tänkta för att på egen hand testa förståelsen för loopar, och ska kunna lösas enbart med information från presentationer och information kring tidigare uppgifter. —\n\n\nSkriv ett program som simulerar hundra tärningskast med en sexsidig tärning. Innan programmet avslutas ska det på lämpligt sätt skriva ut antalet utfall av respektive sort (dvs antalet ettor, antalet tvåor osv) samt medelvärdet med en decimals noggrannhet.\nKanske går det också att vara kreativ och grafiskt visa antalet utfall av respektive sort som ett liggande stapeldiagram, där staplarna utgörs av ett antal stjärnor (*).\nSe tipset till Uppgift 2 ovan för att skapa slumpvisa heltal i ett intervall.\n\n\n\nI en lek som kan användas när man lär sig division sitter deltagarna i en ring. Den första personen i ringen säger “Ett” och den andra “Två”. När en person ska säga ett tal som är jämnt delbart med tre, så säger den “Fizz”. Den tredje personen säger alltså “Fizz” istället för tre, eftersom tre är jämnt delbart med tre, detsamma gäller den person som skulle säga “Sex” och “Nio” osv. När en person ska säga ett tal som är jämnt delbart med fem så ska den istället säga “Buzz”. När talet femton ska uttalas så ska den personen som står på tur säga “FizzBuzz”, eftersom femton är jämnt delbart med både tre och fem. I ringleken så åker personer som säger fel ut, och spelet går vidare med en mindre ring.\nSkriv ett program som gör en uppräkning av heltal från 1 till 100, och på lämpligt sätt skriver ut talen (när de ska skrivas ut), Fizz (istället för tal som är jämnt delbara med tre), Buzz (istället för tal som är jämnt delbara med fem) och FizzBuzz (istället för tal som är jämnt delbara med såväl tre som fem).\nFörsök att skriva två varianter på lösning:\n\nEn som innehåller booleska operatorer i villkoren\nEn som inte innehåller booleska operatorer i villkoren\n\nSe lösningsförslag till uppgift 11 på sidan Utskrifter och villkor för att få en idé om uppbyggnaden.",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: Loopar"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/egna-datatyper/index.html",
    "href": "pr1/python/uppgifter/egna-datatyper/index.html",
    "title": "Uppgifter: Egna datatyper",
    "section": "",
    "text": "Deklarera en datatyp Avatar. Datatypen ska ha attributen namn, färg, ålder, styrka och snabbhet.\n\n\n\n\n\n\nLösningsförslag uppgift 1\n\n\n\n\n\n\nclass Avatar:\n    namn = \"\"\n    färg = \"\"\n    ålder = 0\n    styrka = 0\n    snabbhet = 0\n\n\n\n\n\n\n\nDeklarera två instanser av Avatar från uppgift 1, nämligen player_1 och player_2. Här ska alla attribut på respektive avatar, utom snabbhet sättas till lämpliga värden (styrka kan variera mellan 0 och 10).\nBekräfta med utskrifter att attributen blivit korrekt satta.\nKörningsexempel:\n\n\n\n\n\n\n\n\nPresentation av player_1\n========================\nNamn: Efelia\nFärg: Gul\nÅlder: 120\nStyrka: 6\n\nPresentation av player_2\n========================\nNamn: Castor\nFärg: Blå\nÅlder: 430\nStyrka: 3\n\n\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 2\n\n\n\n\n\nplayer_1 = Avatar()\nplayer_2 = Avatar()\n\nplayer_1.namn = \"Efelia\"\nplayer_1.färg = \"Gul\"\nplayer_1.ålder = 120\nplayer_1.styrka = 6\n\nplayer_2.namn = \"Castor\"\nplayer_2.färg = \"Blå\"\nplayer_2.ålder = 430\nplayer_2.styrka = 3\n\nprint(\"Presentation av player_1\")\nprint(\"========================\")\nprint(f\"Namn: {player_1.namn}\")\nprint(f\"Färg: {player_1.färg}\")\nprint(f\"Ålder: {player_1.ålder}\")\nprint(f\"Styrka: {player_1.styrka}\")\nprint()\nprint(\"Presentation av player_2\")\nprint(\"========================\")\nprint(f\"Namn: {player_2.namn}\")\nprint(f\"Färg: {player_2.färg}\")\nprint(f\"Ålder: {player_2.ålder}\")\nprint(f\"Styrka: {player_2.styrka}\")\n\n\n\n\n\n\nSkapa funktionen beräkna_snabbhet som ska ta emot ett objekt av typen Avatar. Funktionens uppgift är att beräkna och sätta ett värde på attributet snabbhet hos den aktuella avataren. Snabbheten ska beräknas enligt formeln \\(10-\\text{styrka}\\).\nEfter anropet till funktionen ska huvudprogrammet skriva ut styrkan och snabbheten respektive avatar.\nKörningsexempel\n\n\n\n\n\n\n\n\nEfelia har styrkan 6 snabbheten 4\nCastor har styrkan 3 snabbheten 7\n\n\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 3\n\n\n\n\n\ndef beräkna_snabbhet(avatar):\n    avatar.snabbhet = 10 - avatar.styrka\n\nberäkna_snabbhet(player_1)\nberäkna_snabbhet(player_2)\n\nprint(f\"{player_1.namn} har styrkan {player_1.styrka} snabbheten {player_1.snabbhet}\")\nprint(f\"{player_2.namn} har styrkan {player_2.styrka} snabbheten {player_2.snabbhet}\")\n\n\n\n\n\n\n\n\n\nDeklarera en datatyp Bil i Python. Denna datatyp ska innehålla attributen märke, årsmodell, färg, pris och miltal. Skapa minst tio olika instanser av denna datatyp (de kan heta a_bil, b_bil, c_bil osv). Dessa instanser ska läggas in i en lista, denna lista kan heta bilar. För sammanhangets skull kan vi tänka oss att det är en bilhandlare av begagnade bilar som har listan över bilar som är till salu.\n\nSkriv en funktion som tar emot en sådan lista med bilar som parameter och skriver ut all information om respektive bil på ett strukturerat sätt.\nSkriv tre funktioner, välj_märke, välj_pris och välj_max_miltal som skriver ut information om de bilar som uppfyller ett krav (t ex alla Volvo-bilar i listan eller alla bilar som gått max \\(3\\,000\\) mil). Funktionerna måste förstås ta emot lämpliga parametrar och hantera dessa.\nLägg till en meny i programmet där en användare får ange önskemål om vilka bilar som ska skrivas ut.\nSkriv en funktion som sorterar utskriften med avseende på ett valt attribut. Det kan vara att bilarna skrivs ut sorterat efter hur många mil som de gått (den med lägst miltal först och den med högst miltal sist), efter färg, efter pris eller efter märke. Här är en mall till hur en sådan sortering kan gå till:\n\n# Antag att du har en lista med objekt där varje objekt har ett attribut 'attribut'\ndin_lista = [...]\n# Sortera listan baserat på 'attribut'\ndin_lista.sort(key=lambda x: x.attribut)\n\nUtöka programmet med funktionalitet för att söka på bilar efter specifika önskemål baserat på två av ovanstående attribut. T ex alla Volvobilar med ett maximalt miltal eller alla bilar som gått under ett visst antal mil med ett visst maximalt pris.",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: Egna datatyper"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/egna-datatyper/index.html#uppgifter-med-lösningsförslag",
    "href": "pr1/python/uppgifter/egna-datatyper/index.html#uppgifter-med-lösningsförslag",
    "title": "Uppgifter: Egna datatyper",
    "section": "",
    "text": "Deklarera en datatyp Avatar. Datatypen ska ha attributen namn, färg, ålder, styrka och snabbhet.\n\n\n\n\n\n\nLösningsförslag uppgift 1\n\n\n\n\n\n\nclass Avatar:\n    namn = \"\"\n    färg = \"\"\n    ålder = 0\n    styrka = 0\n    snabbhet = 0\n\n\n\n\n\n\n\nDeklarera två instanser av Avatar från uppgift 1, nämligen player_1 och player_2. Här ska alla attribut på respektive avatar, utom snabbhet sättas till lämpliga värden (styrka kan variera mellan 0 och 10).\nBekräfta med utskrifter att attributen blivit korrekt satta.\nKörningsexempel:\n\n\n\n\n\n\n\n\nPresentation av player_1\n========================\nNamn: Efelia\nFärg: Gul\nÅlder: 120\nStyrka: 6\n\nPresentation av player_2\n========================\nNamn: Castor\nFärg: Blå\nÅlder: 430\nStyrka: 3\n\n\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 2\n\n\n\n\n\nplayer_1 = Avatar()\nplayer_2 = Avatar()\n\nplayer_1.namn = \"Efelia\"\nplayer_1.färg = \"Gul\"\nplayer_1.ålder = 120\nplayer_1.styrka = 6\n\nplayer_2.namn = \"Castor\"\nplayer_2.färg = \"Blå\"\nplayer_2.ålder = 430\nplayer_2.styrka = 3\n\nprint(\"Presentation av player_1\")\nprint(\"========================\")\nprint(f\"Namn: {player_1.namn}\")\nprint(f\"Färg: {player_1.färg}\")\nprint(f\"Ålder: {player_1.ålder}\")\nprint(f\"Styrka: {player_1.styrka}\")\nprint()\nprint(\"Presentation av player_2\")\nprint(\"========================\")\nprint(f\"Namn: {player_2.namn}\")\nprint(f\"Färg: {player_2.färg}\")\nprint(f\"Ålder: {player_2.ålder}\")\nprint(f\"Styrka: {player_2.styrka}\")\n\n\n\n\n\n\nSkapa funktionen beräkna_snabbhet som ska ta emot ett objekt av typen Avatar. Funktionens uppgift är att beräkna och sätta ett värde på attributet snabbhet hos den aktuella avataren. Snabbheten ska beräknas enligt formeln \\(10-\\text{styrka}\\).\nEfter anropet till funktionen ska huvudprogrammet skriva ut styrkan och snabbheten respektive avatar.\nKörningsexempel\n\n\n\n\n\n\n\n\nEfelia har styrkan 6 snabbheten 4\nCastor har styrkan 3 snabbheten 7\n\n\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 3\n\n\n\n\n\ndef beräkna_snabbhet(avatar):\n    avatar.snabbhet = 10 - avatar.styrka\n\nberäkna_snabbhet(player_1)\nberäkna_snabbhet(player_2)\n\nprint(f\"{player_1.namn} har styrkan {player_1.styrka} snabbheten {player_1.snabbhet}\")\nprint(f\"{player_2.namn} har styrkan {player_2.styrka} snabbheten {player_2.snabbhet}\")",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: Egna datatyper"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/egna-datatyper/index.html#uppgift-utan-lösningsförslag",
    "href": "pr1/python/uppgifter/egna-datatyper/index.html#uppgift-utan-lösningsförslag",
    "title": "Uppgifter: Egna datatyper",
    "section": "",
    "text": "Deklarera en datatyp Bil i Python. Denna datatyp ska innehålla attributen märke, årsmodell, färg, pris och miltal. Skapa minst tio olika instanser av denna datatyp (de kan heta a_bil, b_bil, c_bil osv). Dessa instanser ska läggas in i en lista, denna lista kan heta bilar. För sammanhangets skull kan vi tänka oss att det är en bilhandlare av begagnade bilar som har listan över bilar som är till salu.\n\nSkriv en funktion som tar emot en sådan lista med bilar som parameter och skriver ut all information om respektive bil på ett strukturerat sätt.\nSkriv tre funktioner, välj_märke, välj_pris och välj_max_miltal som skriver ut information om de bilar som uppfyller ett krav (t ex alla Volvo-bilar i listan eller alla bilar som gått max \\(3\\,000\\) mil). Funktionerna måste förstås ta emot lämpliga parametrar och hantera dessa.\nLägg till en meny i programmet där en användare får ange önskemål om vilka bilar som ska skrivas ut.\nSkriv en funktion som sorterar utskriften med avseende på ett valt attribut. Det kan vara att bilarna skrivs ut sorterat efter hur många mil som de gått (den med lägst miltal först och den med högst miltal sist), efter färg, efter pris eller efter märke. Här är en mall till hur en sådan sortering kan gå till:\n\n# Antag att du har en lista med objekt där varje objekt har ett attribut 'attribut'\ndin_lista = [...]\n# Sortera listan baserat på 'attribut'\ndin_lista.sort(key=lambda x: x.attribut)\n\nUtöka programmet med funktionalitet för att söka på bilar efter specifika önskemål baserat på två av ovanstående attribut. T ex alla Volvobilar med ett maximalt miltal eller alla bilar som gått under ett visst antal mil med ett visst maximalt pris.",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: Egna datatyper"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/klasser-och-metoder/index.html",
    "href": "pr1/python/uppgifter/klasser-och-metoder/index.html",
    "title": "Uppgifter: Klasser och metoder",
    "section": "",
    "text": "Deklarera en klass Avatar. Klassen ska ha attributen namn, styrka snabbhet och position. Snabbhet och styrka är tal mellan 0 och 10; deras summa ska bli 10 (så om styrkan anges till 7 så blir snabbheten 3). Positionen är en koordinat i \\(xy\\)-planet; den består av två heltal. I samband med att avataren skapas så ska värdena på dessa attribut anges (det måste alltså finnas en __init__-metod).\nDet ska finnas en metod, uppdatera_position, som flyttar avataren från ett läge till ett annat (alltså uppdaterar koordinaterna). Det ska också finnas en statisk metod som tar två instanser av Avatar och returnerar avståndet mellan dem.\nMan ska också kunna skriva ut information om en avatar med print(avatar), det måste alltså finnas en __str__-metod.\nNär klassen är klar skulle användandet av den kunna se ut så här (se också utskrifterna under koden):\n\navatar1 = Avatar(\"Efelia\", 4, 2, 3)\navatar2 = Avatar(\"Zmille\", 8, 1, 4)\n\nprint(avatar1)\nprint(avatar2)\n\ndistance = Avatar.dist(avatar1, avatar2)\nprint(f\"Avståndet mellan {avatar1.namn} och {avatar2.namn} är \", end=\"\")\nprint(f\"{distance:.2f} enheter.\")\n\navatar1.uppdatera_position(-2, 4)\nprint(avatar1)\n\nDet här är Efelia med styrkan 4. Snabbheten är 6. Positionen är (2, 3).\nDet här är Zmille med styrkan 8. Snabbheten är 2. Positionen är (1, 4).\nAvståndet mellan Efelia och Zmille är 1.41 enheter.\nEfelia byter läge till (-2, 4)\nDet här är Efelia med styrkan 4. Snabbheten är 6. Positionen är (-2, 4).\n\n\n\n\n\nDeklarera en klass Dice, som ska vara en mall för en tärning. Ett Dice-objekt (en tärning alltså) ska kunna initieras med det antal sidor som tärningen ska ha, t ex dice = Dice(6).\nDet ska finnas en metod, roll, som slår tärningen. Denna ska ta emot en parameter som anger hur många gånger som tärningen ska slås. Den kan användas enligt dice.roll(5), vilket alltså indikerar att tärningen slås fem gånger.\nDet ska finnas en metod get_results, som returnerar en lista med utfallshistorik. Vidare ska det finnas en metod print_frequencies som skriver ut en frekvenstabell med kolumner för absolut frekvens och relativ frekvens.\nSlutligen ska __str__ implementeras så att print(dice) ger information om det senaste utfallet.\nSe nedanstående deklarationer och utmatningar:\n\ndice = Dice()\ndice.roll(3)\nprint(f\"Utfallshistoriken är nu: {dice.get_results()}\\n\")\ndice.print_frequencies()\nprint()\ndice.roll(8)\nprint(f\"Utfallshistoriken är nu: {dice.get_results()}\\n\")\ndice.print_frequencies()\nprint()\ndice.roll(100)\nprint()\ndice.print_frequencies()\nprint()\nprint(dice)\n\nSlår tärning, antal kast: 3\nUtfallshistoriken är nu: [2, 2, 6]\n\n Utfall      Frekvens     Relativ frekvens\n=============================================\n   1     |      0      |      0.00 %\n   2     |      2      |     66.67 %\n   3     |      0      |      0.00 %\n   4     |      0      |      0.00 %\n   5     |      0      |      0.00 %\n   6     |      1      |     33.33 %\n\nSlår tärning, antal kast: 8\nUtfallshistoriken är nu: [2, 2, 6, 6, 6, 1, 1, 3, 1, 3, 1]\n\n Utfall      Frekvens     Relativ frekvens\n=============================================\n   1     |      4      |     36.36 %\n   2     |      2      |     18.18 %\n   3     |      2      |     18.18 %\n   4     |      0      |      0.00 %\n   5     |      0      |      0.00 %\n   6     |      3      |     27.27 %\n\nSlår tärning, antal kast: 100\n\n Utfall      Frekvens     Relativ frekvens\n=============================================\n   1     |     20      |     18.02 %\n   2     |     14      |     12.61 %\n   3     |     19      |     17.12 %\n   4     |     22      |     19.82 %\n   5     |     20      |     18.02 %\n   6     |     16      |     14.41 %\n\nTärningen visar 5",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: Klasser och metoder"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/klasser-och-metoder/index.html#uppgift-1",
    "href": "pr1/python/uppgifter/klasser-och-metoder/index.html#uppgift-1",
    "title": "Uppgifter: Klasser och metoder",
    "section": "",
    "text": "Deklarera en klass Avatar. Klassen ska ha attributen namn, styrka snabbhet och position. Snabbhet och styrka är tal mellan 0 och 10; deras summa ska bli 10 (så om styrkan anges till 7 så blir snabbheten 3). Positionen är en koordinat i \\(xy\\)-planet; den består av två heltal. I samband med att avataren skapas så ska värdena på dessa attribut anges (det måste alltså finnas en __init__-metod).\nDet ska finnas en metod, uppdatera_position, som flyttar avataren från ett läge till ett annat (alltså uppdaterar koordinaterna). Det ska också finnas en statisk metod som tar två instanser av Avatar och returnerar avståndet mellan dem.\nMan ska också kunna skriva ut information om en avatar med print(avatar), det måste alltså finnas en __str__-metod.\nNär klassen är klar skulle användandet av den kunna se ut så här (se också utskrifterna under koden):\n\navatar1 = Avatar(\"Efelia\", 4, 2, 3)\navatar2 = Avatar(\"Zmille\", 8, 1, 4)\n\nprint(avatar1)\nprint(avatar2)\n\ndistance = Avatar.dist(avatar1, avatar2)\nprint(f\"Avståndet mellan {avatar1.namn} och {avatar2.namn} är \", end=\"\")\nprint(f\"{distance:.2f} enheter.\")\n\navatar1.uppdatera_position(-2, 4)\nprint(avatar1)\n\nDet här är Efelia med styrkan 4. Snabbheten är 6. Positionen är (2, 3).\nDet här är Zmille med styrkan 8. Snabbheten är 2. Positionen är (1, 4).\nAvståndet mellan Efelia och Zmille är 1.41 enheter.\nEfelia byter läge till (-2, 4)\nDet här är Efelia med styrkan 4. Snabbheten är 6. Positionen är (-2, 4).",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: Klasser och metoder"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/klasser-och-metoder/index.html#uppgift-2",
    "href": "pr1/python/uppgifter/klasser-och-metoder/index.html#uppgift-2",
    "title": "Uppgifter: Klasser och metoder",
    "section": "",
    "text": "Deklarera en klass Dice, som ska vara en mall för en tärning. Ett Dice-objekt (en tärning alltså) ska kunna initieras med det antal sidor som tärningen ska ha, t ex dice = Dice(6).\nDet ska finnas en metod, roll, som slår tärningen. Denna ska ta emot en parameter som anger hur många gånger som tärningen ska slås. Den kan användas enligt dice.roll(5), vilket alltså indikerar att tärningen slås fem gånger.\nDet ska finnas en metod get_results, som returnerar en lista med utfallshistorik. Vidare ska det finnas en metod print_frequencies som skriver ut en frekvenstabell med kolumner för absolut frekvens och relativ frekvens.\nSlutligen ska __str__ implementeras så att print(dice) ger information om det senaste utfallet.\nSe nedanstående deklarationer och utmatningar:\n\ndice = Dice()\ndice.roll(3)\nprint(f\"Utfallshistoriken är nu: {dice.get_results()}\\n\")\ndice.print_frequencies()\nprint()\ndice.roll(8)\nprint(f\"Utfallshistoriken är nu: {dice.get_results()}\\n\")\ndice.print_frequencies()\nprint()\ndice.roll(100)\nprint()\ndice.print_frequencies()\nprint()\nprint(dice)\n\nSlår tärning, antal kast: 3\nUtfallshistoriken är nu: [2, 2, 6]\n\n Utfall      Frekvens     Relativ frekvens\n=============================================\n   1     |      0      |      0.00 %\n   2     |      2      |     66.67 %\n   3     |      0      |      0.00 %\n   4     |      0      |      0.00 %\n   5     |      0      |      0.00 %\n   6     |      1      |     33.33 %\n\nSlår tärning, antal kast: 8\nUtfallshistoriken är nu: [2, 2, 6, 6, 6, 1, 1, 3, 1, 3, 1]\n\n Utfall      Frekvens     Relativ frekvens\n=============================================\n   1     |      4      |     36.36 %\n   2     |      2      |     18.18 %\n   3     |      2      |     18.18 %\n   4     |      0      |      0.00 %\n   5     |      0      |      0.00 %\n   6     |      3      |     27.27 %\n\nSlår tärning, antal kast: 100\n\n Utfall      Frekvens     Relativ frekvens\n=============================================\n   1     |     20      |     18.02 %\n   2     |     14      |     12.61 %\n   3     |     19      |     17.12 %\n   4     |     22      |     19.82 %\n   5     |     20      |     18.02 %\n   6     |     16      |     14.41 %\n\nTärningen visar 5",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: Klasser och metoder"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/strangar/index.html",
    "href": "pr1/python/uppgifter/strangar/index.html",
    "title": "Uppgifter: Strängar",
    "section": "",
    "text": "Skriv ett program som räknar antalet förekomster av bokstaven “p” i strängen \"Packa pappas kappsäck\".\n\n\n\n\n\n\nLösningsförslag uppgift 1\n\n\n\n\n\nmy_str = \"Packa pappas kappsäck\"\np = 0\nfor char in my_str:\n  if char.lower() == \"p\":\n    p += 1\nprint(p)\n\n\n\n\n\n\nDeklarera strängen vowels = \"aeiouyåäö\", och använd denna för att räkna antalet konsonanter i \"Packa pappas kappsäck\".\nTips: Du kan ha nytta av strängmetoden isalnum(), se Cheat Sheet.\n\n\n\n\n\n\nLösningsförslag uppgift 2\n\n\n\n\n\nvowels = \"aeiouyåäö\"\nmy_str = \"Packa pappas kappsäck\"\ncons = 0\nfor char in my_str:\n    if not(char in vowels) and char.isalnum():\n        cons += 1\nprint(cons)\n\n\n\n\n\n\nSkriv ett program som skriver ut strängen \"Packa pappas kappsäck\" baklänges.\nTips: Du kan ha nytta av funktionen len, som fungerar på samma sätt som för listor, se Cheat Sheet\n\n\n\n\n\n\nLösningsförslag uppgift 3\n\n\n\n\n\nVariant 1, med loop\nmy_str = \"Packa pappas kappsäck\"\nfor i in range(len(my_str) - 1, -1, -1):\n    print(my_str[i], end=\"\")\nVariant 2, med “baklänges delsträng”\nmy_str = \"Packa pappas kappsäck\"\nrev_str = my_str[::-1]\nprint(rev_str)\n\n\n\n\n\n\nSkriv ett program som frågar användaren efter en mening. Programmet ska sedan avgöra om meningen är en palindrom. En palindrom är ett ord eller en mening som blir likadan när den läses baklänges. T ex är \"Sirap i Paris, \"Ni talar bra latin\" och \"Was it a car or a cat I saw?\" palindromer. Observera att mellanslagen inte räknas!\nTips: Omvandla först strängen till en sträng utan mellanslag och skiljetecken!\n\n\n\n\n\n\nLösningsförslag uppgift 4\n\n\n\n\n\nMetoden går ut på att skapa två strängar med gemena bokstäver utan skiljetecken: en framlänges och en baklänges.\nsrc_raw = input(\"Ange en sträng som ska testas som palindrom -&gt; \")\nsrc_comp = \"\"\nrev_comp = \"\"\n\nmax_index = len(src_raw) - 1\n\n# Skapa strängen med gemena bokstäver och utan skiljetecken\nfor i in range(0, max_index+1):\n    if src_raw[i].isalnum():\n        src_comp += src_raw[i].lower()\n    \n# Skapa baklänges-strängen\nfor i in range(max_index, -1, -1):\n    if src_raw[i].isalnum():\n        rev_comp += src_raw[i].lower()\n\n# Jämför strängarna med varandra\nif src_comp == rev_comp:\n    print(f\"\\\"{src_raw}\\\" är en palindrom\")\nelse:\n    print(f\"\\\"{src_raw}\\\" är inte en palindrom\")\n\n\n\n\n\n\nI rövarspråket så blir varje så ska varje konsonant upprepas med bokstaven “o” mellan. T ex översätts ordet “KAFFE” till “KOKAFOFFOFE”.\nSkapa ett program som översätter en valfri sträng till rövarspråket.\n\n\n\n\n\n\nLösningsförslag uppgift 5\n\n\n\n\n\nsource = input(\"Ange en sträng för översättning till rövarspråket -&gt; \")\ntarget = \"\"\nconsonants = \"bcdfghjklmnpqrstvwxz\"\nfor char in source:\n    target += char\n    if char.lower() in consonants:\n        target += \"o\" + char\nprint(target)",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: Strängar"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/strangar/index.html#uppgifter-med-kommentarer-och-lösningsförslag",
    "href": "pr1/python/uppgifter/strangar/index.html#uppgifter-med-kommentarer-och-lösningsförslag",
    "title": "Uppgifter: Strängar",
    "section": "",
    "text": "Skriv ett program som räknar antalet förekomster av bokstaven “p” i strängen \"Packa pappas kappsäck\".\n\n\n\n\n\n\nLösningsförslag uppgift 1\n\n\n\n\n\nmy_str = \"Packa pappas kappsäck\"\np = 0\nfor char in my_str:\n  if char.lower() == \"p\":\n    p += 1\nprint(p)\n\n\n\n\n\n\nDeklarera strängen vowels = \"aeiouyåäö\", och använd denna för att räkna antalet konsonanter i \"Packa pappas kappsäck\".\nTips: Du kan ha nytta av strängmetoden isalnum(), se Cheat Sheet.\n\n\n\n\n\n\nLösningsförslag uppgift 2\n\n\n\n\n\nvowels = \"aeiouyåäö\"\nmy_str = \"Packa pappas kappsäck\"\ncons = 0\nfor char in my_str:\n    if not(char in vowels) and char.isalnum():\n        cons += 1\nprint(cons)\n\n\n\n\n\n\nSkriv ett program som skriver ut strängen \"Packa pappas kappsäck\" baklänges.\nTips: Du kan ha nytta av funktionen len, som fungerar på samma sätt som för listor, se Cheat Sheet\n\n\n\n\n\n\nLösningsförslag uppgift 3\n\n\n\n\n\nVariant 1, med loop\nmy_str = \"Packa pappas kappsäck\"\nfor i in range(len(my_str) - 1, -1, -1):\n    print(my_str[i], end=\"\")\nVariant 2, med “baklänges delsträng”\nmy_str = \"Packa pappas kappsäck\"\nrev_str = my_str[::-1]\nprint(rev_str)\n\n\n\n\n\n\nSkriv ett program som frågar användaren efter en mening. Programmet ska sedan avgöra om meningen är en palindrom. En palindrom är ett ord eller en mening som blir likadan när den läses baklänges. T ex är \"Sirap i Paris, \"Ni talar bra latin\" och \"Was it a car or a cat I saw?\" palindromer. Observera att mellanslagen inte räknas!\nTips: Omvandla först strängen till en sträng utan mellanslag och skiljetecken!\n\n\n\n\n\n\nLösningsförslag uppgift 4\n\n\n\n\n\nMetoden går ut på att skapa två strängar med gemena bokstäver utan skiljetecken: en framlänges och en baklänges.\nsrc_raw = input(\"Ange en sträng som ska testas som palindrom -&gt; \")\nsrc_comp = \"\"\nrev_comp = \"\"\n\nmax_index = len(src_raw) - 1\n\n# Skapa strängen med gemena bokstäver och utan skiljetecken\nfor i in range(0, max_index+1):\n    if src_raw[i].isalnum():\n        src_comp += src_raw[i].lower()\n    \n# Skapa baklänges-strängen\nfor i in range(max_index, -1, -1):\n    if src_raw[i].isalnum():\n        rev_comp += src_raw[i].lower()\n\n# Jämför strängarna med varandra\nif src_comp == rev_comp:\n    print(f\"\\\"{src_raw}\\\" är en palindrom\")\nelse:\n    print(f\"\\\"{src_raw}\\\" är inte en palindrom\")\n\n\n\n\n\n\nI rövarspråket så blir varje så ska varje konsonant upprepas med bokstaven “o” mellan. T ex översätts ordet “KAFFE” till “KOKAFOFFOFE”.\nSkapa ett program som översätter en valfri sträng till rövarspråket.\n\n\n\n\n\n\nLösningsförslag uppgift 5\n\n\n\n\n\nsource = input(\"Ange en sträng för översättning till rövarspråket -&gt; \")\ntarget = \"\"\nconsonants = \"bcdfghjklmnpqrstvwxz\"\nfor char in source:\n    target += char\n    if char.lower() in consonants:\n        target += \"o\" + char\nprint(target)",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: Strängar"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/funktioner/index.html",
    "href": "pr1/python/uppgifter/funktioner/index.html",
    "title": "Uppgifter: Funktioner",
    "section": "",
    "text": "Skriv en funktion print_hypotenusa. Funktionen ska ta emot värden på de båda kateternas längd i en rätvinklig triangel, och skriva ut längden av hypotenusan.\nDu behöver inte mata in värden under programkörning, funktionen kan anropas direkt med givna värden på kateterna.\nKörningsexempel:\n\n\n\n\n\n\n\n\nDenna utskrift sker från funktionen print_hypotenusa\nFunktionen tog emot parametrarna 3 och 4\nHypotenusans längd beräknas till 5.0\n\n\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 1\n\n\n\n\n\ndef print_hypotenusa(a, b):\n    hypotenusa = (a**2 + b**2)**0.5\n    print(\"Denna utskrift sker från funktionen print_hypotenusa\")\n    print(f\"Funktionen tog emot parametrarna {a} och {b}\")\n    print(f\"Hypotenusans längd beräknas till {hypotenusa}\")\n\nprint_hypotenusa(3, 4)\n\n\n\n\n\n\nSkriv en funktion beräkna_hypotenusa. Till skillnad från funktionen i uppgift 1 så ska denna funktion returnera värdet på hypotenusans längd och det är huvudprogrammets uppgift (inte funktionens) att skriva ut längden.\nKörningsexempel:\n\n\n\n\n\n\n\n\nDenna utskrift sker från huvudprogrammet\nHuvudprogrammet skickar argumenten 3 och 4 till funktionen\nFuntkionen beräknar hypotenusans längd till 5.0\n\n\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 2\n\n\n\n\n\ndef beräkna_hypotenusa(a, b):\n    hypotenusa = (a**2 + b**2)**0.5\n    return hypotenusa\n\nkatet_1 = 3\nkatet_2 = 4\nhypotenusa = beräkna_hypotenusa(katet_1, katet_2)\nprint(\"Denna utskrift sker från huvudprogrammet\")\nprint(f\"Huvudprogrammet skickar argumenten {katet_1} och {katet_2} till funktionen\")\nprint(f\"Funtkionen beräknar hypotenusans längd till {hypotenusa}\")\n\n\n\n\n\n\nSkriv ett program som ber användaren om en temperatur given antingen i grader Celsius eller grader Fahrenheit, och sedan omvandlar temperaturen till den andra av dessa enheter. Beroende på vilken enhet som temperaturen ges i ska en funktion väljas. Funktionerna, som du ska skriva, kan heta till_fahr respektive till_celsius. Var och en av dessa funktioner ska ta en temperatur som parameter och returnera temperaturen uttryckt i den andra enheten.\nHuvudprogrammet kan se ut enligt nedan. Här finns också rutiner för en ‘’säker inmatning’’ av heltal respektive strängar. Detta kan du använda som referens för senare program.\n# Huvudprogram, omvandling av temperatur mellan olika enheter\n\n# Nedanstående kod ger en säker inmatning av heltal\nwhile True:\n    try:\n        temp =  int(input(\"Ange mätvärdet på temperaturen -&gt; \"))\n        break\n    except ValueError:\n        print(\"Felaktig inmatning, försök igen\")\n\n# Nedanstående kod ger en säker inmatning av enheten\n# och dirigerar värdet till aktuell funktion\nwhile True:\n    enhet = input(\"Ange enheten som detta mätvärde är angivet i [C / F] -&gt; \")\n    if enhet in {\"C\", \"c\"}:\n        fahr = till_fahr(temp)\n        print(f\"Temperaturen i grader Fahrenheit är {fahr}\")\n        break\n    elif enhet in {\"F\", \"f\"}:\n        celsius = till_celsius(temp)\n        print(f\"Temperaturen i grader Celsius är {celsius}\")\n        break\n    print(\"Felaktig inmatning, försök igen\")\nSambandet mellan temperatur angivet i grader Celsius och gradet Fahrenheit är givet i Uppgift 9 i avsnittet om loopar\n\n\n\n\n\n\nLösningsförslag uppgift 3\n\n\n\n\n\ndef till_celsius(F):\n    C = 5/9 * F - 160/9\n    return C\n\ndef till_fahr(C):\n    F = 9/5 * C + 32\n    return F\n\n# Huvudprogram, omvandling av temperatur mellan olika enheter\n\n# Nedanstående kod ger en säker inmatning av heltal\nwhile True:\n    try:\n        temp =  int(input(\"Ange mätvärdet på temperaturen -&gt; \"))\n        break\n    except ValueError:\n        print(\"Felaktig inmatning, försök igen\")\n\n# Nedanstående kod ger en säker inmatning av enheten\n# och dirigerar värdet till aktuell funktion\nwhile True:\n    enhet = input(\"Ange enheten som detta mätvärde är angivet i [C / F] -&gt; \")\n    if enhet in {\"C\", \"c\"}:\n        fahr = till_fahr(temp)\n        print(f\"Temperaturen i grader Fahrenheit är {fahr}\")\n        break\n    elif enhet in {\"F\", \"f\"}:\n        celsius = till_celsius(temp)\n        print(f\"Temperaturen i grader Celsius är {celsius}\")\n        break\n    print(\"Felaktig inmatning, försök igen\")\n\n\n\n\n\n\nÄven om programmet i Uppgift 3 gör sitt jobb, så är huvudprogrammet lite väl långt. Det är eftersträvansvärt att huvudprogrammet ger en klar bild av strukturen, och det mesta utlokaliseras till funktioner.\nExempel på hur ett kortare huvudprogram kan se ut:\n# Huvudprogram, omvandling av temperatur mellan olika enheter\n\ntemp = ange_mätvärde()\nenhet = ange_enhet()\nskriv_mätvärde_i_andra_enheten(temp, enhet)\nHuvudprogrammet består alltså av tre funktionsanrop, och funktionen skriv_mätvärde_i_andra_enheten består dessutom av två möjliga funktionsanrop där ett av dessa väljs.\n\n\n\n\n\n\nLösningsförslag uppgift 4\n\n\n\n\n\ndef till_celsius(F):\n    C = 5/9 * F - 160/9\n    return C\n\ndef till_fahr(C):\n    F = 9/5 * C + 32\n    return F\n\ndef ange_mätvärde():\n    # Nedanstående kod ger en säker inmatning av heltal\n    while True:\n        try:\n            temp =  int(input(\"Ange mätvärdet på temperaturen -&gt; \"))\n            return temp\n        except ValueError:\n            print(\"Felaktig inmatning, försök igen\")\n\ndef ange_enhet():\n    # Nedanstående kod ger en säker inmatning av enheten\n    # och dirigerar värdet till aktuell funktion\n    while True:\n        enhet = input(\"Ange enheten som detta mätvärde är angivet i [C / F] -&gt; \")\n        if enhet in {\"C\", \"c\"}:\n            return \"C\"\n        elif enhet in {\"F\", \"f\"}:\n            celsius = till_celsius(temp)\n            return \"F\"\n        print(\"Felaktig inmatning, försök igen\")\n\ndef skriv_mätvärde_i_andra_enheten(temp, enhet):\n    if enhet == \"C\":\n        fahr = till_fahr(temp)\n        print(f\"Temperaturen i grader Fahrenheit är {fahr}\")\n    else:\n        celsius = till_celsius(temp)\n        print(f\"Temperaturen i grader Celsius är {celsius}\")\n        \n    \n    \n# Huvudprogram, omvandling av temperatur mellan olika enheter\n\ntemp = ange_mätvärde()\nenhet = ange_enhet()\nskriv_mätvärde_i_andra_enheten(temp, enhet)\n\n\n\n\n\n\nDu har tidigare skrivit ett program där du låter en spelare gissa på ett framslumpat tal.\nSkriv en funktion som slumpar fram talet och håller reda på antalet gissningar innan talet gissas rätt. Funktionen ska returnera antalet gissningar, vilka skrivs ut i huvudprogrammet.\nProgrammet ska ha följande struktur:\ndef spela():\n  # Här skriver du funktionen...\n  # ...och returnerar antalet försök\n\n# Huvudprogram\nantal_försök = spela()\nprint(\"RÄTT GISSAT!\")\nprint(f\"Du klarade spelet på gissning nr. {antal_försök}.\")\nFormulera också en lämplig docstring till funktionen spela. Försök att göra gissningarna inmatningssäkra, och att enbart giltiga gissningar räknas.\n\n\n\n\n\n\nLösningsförslag uppgift 5\n\n\n\n\n\nDetta gissningsspel är lite mer utvecklat än det förra som gjordes. Här finns en inmatningskontroll så att enbart tal mellan (och inklusive) 1 och 10 kommer att godtas som inmatning.\nimport random as rand\n\ndef spela():\n    '''\n    I denna funktion så får användaren gissa på\n    ett tal som datorn slumpat fram.\n    Feedback till användaren i form av ledtråd\n    om det inmatade talet var för stort eller för litet.\n    Parametrar: inga\n    Returvärde: antal gissningar som behövdes\n    '''\n    datorns_tal = rand.randint(1, 10)\n    antal_gissningar = 0\n    while True:\n        gissning = input(\"Gissa ett tal mellan 1 och 10 -&gt; \")\n        try:\n            gissning = int(gissning)\n        except ValueError:\n            print(\"Du måste ange ett heltal mellan 1 och 10\")\n            continue\n        if (1 &lt;= gissning &lt;= 10):\n            antal_gissningar += 1\n            if gissning &gt; datorns_tal:\n                print(\"Din gissning var för stor\")\n            elif gissning &lt; datorns_tal:\n                print(\"Din gissning var för liten\")\n            else:\n                return antal_gissningar\n        else:\n            print(\"Du måste ange ett heltal mellan 1 och 10\")\n\n# Huvudprogram\nantal_försök = spela()\nprint(\"RÄTT GISSAT!\")\nprint(f\"Du klarade spelet på gissning nr. {antal_försök}.\")\n\n\n\n\n\n\n\n\n\nFakulteten på talet \\(x\\) skrivs som \\(x!\\). T ex gäller att \\(5!\\) antar värdet \\(5\\cdot 4\\cdot 3\\cdot 2\\cdot 1\\).\nSkriv en funktion fac som tar emot ett tal \\(x\\), som är ett icke-negativt heltal, och returnerar värdet på \\(x!\\). Värdet på \\(0!\\) är definierat till 1.\n\n\n\nEtt primtal är ett positivt heltal som är 2 eller större, där 2 är det minsta primtalet. Ett primtal är enbart delbart med sig självt och 1. T ex är talet 13 ett primtal därför att det uppfyller allt detta.\nSkriv en funktion is_prime(number) som returnerar True om parametern number är ett primtal, och annars False.\nJämn delbarhet kan testas med modulo-operatorn, %. T ex gäller att talet 12 är jämnt delbart med 4, varför uttrycket 12 % 4 antar värdet 0. Talet 13 är inte jämnt delbart med 4, varför uttrycket 13 % 4 får ett annat värde än noll (i nuläget spelar det inte någon roll vilket annat värde, testa enbart på noll och nollskilda värden).\nJämn delbarhet behöver också enbart testas upp till kvadratroten ur talet ifråga. T ex så gäller att \\(\\sqrt{29}\\approx 5.38\\), varför det räcker med att pröva om talet 29 är jämnt delbart med 2, 3, 4 och 5 för att avgöra om det är ett primtal (och det är det).\nTänk på att \\(\\sqrt{x}=x^{0.5}\\). Det skrivs i Python som x**0.5.",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: Funktioner"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/funktioner/index.html#uppgifter-med-lösningsförslag",
    "href": "pr1/python/uppgifter/funktioner/index.html#uppgifter-med-lösningsförslag",
    "title": "Uppgifter: Funktioner",
    "section": "",
    "text": "Skriv en funktion print_hypotenusa. Funktionen ska ta emot värden på de båda kateternas längd i en rätvinklig triangel, och skriva ut längden av hypotenusan.\nDu behöver inte mata in värden under programkörning, funktionen kan anropas direkt med givna värden på kateterna.\nKörningsexempel:\n\n\n\n\n\n\n\n\nDenna utskrift sker från funktionen print_hypotenusa\nFunktionen tog emot parametrarna 3 och 4\nHypotenusans längd beräknas till 5.0\n\n\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 1\n\n\n\n\n\ndef print_hypotenusa(a, b):\n    hypotenusa = (a**2 + b**2)**0.5\n    print(\"Denna utskrift sker från funktionen print_hypotenusa\")\n    print(f\"Funktionen tog emot parametrarna {a} och {b}\")\n    print(f\"Hypotenusans längd beräknas till {hypotenusa}\")\n\nprint_hypotenusa(3, 4)\n\n\n\n\n\n\nSkriv en funktion beräkna_hypotenusa. Till skillnad från funktionen i uppgift 1 så ska denna funktion returnera värdet på hypotenusans längd och det är huvudprogrammets uppgift (inte funktionens) att skriva ut längden.\nKörningsexempel:\n\n\n\n\n\n\n\n\nDenna utskrift sker från huvudprogrammet\nHuvudprogrammet skickar argumenten 3 och 4 till funktionen\nFuntkionen beräknar hypotenusans längd till 5.0\n\n\n\n\n\n\n\n\n\n\n\nLösningsförslag uppgift 2\n\n\n\n\n\ndef beräkna_hypotenusa(a, b):\n    hypotenusa = (a**2 + b**2)**0.5\n    return hypotenusa\n\nkatet_1 = 3\nkatet_2 = 4\nhypotenusa = beräkna_hypotenusa(katet_1, katet_2)\nprint(\"Denna utskrift sker från huvudprogrammet\")\nprint(f\"Huvudprogrammet skickar argumenten {katet_1} och {katet_2} till funktionen\")\nprint(f\"Funtkionen beräknar hypotenusans längd till {hypotenusa}\")\n\n\n\n\n\n\nSkriv ett program som ber användaren om en temperatur given antingen i grader Celsius eller grader Fahrenheit, och sedan omvandlar temperaturen till den andra av dessa enheter. Beroende på vilken enhet som temperaturen ges i ska en funktion väljas. Funktionerna, som du ska skriva, kan heta till_fahr respektive till_celsius. Var och en av dessa funktioner ska ta en temperatur som parameter och returnera temperaturen uttryckt i den andra enheten.\nHuvudprogrammet kan se ut enligt nedan. Här finns också rutiner för en ‘’säker inmatning’’ av heltal respektive strängar. Detta kan du använda som referens för senare program.\n# Huvudprogram, omvandling av temperatur mellan olika enheter\n\n# Nedanstående kod ger en säker inmatning av heltal\nwhile True:\n    try:\n        temp =  int(input(\"Ange mätvärdet på temperaturen -&gt; \"))\n        break\n    except ValueError:\n        print(\"Felaktig inmatning, försök igen\")\n\n# Nedanstående kod ger en säker inmatning av enheten\n# och dirigerar värdet till aktuell funktion\nwhile True:\n    enhet = input(\"Ange enheten som detta mätvärde är angivet i [C / F] -&gt; \")\n    if enhet in {\"C\", \"c\"}:\n        fahr = till_fahr(temp)\n        print(f\"Temperaturen i grader Fahrenheit är {fahr}\")\n        break\n    elif enhet in {\"F\", \"f\"}:\n        celsius = till_celsius(temp)\n        print(f\"Temperaturen i grader Celsius är {celsius}\")\n        break\n    print(\"Felaktig inmatning, försök igen\")\nSambandet mellan temperatur angivet i grader Celsius och gradet Fahrenheit är givet i Uppgift 9 i avsnittet om loopar\n\n\n\n\n\n\nLösningsförslag uppgift 3\n\n\n\n\n\ndef till_celsius(F):\n    C = 5/9 * F - 160/9\n    return C\n\ndef till_fahr(C):\n    F = 9/5 * C + 32\n    return F\n\n# Huvudprogram, omvandling av temperatur mellan olika enheter\n\n# Nedanstående kod ger en säker inmatning av heltal\nwhile True:\n    try:\n        temp =  int(input(\"Ange mätvärdet på temperaturen -&gt; \"))\n        break\n    except ValueError:\n        print(\"Felaktig inmatning, försök igen\")\n\n# Nedanstående kod ger en säker inmatning av enheten\n# och dirigerar värdet till aktuell funktion\nwhile True:\n    enhet = input(\"Ange enheten som detta mätvärde är angivet i [C / F] -&gt; \")\n    if enhet in {\"C\", \"c\"}:\n        fahr = till_fahr(temp)\n        print(f\"Temperaturen i grader Fahrenheit är {fahr}\")\n        break\n    elif enhet in {\"F\", \"f\"}:\n        celsius = till_celsius(temp)\n        print(f\"Temperaturen i grader Celsius är {celsius}\")\n        break\n    print(\"Felaktig inmatning, försök igen\")\n\n\n\n\n\n\nÄven om programmet i Uppgift 3 gör sitt jobb, så är huvudprogrammet lite väl långt. Det är eftersträvansvärt att huvudprogrammet ger en klar bild av strukturen, och det mesta utlokaliseras till funktioner.\nExempel på hur ett kortare huvudprogram kan se ut:\n# Huvudprogram, omvandling av temperatur mellan olika enheter\n\ntemp = ange_mätvärde()\nenhet = ange_enhet()\nskriv_mätvärde_i_andra_enheten(temp, enhet)\nHuvudprogrammet består alltså av tre funktionsanrop, och funktionen skriv_mätvärde_i_andra_enheten består dessutom av två möjliga funktionsanrop där ett av dessa väljs.\n\n\n\n\n\n\nLösningsförslag uppgift 4\n\n\n\n\n\ndef till_celsius(F):\n    C = 5/9 * F - 160/9\n    return C\n\ndef till_fahr(C):\n    F = 9/5 * C + 32\n    return F\n\ndef ange_mätvärde():\n    # Nedanstående kod ger en säker inmatning av heltal\n    while True:\n        try:\n            temp =  int(input(\"Ange mätvärdet på temperaturen -&gt; \"))\n            return temp\n        except ValueError:\n            print(\"Felaktig inmatning, försök igen\")\n\ndef ange_enhet():\n    # Nedanstående kod ger en säker inmatning av enheten\n    # och dirigerar värdet till aktuell funktion\n    while True:\n        enhet = input(\"Ange enheten som detta mätvärde är angivet i [C / F] -&gt; \")\n        if enhet in {\"C\", \"c\"}:\n            return \"C\"\n        elif enhet in {\"F\", \"f\"}:\n            celsius = till_celsius(temp)\n            return \"F\"\n        print(\"Felaktig inmatning, försök igen\")\n\ndef skriv_mätvärde_i_andra_enheten(temp, enhet):\n    if enhet == \"C\":\n        fahr = till_fahr(temp)\n        print(f\"Temperaturen i grader Fahrenheit är {fahr}\")\n    else:\n        celsius = till_celsius(temp)\n        print(f\"Temperaturen i grader Celsius är {celsius}\")\n        \n    \n    \n# Huvudprogram, omvandling av temperatur mellan olika enheter\n\ntemp = ange_mätvärde()\nenhet = ange_enhet()\nskriv_mätvärde_i_andra_enheten(temp, enhet)\n\n\n\n\n\n\nDu har tidigare skrivit ett program där du låter en spelare gissa på ett framslumpat tal.\nSkriv en funktion som slumpar fram talet och håller reda på antalet gissningar innan talet gissas rätt. Funktionen ska returnera antalet gissningar, vilka skrivs ut i huvudprogrammet.\nProgrammet ska ha följande struktur:\ndef spela():\n  # Här skriver du funktionen...\n  # ...och returnerar antalet försök\n\n# Huvudprogram\nantal_försök = spela()\nprint(\"RÄTT GISSAT!\")\nprint(f\"Du klarade spelet på gissning nr. {antal_försök}.\")\nFormulera också en lämplig docstring till funktionen spela. Försök att göra gissningarna inmatningssäkra, och att enbart giltiga gissningar räknas.\n\n\n\n\n\n\nLösningsförslag uppgift 5\n\n\n\n\n\nDetta gissningsspel är lite mer utvecklat än det förra som gjordes. Här finns en inmatningskontroll så att enbart tal mellan (och inklusive) 1 och 10 kommer att godtas som inmatning.\nimport random as rand\n\ndef spela():\n    '''\n    I denna funktion så får användaren gissa på\n    ett tal som datorn slumpat fram.\n    Feedback till användaren i form av ledtråd\n    om det inmatade talet var för stort eller för litet.\n    Parametrar: inga\n    Returvärde: antal gissningar som behövdes\n    '''\n    datorns_tal = rand.randint(1, 10)\n    antal_gissningar = 0\n    while True:\n        gissning = input(\"Gissa ett tal mellan 1 och 10 -&gt; \")\n        try:\n            gissning = int(gissning)\n        except ValueError:\n            print(\"Du måste ange ett heltal mellan 1 och 10\")\n            continue\n        if (1 &lt;= gissning &lt;= 10):\n            antal_gissningar += 1\n            if gissning &gt; datorns_tal:\n                print(\"Din gissning var för stor\")\n            elif gissning &lt; datorns_tal:\n                print(\"Din gissning var för liten\")\n            else:\n                return antal_gissningar\n        else:\n            print(\"Du måste ange ett heltal mellan 1 och 10\")\n\n# Huvudprogram\nantal_försök = spela()\nprint(\"RÄTT GISSAT!\")\nprint(f\"Du klarade spelet på gissning nr. {antal_försök}.\")",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: Funktioner"
    ]
  },
  {
    "objectID": "pr1/python/uppgifter/funktioner/index.html#uppgifter-utan-lösningsförslag",
    "href": "pr1/python/uppgifter/funktioner/index.html#uppgifter-utan-lösningsförslag",
    "title": "Uppgifter: Funktioner",
    "section": "",
    "text": "Fakulteten på talet \\(x\\) skrivs som \\(x!\\). T ex gäller att \\(5!\\) antar värdet \\(5\\cdot 4\\cdot 3\\cdot 2\\cdot 1\\).\nSkriv en funktion fac som tar emot ett tal \\(x\\), som är ett icke-negativt heltal, och returnerar värdet på \\(x!\\). Värdet på \\(0!\\) är definierat till 1.\n\n\n\nEtt primtal är ett positivt heltal som är 2 eller större, där 2 är det minsta primtalet. Ett primtal är enbart delbart med sig självt och 1. T ex är talet 13 ett primtal därför att det uppfyller allt detta.\nSkriv en funktion is_prime(number) som returnerar True om parametern number är ett primtal, och annars False.\nJämn delbarhet kan testas med modulo-operatorn, %. T ex gäller att talet 12 är jämnt delbart med 4, varför uttrycket 12 % 4 antar värdet 0. Talet 13 är inte jämnt delbart med 4, varför uttrycket 13 % 4 får ett annat värde än noll (i nuläget spelar det inte någon roll vilket annat värde, testa enbart på noll och nollskilda värden).\nJämn delbarhet behöver också enbart testas upp till kvadratroten ur talet ifråga. T ex så gäller att \\(\\sqrt{29}\\approx 5.38\\), varför det räcker med att pröva om talet 29 är jämnt delbart med 2, 3, 4 och 5 för att avgöra om det är ett primtal (och det är det).\nTänk på att \\(\\sqrt{x}=x^{0.5}\\). Det skrivs i Python som x**0.5.",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Uppgifter, Python",
      "Uppgifter: Funktioner"
    ]
  },
  {
    "objectID": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#klipsk-som-en-dator",
    "href": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#klipsk-som-en-dator",
    "title": "Introduktion Programmering 1",
    "section": "Klipsk som en dator?",
    "text": "Klipsk som en dator?"
  },
  {
    "objectID": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#förkunskaper",
    "href": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#förkunskaper",
    "title": "Introduktion Programmering 1",
    "section": "Förkunskaper?",
    "text": "Förkunskaper?\n\n\n\n\nhttps://tinyurl.com/37n7zry2"
  },
  {
    "objectID": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#vad-är-ett-datorprogram",
    "href": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#vad-är-ett-datorprogram",
    "title": "Introduktion Programmering 1",
    "section": "Vad är ett datorprogram?",
    "text": "Vad är ett datorprogram?\n\n\n\nEtt datorprogram är som en uppsättning instruktioner eller regler som berättar för datorn vad den ska göra.\n\n\n\n\nPrecis som vi människor använder oss av instruktioner för att utföra olika uppgifter, använder sig också en dator av programmet för att lösa problem och utföra specifika arbetsuppgifter.\n\n\n\n\nDessa instruktioner i ett datorprogram skrivs vanligtvis i ett programmeringsspråk, vilket är ett särskilt språk som både människor och datorer kan förstå.\n\n\n\n\nNär programmet körs på en dator läser den stegvis igenom varje instruktion och utför de angivna operationerna."
  },
  {
    "objectID": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#vad-är-ett-datorprogram-forts.",
    "href": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#vad-är-ett-datorprogram-forts.",
    "title": "Introduktion Programmering 1",
    "section": "Vad är ett datorprogram? (forts.)",
    "text": "Vad är ett datorprogram? (forts.)\n\n\n\nGenom att kombinera olika instruktionssekvenser kan man bygga upp mer komplexa program som kan hantera allt från matematiska beräkningar till grafikrendering eller datahantering.\n\n\n\n\nMänniskor skapar dessa program för att automatisera processer, lösa problem eller utveckla nya teknologier och applikationer som används inom allt från spelutveckling till medicinsk forskning och affärsverksamhet.\n\n\n\nSammanfattningsvis kan man säga att ett datorprogram är en samling av instruktioner skrivna i programmeringsspråk, vilket ger möjlighet att styra hur en dators hårdvara fungerar och får den att utföra specifika uppgifter."
  },
  {
    "objectID": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#utvecklingsmiljö",
    "href": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#utvecklingsmiljö",
    "title": "Introduktion Programmering 1",
    "section": "Utvecklingsmiljö",
    "text": "Utvecklingsmiljö\nVi kommer att arbeta med Pythons miljö Idle under första halvan av höstterminen\n\n\n  \n\nMiljön består av en konsol där kortare “kodsnuttar” kan skrivas in och en editor där program kan skrivas och sparas.\n\nLadda ned från https://www.python.org/downloads"
  },
  {
    "objectID": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#dagens-mål",
    "href": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#dagens-mål",
    "title": "Introduktion Programmering 1",
    "section": "Dagens mål",
    "text": "Dagens mål\n\nInstallera Python på datorn\nBekanta sig med konsol och editor genom arbete med\n\nVariabler\nFormaterad utskrift"
  },
  {
    "objectID": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#variabler",
    "href": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#variabler",
    "title": "Introduktion Programmering 1",
    "section": "Variabler",
    "text": "Variabler\nEn variabel är ett “namn” på ett värde. Kan även kallas för en identifierare.\n\n# Detta program skrivs i en fil som sparas.\n# Filen skapas i Idle: File -&gt; New File\n# och namnges till fartberäkning\nsträcka = 103  # Sträckan i meter\ntid = 13.2     # Tiden i sekunder\nfart = sträcka / tid\n\nprint(f\"Fart = {fart:.1f} m/s\")\n# Skriver ut Fart = 7.8 m/s\n\nFart = 7.8 m/s\n\n\n\nVariabler kan innehålla andra saker än tal; man säger att även detta är värden."
  },
  {
    "objectID": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#variabeltyper",
    "href": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#variabeltyper",
    "title": "Introduktion Programmering 1",
    "section": "Variabeltyper",
    "text": "Variabeltyper\n\nNågra vanliga typer av variabler är  string (sträng), int (heltal) och float (tal med decimaler).\n\n\nPython kan skriva ut variabeltypen för en given variabel.\n\n\n\nett_heltal = 5\nett_flyttal = 2.9\nen_sträng = \"En sträng\"\nprint(type(ett_heltal))\nprint(type(ett_flyttal))\nprint(type(en_sträng))\n\n&lt;class 'int'&gt;\n&lt;class 'float'&gt;\n&lt;class 'str'&gt;"
  },
  {
    "objectID": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#variabler-i-datorminnet",
    "href": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#variabler-i-datorminnet",
    "title": "Introduktion Programmering 1",
    "section": "Variabler i datorminnet",
    "text": "Variabler i datorminnet\n\nNär en variabel tilldelas ett värde kommer detta värde att sparas på en plats i datorns minne. När variabeln adresseras kommer namnet att hänvisa till denna minnesplats."
  },
  {
    "objectID": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#några-regler-för-variabelnamn",
    "href": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#några-regler-för-variabelnamn",
    "title": "Introduktion Programmering 1",
    "section": "Några regler för variabelnamn",
    "text": "Några regler för variabelnamn\n\n\nAlla bokstavstecken och siffror får användas\n\n\n\n\nPython gör skillnad på versaler och gemener\n\n\n\n\nVariabelnamn kan inte börja med en siffra\n\n\n\n\nVariabelnamn kan inte innehålla mellanslag\n\n\n\n\nVariabelnamn kan inte innehålla bindestreck"
  },
  {
    "objectID": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#några-regler-för-variabelnamn-forts.",
    "href": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#några-regler-för-variabelnamn-forts.",
    "title": "Introduktion Programmering 1",
    "section": "Några regler för variabelnamn (forts.)",
    "text": "Några regler för variabelnamn (forts.)\n\n\n\n\n\nVariabelnamn bör inledas med en gemen (“liten”) bokstav\n\n\n\n\nVariabelnamn bör vara uttrycksfulla, dvs beskriva vad de står för\n\n\n\n\nOrd separeras, t ex längd_rekt = 5\n\n\n\n\nLänk: Tillåtna namn på variabler"
  },
  {
    "objectID": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#utskrifter-i-python",
    "href": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#utskrifter-i-python",
    "title": "Introduktion Programmering 1",
    "section": "Utskrifter i Python",
    "text": "Utskrifter i Python\n\n\n\nUtskrift av sträng\n\nhello_string = \"Hello, world\"\nprint(hello_string)\n\nHello, world\n\n\n\n\n\n\n\nUtskrift av sträng och tal\n\npris = 10\nprint(f\"Priset är {pris} kr.\")\n\nPriset är 10 kr.\n\n\n\n\n\nUtskrift av heltal\n\npris = 10\nprint(pris)\n\n10\n\n\n\n\n\n\n\nAvrundning\n\nmy_float = 2/3\nprint(f\"{my_float:.2f}\")\n\n0.67\n\n\n\n\n\nNär “fast” text ska skrivas ut tillsammans med en variabel används en s.k f-string. Det står för formatted string literal."
  },
  {
    "objectID": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#formaterad-utskrift",
    "href": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#formaterad-utskrift",
    "title": "Introduktion Programmering 1",
    "section": "Formaterad utskrift",
    "text": "Formaterad utskrift\nEn teckensträng har en en given textbredd. Det tydliggörs med utfyllnadstecken.\n\ns1 = \"Kalle\"\ns2 = \"Anka\"\nprint(f\"{s1:*&lt;13}\")      # Textbredd 13, vänsterjusterat\nprint(f\"{s1:*&gt;13}\")      # Textbredd 13, högerjusterat\nprint(f\"{s1:*^13}\")      # Textbredd 13, centrerat\nprint(s1.rjust(13, \"*\")) # Finns även ljust och center\nprint(s1.ljust(13) + s2) # Inget utfyllnadstecken!\n\n\n\nKalle********\n********Kalle\n****Kalle****\n********Kalle\nKalle        Anka\n\n\n\nPå rad 7 syns att vi kan slå ihop (konkatenera) två strängar med operatorn +."
  },
  {
    "objectID": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#sträng-med-radbrytning",
    "href": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#sträng-med-radbrytning",
    "title": "Introduktion Programmering 1",
    "section": "Sträng med radbrytning",
    "text": "Sträng med radbrytning\nFör att skriva ut en sträng på flera används ett s.k “flykttecken” (escape character).\n\nprint(\"Här är en text\\npå två rader\")\n\nHär är en text\npå två rader\n\n\n\nDetta kan användas tillsammans med textbredden.\n\nprint(f\"Detta är en högerjusterad text\\n{'på flera rader':*&gt;30}\")\n\nDetta är en högerjusterad text\n****************på flera rader\n\n\n\n\n\n\n\n\nDet finns flera exempel på escape characters på denna länk."
  },
  {
    "objectID": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#justering-av-tal",
    "href": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#justering-av-tal",
    "title": "Introduktion Programmering 1",
    "section": "Justering av tal",
    "text": "Justering av tal\n\nTabeller blir mer lättlästa om ental står under ental, tiondel under tiondel osv.\n\n\n\na = 10.5; b = 2.38\nc = 2.3;  d = 0.1\nprint(f\"{a:6.2f}\\t\\t{c:6.2f}\\n{b:6.2f}\\t\\t{d:6.2f}\")\nprint(\"----------------------\");\nprint(f\"{(a+b):6.2f}\\t\\t{(c+d):6.2f}\")\n\n 10.50        2.30\n  2.38        0.10\n----------------------\n 12.88        2.40\n\n\n\n\nObservera att beräkningarna sker mellan måsvingarna!"
  },
  {
    "objectID": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#sammanfattning",
    "href": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#sammanfattning",
    "title": "Introduktion Programmering 1",
    "section": "Sammanfattning",
    "text": "Sammanfattning\n\n\n\nEtt datorprogram är en följd av instruktioner.\n\n\n\n\nDessa instruktioner skrivs i ett programmeringsspråk.\n\n\n\n\nI Python kan korta kodavsnitt skrivas i konsolen, medan en editor används för att skriva och spara program.\n\n\n\n\nI datorprogram kan användas kommentarer för att det ska bli mer lättläst. För Python gäller tecknet # inleder kommentaren # Kommentar\n\n\n\n\nFör att lagra värden i ett program används variabler.\n\n\n\n\nVariabelns typ beror på vilket sorts värde som lagras."
  },
  {
    "objectID": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#sammanfattning-forts.",
    "href": "pr1/python/intro/pres-version-installerad-python/intro-pres.html#sammanfattning-forts.",
    "title": "Introduktion Programmering 1",
    "section": "Sammanfattning (forts.)",
    "text": "Sammanfattning (forts.)\n\n\n\nDet finns regler och konventioner för namngivning av variabler.\n\n\n\n\nFör att skriva ut variabler i Python används en funktion som heter print.\n\n\n\n\nMed print går det att styra hur utskriften sker, t ex med avseende på radbrytning, textjustering och antal decimaler för ett tal.\n\n\n\n\nUttryck kan evalueras i en sträng i Python med f-string.\n\nprint(f\"Talet är {2+2}\") # Talet är 4"
  },
  {
    "objectID": "pr1/python/intro/pres-version-online-python/intro-pres.html#klipsk-som-en-dator",
    "href": "pr1/python/intro/pres-version-online-python/intro-pres.html#klipsk-som-en-dator",
    "title": "Introduktion Programmering 1, indval",
    "section": "Klipsk som en dator?",
    "text": "Klipsk som en dator?"
  },
  {
    "objectID": "pr1/python/intro/pres-version-online-python/intro-pres.html#förkunskaper",
    "href": "pr1/python/intro/pres-version-online-python/intro-pres.html#förkunskaper",
    "title": "Introduktion Programmering 1, indval",
    "section": "Förkunskaper?",
    "text": "Förkunskaper?\n\n\n\n\nhttps://shorturl.at/fhBG5"
  },
  {
    "objectID": "pr1/python/intro/pres-version-online-python/intro-pres.html#vad-är-ett-datorprogram",
    "href": "pr1/python/intro/pres-version-online-python/intro-pres.html#vad-är-ett-datorprogram",
    "title": "Introduktion Programmering 1, indval",
    "section": "Vad är ett datorprogram?",
    "text": "Vad är ett datorprogram?\n\n\n\nEtt datorprogram är som en uppsättning instruktioner eller regler som berättar för datorn vad den ska göra.\n\n\n\n\nPrecis som vi människor använder oss av instruktioner för att utföra olika uppgifter, använder sig också en dator av programmet för att lösa problem och utföra specifika arbetsuppgifter.\n\n\n\n\nDessa instruktioner i ett datorprogram skrivs vanligtvis i ett programmeringsspråk, vilket är ett särskilt språk som både människor och datorer kan förstå.\n\n\n\n\nNär programmet körs på en dator läser den stegvis igenom varje instruktion och utför de angivna operationerna."
  },
  {
    "objectID": "pr1/python/intro/pres-version-online-python/intro-pres.html#vad-är-ett-datorprogram-forts.",
    "href": "pr1/python/intro/pres-version-online-python/intro-pres.html#vad-är-ett-datorprogram-forts.",
    "title": "Introduktion Programmering 1, indval",
    "section": "Vad är ett datorprogram? (forts.)",
    "text": "Vad är ett datorprogram? (forts.)\n\n\n\nGenom att kombinera olika instruktionssekvenser kan man bygga upp mer komplexa program som kan hantera allt från matematiska beräkningar till grafikrendering eller datahantering.\n\n\n\n\nMänniskor skapar dessa program för att automatisera processer, lösa problem eller utveckla nya teknologier och applikationer som används inom allt från spelutveckling till medicinsk forskning och affärsverksamhet.\n\n\n\nSammanfattningsvis kan man säga att ett datorprogram är en samling av instruktioner skrivna i programmeringsspråk, vilket ger möjlighet att styra hur en dators hårdvara fungerar och får den att utföra specifika uppgifter."
  },
  {
    "objectID": "pr1/python/intro/pres-version-online-python/intro-pres.html#utvecklingsmiljö",
    "href": "pr1/python/intro/pres-version-online-python/intro-pres.html#utvecklingsmiljö",
    "title": "Introduktion Programmering 1, indval",
    "section": "Utvecklingsmiljö",
    "text": "Utvecklingsmiljö\nVi kommer att arbeta i online-miljön Replit under kursen.\n\n\n\n\n\n  \n\nMiljön består b la av en konsol där kortare “kodsnuttar” kan skrivas in och en editor där program kan skrivas och sparas.\n\nRegistrera dig på https://replit.com/ med din “skol-Google”."
  },
  {
    "objectID": "pr1/python/intro/pres-version-online-python/intro-pres.html#dagens-mål",
    "href": "pr1/python/intro/pres-version-online-python/intro-pres.html#dagens-mål",
    "title": "Introduktion Programmering 1, indval",
    "section": "Dagens mål",
    "text": "Dagens mål\n\nSkapa inloggning på Replit\nBekanta sig med konsol och editor genom arbete med\n\nVariabler\nFormaterad utskrift"
  },
  {
    "objectID": "pr1/python/intro/pres-version-online-python/intro-pres.html#variabler",
    "href": "pr1/python/intro/pres-version-online-python/intro-pres.html#variabler",
    "title": "Introduktion Programmering 1, indval",
    "section": "Variabler",
    "text": "Variabler\nEn variabel är ett “namn” på ett värde. Kan även kallas för en identifierare.\n\n# Detta program skrivs i en fil som sparas.\n# Filen skapas i Idle: File -&gt; New File\n# och namnges till fartberäkning\nsträcka = 103  # Sträckan i meter\ntid = 13.2     # Tiden i sekunder\nfart = sträcka / tid\n\nprint(f\"Fart = {fart:.1f} m/s\")\n# Skriver ut Fart = 7.8 m/s\n\nFart = 7.8 m/s\n\n\n\nVariabler kan innehålla andra saker än tal; man säger att även detta är värden."
  },
  {
    "objectID": "pr1/python/intro/pres-version-online-python/intro-pres.html#variabeltyper",
    "href": "pr1/python/intro/pres-version-online-python/intro-pres.html#variabeltyper",
    "title": "Introduktion Programmering 1, indval",
    "section": "Variabeltyper",
    "text": "Variabeltyper\n\nNågra vanliga typer av variabler är  string (sträng), int (heltal) och float (tal med decimaler).\n\n\nPython kan skriva ut variabeltypen för en given variabel.\n\n\n\nett_heltal = 5\nett_flyttal = 2.9\nen_sträng = \"En sträng\"\nprint(type(ett_heltal))\nprint(type(ett_flyttal))\nprint(type(en_sträng))\n\n&lt;class 'int'&gt;\n&lt;class 'float'&gt;\n&lt;class 'str'&gt;"
  },
  {
    "objectID": "pr1/python/intro/pres-version-online-python/intro-pres.html#variabler-i-datorminnet",
    "href": "pr1/python/intro/pres-version-online-python/intro-pres.html#variabler-i-datorminnet",
    "title": "Introduktion Programmering 1, indval",
    "section": "Variabler i datorminnet",
    "text": "Variabler i datorminnet\n\nNär en variabel tilldelas ett värde kommer detta värde att sparas på en plats i datorns minne. När variabeln adresseras kommer namnet att hänvisa till denna minnesplats."
  },
  {
    "objectID": "pr1/python/intro/pres-version-online-python/intro-pres.html#några-regler-för-variabelnamn",
    "href": "pr1/python/intro/pres-version-online-python/intro-pres.html#några-regler-för-variabelnamn",
    "title": "Introduktion Programmering 1, indval",
    "section": "Några regler för variabelnamn",
    "text": "Några regler för variabelnamn\n\n\nAlla bokstavstecken och siffror får användas\n\n\n\n\nPython gör skillnad på versaler och gemener\n\n\n\n\nVariabelnamn kan inte börja med en siffra\n\n\n\n\nVariabelnamn kan inte innehålla mellanslag\n\n\n\n\nVariabelnamn kan inte innehålla bindestreck"
  },
  {
    "objectID": "pr1/python/intro/pres-version-online-python/intro-pres.html#några-regler-för-variabelnamn-forts.",
    "href": "pr1/python/intro/pres-version-online-python/intro-pres.html#några-regler-för-variabelnamn-forts.",
    "title": "Introduktion Programmering 1, indval",
    "section": "Några regler för variabelnamn (forts.)",
    "text": "Några regler för variabelnamn (forts.)\n\n\n\n\n\nVariabelnamn bör inledas med en gemen (“liten”) bokstav\n\n\n\n\nVariabelnamn bör vara uttrycksfulla, dvs beskriva vad de står för\n\n\n\n\nOrd separeras, t ex längd_rekt = 5\n\n\n\n\nLänk: Tillåtna namn på variabler"
  },
  {
    "objectID": "pr1/python/intro/pres-version-online-python/intro-pres.html#utskrifter-i-python",
    "href": "pr1/python/intro/pres-version-online-python/intro-pres.html#utskrifter-i-python",
    "title": "Introduktion Programmering 1, indval",
    "section": "Utskrifter i Python",
    "text": "Utskrifter i Python\n\n\n\nUtskrift av sträng\n\nhello_string = \"Hello, world\"\nprint(hello_string)\n\nHello, world\n\n\n\n\n\n\n\nUtskrift av sträng och tal\n\npris = 10\nprint(f\"Priset är {pris} kr.\")\n\nPriset är 10 kr.\n\n\n\n\n\nUtskrift av heltal\n\npris = 10\nprint(pris)\n\n10\n\n\n\n\n\n\n\nAvrundning\n\nmy_float = 2/3\nprint(f\"{my_float:.2f}\")\n\n0.67\n\n\n\n\n\nNär “fast” text ska skrivas ut tillsammans med en variabel används en s.k f-string. Det står för formatted string literal."
  },
  {
    "objectID": "pr1/python/intro/pres-version-online-python/intro-pres.html#formaterad-utskrift",
    "href": "pr1/python/intro/pres-version-online-python/intro-pres.html#formaterad-utskrift",
    "title": "Introduktion Programmering 1, indval",
    "section": "Formaterad utskrift",
    "text": "Formaterad utskrift\nEn teckensträng har en en given textbredd. Det tydliggörs med utfyllnadstecken.\n\ns1 = \"Kalle\"\ns2 = \"Anka\"\nprint(f\"{s1:*&lt;13}\")      # Textbredd 13, vänsterjusterat\nprint(f\"{s1:*&gt;13}\")      # Textbredd 13, högerjusterat\nprint(f\"{s1:*^13}\")      # Textbredd 13, centrerat\nprint(s1.rjust(13, \"*\")) # Finns även ljust och center\nprint(s1.ljust(13) + s2) # Inget utfyllnadstecken!\n\n\n\nKalle********\n********Kalle\n****Kalle****\n********Kalle\nKalle        Anka\n\n\n\nPå rad 7 syns att vi kan slå ihop (konkatenera) två strängar med operatorn +."
  },
  {
    "objectID": "pr1/python/intro/pres-version-online-python/intro-pres.html#sträng-med-radbrytning",
    "href": "pr1/python/intro/pres-version-online-python/intro-pres.html#sträng-med-radbrytning",
    "title": "Introduktion Programmering 1, indval",
    "section": "Sträng med radbrytning",
    "text": "Sträng med radbrytning\nFör att skriva ut en sträng på flera används ett s.k “flykttecken” (escape character).\n\nprint(\"Här är en text\\npå två rader\")\n\nHär är en text\npå två rader\n\n\n\nDetta kan användas tillsammans med textbredden.\n\nprint(f\"Detta är en högerjusterad text\\n{'på flera rader':*&gt;30}\")\n\nDetta är en högerjusterad text\n****************på flera rader\n\n\n\n\n\n\n\n\nDet finns flera exempel på escape characters på denna länk."
  },
  {
    "objectID": "pr1/python/intro/pres-version-online-python/intro-pres.html#justering-av-tal",
    "href": "pr1/python/intro/pres-version-online-python/intro-pres.html#justering-av-tal",
    "title": "Introduktion Programmering 1, indval",
    "section": "Justering av tal",
    "text": "Justering av tal\n\nTabeller blir mer lättlästa om ental står under ental, tiondel under tiondel osv.\n\n\n\na = 10.5; b = 2.38\nc = 2.3;  d = 0.1\nprint(f\"{a:6.2f}\\t\\t{c:6.2f}\\n{b:6.2f}\\t\\t{d:6.2f}\")\nprint(\"----------------------\");\nprint(f\"{(a+b):6.2f}\\t\\t{(c+d):6.2f}\")\n\n 10.50        2.30\n  2.38        0.10\n----------------------\n 12.88        2.40\n\n\n\n\nObservera att beräkningarna sker mellan måsvingarna!"
  },
  {
    "objectID": "pr1/python/intro/pres-version-online-python/intro-pres.html#sammanfattning",
    "href": "pr1/python/intro/pres-version-online-python/intro-pres.html#sammanfattning",
    "title": "Introduktion Programmering 1, indval",
    "section": "Sammanfattning",
    "text": "Sammanfattning\n\n\n\nEtt datorprogram är en följd av instruktioner.\n\n\n\n\nDessa instruktioner skrivs i ett programmeringsspråk.\n\n\n\n\nI Python kan korta kodavsnitt skrivas i konsolen, medan en editor används för att skriva och spara program.\n\n\n\n\nI datorprogram kan användas kommentarer för att det ska bli mer lättläst. För Python gäller tecknet # inleder kommentaren # Kommentar\n\n\n\n\nFör att lagra värden i ett program används variabler.\n\n\n\n\nVariabelns typ beror på vilket sorts värde som lagras."
  },
  {
    "objectID": "pr1/python/intro/pres-version-online-python/intro-pres.html#sammanfattning-forts.",
    "href": "pr1/python/intro/pres-version-online-python/intro-pres.html#sammanfattning-forts.",
    "title": "Introduktion Programmering 1, indval",
    "section": "Sammanfattning (forts.)",
    "text": "Sammanfattning (forts.)\n\n\n\nDet finns regler och konventioner för namngivning av variabler.\n\n\n\n\nFör att skriva ut variabler i Python används en funktion som heter print.\n\n\n\n\nMed print går det att styra hur utskriften sker, t ex med avseende på radbrytning, textjustering och antal decimaler för ett tal.\n\n\n\n\nUttryck kan evalueras i en sträng i Python med f-string.\n\nprint(f\"Talet är {2+2}\") # Talet är 4"
  },
  {
    "objectID": "pr1/python/villkor/presentation/index.html",
    "href": "pr1/python/villkor/presentation/index.html",
    "title": "Presentation: Villkor",
    "section": "",
    "text": "Presentation på hela skärmen",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Presentationer, Python",
      "Presentation: Villkor"
    ]
  },
  {
    "objectID": "pr1/python/villkor/presentation/index.html#uppgifter",
    "href": "pr1/python/villkor/presentation/index.html#uppgifter",
    "title": "Presentation: Villkor",
    "section": "Uppgifter",
    "text": "Uppgifter\nUppgifterna 7 – 11 i dokumentet Uppgifter Pr1, utskrift och villkor",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Presentationer, Python",
      "Presentation: Villkor"
    ]
  },
  {
    "objectID": "pr1/python/listor/presentation/index.html#uppgifter",
    "href": "pr1/python/listor/presentation/index.html#uppgifter",
    "title": "Presentation: Listor",
    "section": "Uppgifter",
    "text": "Uppgifter\nUppgifterna i dokumentet Uppgifter Pr1, listor",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Presentationer, Python",
      "Presentation: Listor"
    ]
  },
  {
    "objectID": "pr1/python/egna-datatyper/presentation/index.html#uppgifter",
    "href": "pr1/python/egna-datatyper/presentation/index.html#uppgifter",
    "title": "Presentation: Egna datatyper i Python",
    "section": "Uppgifter",
    "text": "Uppgifter\nUppgifterna i dokumentet Uppgifter Pr1, Egna datatyper",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Presentationer, Python",
      "Presentation: Egna datatyper i Python"
    ]
  },
  {
    "objectID": "pr1/python/klasser-och-metoder/presentation/klasser-och-metoder.html#dagens-mål",
    "href": "pr1/python/klasser-och-metoder/presentation/klasser-och-metoder.html#dagens-mål",
    "title": "Klasser och metoder i Python",
    "section": "Dagens mål",
    "text": "Dagens mål\n\nAtt kunna skapa en klass och knyta några funktioner till denna\nAtt tillämpa metoder på objekt\nAtt känna till vad self-parametern är\nAtt kunna skicka objekt för vidare process i funktioner"
  },
  {
    "objectID": "pr1/python/klasser-och-metoder/presentation/klasser-och-metoder.html#klasser-i-python",
    "href": "pr1/python/klasser-och-metoder/presentation/klasser-och-metoder.html#klasser-i-python",
    "title": "Klasser och metoder i Python",
    "section": "Klasser i Python",
    "text": "Klasser i Python\n\n\n\n\nVi har tidigare gått igenom hur egna datatyper (klasser) kan skapas. Till dessa knöt vi variabler, t ex ett namn eller ett pris.\nDet går även att knyta funktioner till dessa datatyper. Det gör att objektet kan “göra” saker, t ex ett objekt bil tutar, eller att någon egenskap förändras, t ex hastigheten, förändras."
  },
  {
    "objectID": "pr1/python/klasser-och-metoder/presentation/klasser-och-metoder.html#deklarera-en-metod",
    "href": "pr1/python/klasser-och-metoder/presentation/klasser-och-metoder.html#deklarera-en-metod",
    "title": "Klasser och metoder i Python",
    "section": "Deklarera en metod",
    "text": "Deklarera en metod\nVi kan deklarera och använda en klass Car på det här sättet:\n\nclass Car:\n  speed = 0\n  \n  # Metod\n  def set_speed(self, new_speed):\n    self.speed = new_speed\n    \nmy_car = Car()\nyour_car = Car()\nmy_car.set_speed(100)\nyour_car.set_speed(70)\n\nprint(f\"my_car speed: {my_car.speed}, your_car speed: {your_car.speed}\")\n\nSista raden skriver ut my_car speed: 100, your_car speed: 70"
  },
  {
    "objectID": "pr1/python/klasser-och-metoder/presentation/klasser-och-metoder.html#parametern-self",
    "href": "pr1/python/klasser-och-metoder/presentation/klasser-och-metoder.html#parametern-self",
    "title": "Klasser och metoder i Python",
    "section": "Parametern self",
    "text": "Parametern self\nSom vi såg så håller Python reda på respektive bils fart.\nDetta vet Python pga parametern self i metoden:\ndef set_speed(self, new_speed):\nVarje instans har ett ID-nummer. Detta skickas till metoderna som en referens för identifiering.\ndef set_speed(self, new_speed):\n    self.speed = new_speed\n\nmy_car = Car()\nmy_car.set_speed(100)\nID-numret skickas till metoden som ett osynligt argument. Alla metoder måste ha parametern self som första parameter."
  },
  {
    "objectID": "pr1/python/klasser-och-metoder/presentation/klasser-och-metoder.html#exempel",
    "href": "pr1/python/klasser-och-metoder/presentation/klasser-och-metoder.html#exempel",
    "title": "Klasser och metoder i Python",
    "section": "Exempel",
    "text": "Exempel\n\n\n\nI en tidigare presentation fanns exempel på en tänkt spelkod:\nitems = [\"Klocka\", \"Kikare\", \"Termometer\"]\nfor item in items:\n    if item.is_boostable:\n      item.boost()\n      print(f\"Din {item} är nu boostad ✅\")\n    else:\n      print(f\"{item} gick inte att boosta ❌\")"
  },
  {
    "objectID": "pr1/python/klasser-och-metoder/presentation/klasser-och-metoder.html#exempel-1",
    "href": "pr1/python/klasser-och-metoder/presentation/klasser-och-metoder.html#exempel-1",
    "title": "Klasser och metoder i Python",
    "section": "Exempel",
    "text": "Exempel\nImplementationen skulle kunna se ut så här:\nclass Item:\n  is_boostable = False\n  is_boosted = False\n\n  def boost(self):\n    if self.is_boostable:\n      self.is_boosted = True\n\nklocka = Item()  # Skapa på samma sätt kikare och termometer\nkikare.boostable = True\nitems = [klocka, kikare, termometer]\n\nfor item in items:\n    if item.is_boostable:\n      item.boost()\n      print(f\"Din {item} är nu boostad ✅\")     # För att `item` ska skriva\n    else:                                       # något vettigt måste sådan\n      print(f\"{item} gick inte att boosta ❌\")  # funktionalitet läggas in."
  },
  {
    "objectID": "pr1/python/klasser-och-metoder/presentation/klasser-och-metoder.html#metoden-__init__",
    "href": "pr1/python/klasser-och-metoder/presentation/klasser-och-metoder.html#metoden-__init__",
    "title": "Klasser och metoder i Python",
    "section": "Metoden __init__",
    "text": "Metoden __init__\nFör att tilldela värden till en instans i samband med att den skapas så kan man använda en metod som heter __init__\n\nclass Car:\n  def __init__(self, brand, mileage):\n    self.brand = brand\n    self.mileage = mileage\n\nmy_car = Car(\"Volvo\", 1200)\nprint(f\"Märke: {my_car.brand}, Miltal: {my_car.mileage}\")\n\n\n\n\nSkriver ut: Märke: Volvo, Miltal: 1200, vi har alltså initierat ett Car-objekt med dessa värden med hjälp av den fördefinierade metoden __init__"
  },
  {
    "objectID": "pr1/python/klasser-och-metoder/presentation/klasser-och-metoder.html#metoden-__str__",
    "href": "pr1/python/klasser-och-metoder/presentation/klasser-och-metoder.html#metoden-__str__",
    "title": "Klasser och metoder i Python",
    "section": "Metoden __str__",
    "text": "Metoden __str__\nIbland vill man kunna skriva ut information om objekt med en kort print-sats, t ex print(my_car). Då kan metoden __str__ användas.\n\nclass Car:\n  def __init__(self, brand, mileage):\n    self.brand = brand\n    self.mileage = mileage\n\n  def __str__(self):\n    return (f\"Märke: {self.brand}, Miltal: {self.mileage}\")\n\nmy_car = Car(\"Volvo\", 1200)\nprint(my_car)\n\nSista raden skriver ut Märke: Volvo, Miltal: 1200\nUtskriftssträngen definieras av __str__-metoden."
  },
  {
    "objectID": "pr1/python/klasser-och-metoder/presentation/klasser-och-metoder.html#statiska-metoder",
    "href": "pr1/python/klasser-och-metoder/presentation/klasser-och-metoder.html#statiska-metoder",
    "title": "Klasser och metoder i Python",
    "section": "Statiska metoder",
    "text": "Statiska metoder\nEn statisk metod är en funktion som är knuten till en klass, men inte till ett objekt.\n\nclass Age:\n  def __init__(self, age):\n    self.age = age\n  \n  def __str__(self):\n    return str(self.age)\n  \n  @staticmethod # En funktion som hör till klassen, men inte till ett objekt\n  def create_from_birthyear(year):\n    age = 2024 - year\n    return Age(age)\n\nage_Kalle = Age(18)\nage_Linda = Age.create_from_birthyear(2002)\nprint(f\"Kalle: {age_Kalle}, Linda: {age_Linda}\")\n\nKalle: 18, Linda: 22"
  },
  {
    "objectID": "pr1/python/klasser-och-metoder/presentation/klasser-och-metoder.html#sammanfattning",
    "href": "pr1/python/klasser-och-metoder/presentation/klasser-och-metoder.html#sammanfattning",
    "title": "Klasser och metoder i Python",
    "section": "Sammanfattning",
    "text": "Sammanfattning\n\nFunktioner till en klass kallas för metoder\nMetoderna anropas på samma sätt som funktioner i allmänhet, men föregås av namnet på instansen som tillämpar den. (t ex my_item.boost())\nMetoderna tar en “osynlig referens” till instansen i form av self. Detta self måste finnas först i parameterlistan.\nEn statisk metod är en funktion som är organiserad till en klass, men inte är knuten till ett objekt. Den skapas med @staticmethod"
  },
  {
    "objectID": "pr1/python/cheat_sheet_python.html",
    "href": "pr1/python/cheat_sheet_python.html",
    "title": "Python Cheat Sheet",
    "section": "",
    "text": "Operator\nOperation\nExempel\n\n\n\n\n**\nUpphöjt till\n3 ** 2 # Resultat: 9\n\n\n%\nModulo\n9 % 2 # Resultat: 1\n\n\n//\nHeltalsdivision\n9  // 2 # Resultat: 4\n\n\n/\nDivision\n9 / 2 # Resultat: 4.5\n\n\n*\nMultiplikation\n2 * 3 # Resultat: 6\n\n\n-\nSubtraktion\n2 - 3 # Resultat: -1\n\n\n+\nAddition\n2 + 3 # Resultat: 5\n\n\n\nOperatorerna ovan är listade i prioriteringsordning.\n\n\n\n\n\nEn variabel är ett namn med ett värde knutet till sig. En variabel är av en specifik datatyp. Variabler tilldelas ett värde enligt följande exempel (datatyp inom parentes):\npris    = 10                # Datatyp int (Heltal), utan decimalpunkt\nsträcka = 4.5               # Datayp float (flyttal), med decimalpunkt\nnamn    = \"Ada\"             # Datatyp str (Sträng), teckenföljd\nis_game_on = True           # Datatyp bool (Boolesk variabel), kan anta värdena True och False\neven5   = [2, 4, 6, 8, 10]  # Datatyp list (Lista)\nuppslag = {\"a\":1, \"b\":2}    # Datatyp dict (Uppslagstabell)\nEn variabel kan förändras med t ex pris += 0.5 (nu kommer pris att ha värdet 10.5, och således också ha bytt datatyp till float). Ett annat exempel är namn += \" Lovelace\". Nu kommer namn att utgöras av strängen \"Ada Lovelace\".\nVissa datatyper går att konvertera till andra datatyper. T ex ger str(3.14) resultatet \"3.14\" (konvertering från float till str) och int(\"9\") ger resultatet 9 (konvertering från str till int).\n\n\n\nEn egendefinierad datatyp skapas med nyckelorden class. Den kan skapas och användas enligt följande:\n# Datatypen skapas\nclass Bil:\n    märke = \"\"\n    årsmodell = -1\n\n# En instans skapas\na_bil = Bil()\na_bil.märke = \"Volvo\"\na_bil.årsmodell = 2021\n\n# Informationen kan läsas enligt\nprint(f\"Variabeln a_bil är en bil av märket {a_bil.märke} \", end=\"\")\nprint(f\"och årsmodell {a_bil.årsmodell}\")\n\n\n\n\nFör att skriva ut något till konsolen kan en print-sats användas. Exempel:\nprint(\"Hello, world\") # Skriver ut: Hello, world\nfavorite_number = 42\nprint(favorite_number) # Skriver ut: 42\nprint(f\"Mitt favorittal är {favorite_number}, förstås.\")\n# Skriver ut: Mitt favorittal är 42, förstås.\n\n\n\nEtt program kan vänta på indata från konsolen genom funktionen input. Denna funktion returnerar alltid en sträng (str). Exempel:\ngiven_name = input(\"Ange ditt förnamn -&gt; \")\nprint(f\"Hej, {given_name}!\")\n\n\n\nFöljande tilldelningar görs: a = -2, b = a och c = 0. Då kan dessa variabler jämföras t ex enligt följande:\n\n\n\nOperator\nOperation\nResultat\n\n\n\n\nLika med\na == b\nTrue\n\n\nSkilt från\na != b\nFalse\n\n\nStörre än\na &gt; b\nFalse\n\n\nMindre än\na &lt; c\nTrue\n\n\nStörre än eller lika med\na &gt;= b\nTrue\n\n\nMindre än eller lika med\na &lt;= c\nTrue\n\n\n\nDet går även att jämföra flera variabler i en följd, t ex a == b &lt; c, vilket returnar True.\n\n\n\nDet finns tre inbyggda logiska operatorer i Python: and, or och not. Följande tilldelningar görs: a = True, b = False, c = True och d = False.\n\n\n\nOperator\nOperation\nResultat\n\n\n\n\nand\na and c\nTrue\n\n\nand\na and b\nFalse\n\n\nor\na or b\nTrue\n\n\nor\nb or d\nFalse\n\n\nnot\nnot b\nTrue\n\n\nnot\nnot a\nFalse\n\n\n\nDet går att tillämpa flera logiska operatorer i en följd, t ex (a and not b) or (a and d), vilket returnerar True.\n\n\n\nI Python prövas ett villkor med if-satser. Syntaxen är\nif &lt;booleskt_uttryck_1&gt;:\n    &lt;gör något om booleskt_uttryck_1 är True&gt;\nelif &lt;booleskt_uttryck_2&gt;:\n    &lt;Om inte booleskt_uttryck_1 var True, gör något annat om booleskt_uttryck_2\n    är True&gt;\nelse:\n    &lt;Gör något annat om inget av de tidigare prövade booleska uttrycken var True&gt;\nDetta kan exemplifieras i följande program:\nmy_number = 42\nif my_number &gt; 100:\n    print(\"Talet är större än hundra.\")\nelif my_number &gt;= 0:\n    print(\"Talet är större än eller lika med noll\")\nelse:\n    print(\"Talet är negativt\")\n# Programmet skriver ut: Talet är större än eller lika med noll.\n\n\n\n\n\nI en loop kan kod processas flera gånger. Exempel:\na  = 0\nwhile a &lt; 5:\n    print(a, end=\" \")\n    a += 1\n# Skriver ut 0 1 2 3 4\nDet går att kontrollera hur loopen körs genom nyckelorden break (avbryter aktuell loop) och continue (startar om loopen från början). Exempel:\na = 0\nwhile True:\n    if a == 5:\n        a = 7\n        continue\n    if a == 9:\n        break\n    print(a, end=\" \")\n    a += 1\n# Skriver ut: 0 1 2 3 4 7 8\n\n\n\nSe avsnitt Listor, underavsnitt Loopa genom listor. Nyckelorden break och continue fungerar på samma sätt i for-loopar som i while-loopar.\n\n\n\n\n\n\n\n\nLåt lst = [10, 20, 30, 40, 50]. Då gäller att lst[0] har värdet 10 och lst[1] har värdet 20 osv. Det gäller också att lst[-1] har värdet 50 och lst[-2] har värdet 40 osv.\nDet går att komma åt delar av listan går det att göra\nlst[2:4]   # Resultat: [30, 40] (Elementen mellan två index)\nlst[2:]    # Resultat: [30, 40, 50] (Elementen fr o m index nr. 2)\nlst[:4]    # Resultat: [10, 20, 30, 40] (Elementen till index nr. 4 (men inte inklusive detta))\nlst[1:4:2] # Resultat: [20, 40] (Vartannat element mellan två index)\nlst[::-1]  # Resultat: [50, 40, 30, 20, 10] (Baklänges)\n\n\n\nEn lista kan skapas med den inbyggda funktionen range. T ex long_list = list(range(100, 1000, 2)). Detta kommer att skapa listan [100, 102, 104,..., 998].\n\n\n\nAntalet element i en lista erhålls med den inbyggda funktionen len. Exempel:\nlst = list(range(100, 1000, 2))\nprint(len(lst)) # Skriver ut antalet element: 450\n\n\n\nFörekomsten av ett element i en lista kan kontrolleras enligt följande:\nlong_list = list(range(100, 1000, 2))\n500 in long_list # Returnerar True\n501 in long_list # Returnerar False\n\n\n\nEn lista kan gås igenom element för element i en for-loop enligt fäljande:\nlst = list(range(5, 0, -1)) # Skapar listan [5, 4, 3, 2, 1]\nfor i in lst:\n    print(i, end=\" \")\n# Matar ut: 5 4 3 2 1\n\n\n\nFöljande exempel visar några tilläggs- och borttagningsoperationer:\nlst = [10, 20, 30, 40]\nlst.append(50) # lst är nu [10, 20, 30, 40, 50]\nlst.remove(30) # lst är nu [10, 20, 40, 50]\ndel(lst[1])    # lst är nu [10, 40, 50]\nlst.pop()      # Returnerar 50, lst är nu [10, 40]\na = lst.pop()  # a är nu 40, lst är nu [10]\n\n\n\nFöljande exempel visar hur en lista kan sorteras\nlst = [5, 3, 10, -1, 8]\nsorted(lst) # Returnerar [-1, 3, 5, 8, 10]; lst är fortfarande [5, 3, 10, -1, 8]\nlst.sort()  # Returnerar inget, lst är ändrad till [-1, 3, 5, 8, 10]\nlst.sort(reverse=True) # lst är nu [10, 8, 5, 3, -1]\n\n\n\n\nEn uppslagstabell fungerar som en lista, men istället för numrerade index så har den nyckel:värde-par. Nyckeln kan vara vara av vilken immuterbar, datatyp som helst (t ex en sträng eller ett tal), värdet kan vara av vilken datatyp som helst, inklusive egendefinierade datatyper. Exempel:\nmy_dict = {\"namn\": \"Anna\",\n           \"ålder\": 25,\n           \"längd\": 1.75}\n\n# Loopar genom uppslagstabellen\nfor key, value in my_dict.items():\n    print(f\"{key}: {value}\", end=\", \")\n    # Skriver ut \"namn: Anna, ålder:25, längd:1.75, \"\n\n# Lägger till en ny nyckel med värde i form av en lista\nmy_dict[\"värden\"] = [1, 2, 3] \n\n# Raderar nyckeln \"längd\"\ndel my_dict[\"längd\"]\n\n# Alternativ loop genom uppslagstabellens nycklar\nfor key in my_dict.keys():\n    print(f\"{key}: {my_dict[key]}\")\n    # Skriver ut:\n    # namn: Anna\n    # ålder: 25\n    # värden: [1, 2, 3]\n\n# Kontroll av förekomsten av en nyckel:\n\"värden\" in my_dict # Returnerar True\n\"längd\" in my_dict  # Returnerar False\n\n\n\n\nEn sträng (datatyp str) kan i flera flera fall hanteras som en lista. Exempel: str1 = \"abc 123\". Då gäller att str1[1] innehåller \"b\" och str1[-1] innehåller \"3\". Däremot går det inte att utföra str1[-1] = 4; det ger ett felmeddelande eftersom strängar inte är muterbara. Antalet tecken i en sträng erhålls på samma sätt som antalet element i en lista med funktionen len; t ex ger len(str1) returvärdet 7.\nDelsträngar fungerar på samma sätt som att komma åt delar av en lista; se rubriken Listor, underrubrik Åkomst av element ovan.\n\n\nI följande exempel är följande deklaration gjord: str1 = \"Detta är en sträng som består av 42 tecken\"\n\n\n\n\n\n\n\n\n\nMetod\nExempel\nResultat\nKommentar\n\n\n\n\n.count()\nstr1.count(\"e\")\n2\nGer antalet tecken av den specificerade sorten. Det går även att söka på en följd av tecken, då måste hela följden matchas för att räknas\n\n\n.upper()\nstr1.upper()\n\"DETTA ÄR EN STRÄNG SOM BESTÅR AV 42 TECKEN\"\nReturnerar strängen, där de alfanumeriska tecknen är versaler. str1 är oförändrad.\n\n\n.lower()\nstr1.lower()\n\"detta är en sträng som består av 42 tecken\"\nReturnerar strängen, där de alfanumeriska tecknen är gemener. str1 är oförändrad.\n\n\n.title()\nstr1.title()\n\"Detta Är En Sträng Som Består Av 42 Tecken\"\nKonverterar det första tecknet i varje ord till versal. str1 är oförändrad.\n\n\n.strip()\nstr1.strip()\n\"Detta är en sträng som består av 42 tecken\"\nTar bort mellanslag i början och i slutet av strängen (finns inga sådana i den aktuella strängen). str1 är oförändrad.\n\n\n.replace()\nstr1.replace(\"42\", \"många\")\n\"Detta är en sträng som består av många tecken\"\nErsätter ett tecken, eller en följd av tecken, med andra tecken. str1 är oförändrad.\n\n\n.split()\nstr1.split()\n['Detta', 'är', 'en', 'sträng', 'som', 'består', 'av', '42', 'tecken']\nGör om strängen till ord i en lista. Separatortecknet är mellanslag som standard. str1 är oförändrad.\n\n\n.index()\nstr1.index(\"a\")\n4\nReturnerar första positionen av ett tecken eller en teckenföljd. str1 är oförändrad.\n\n\n.isalnum()\n\"abc123\".isalnum()\nTrue\nReturnerar True om alla tecken som kontrolleras är alfanumeriska, dvs bokstäver eller siffror; annars False.\n\n\n.isalpha()\n\"abc123\".isalpha()\nFalse\nReturnerar True om alla tecken som kontrolleras är bokstäver, annars False.\n\n\n.isdigit()\n\"42\".isdigit()\nTrue\nReturnerar True om alla tecken som kontrolleras är siffror, annars False.\n\n\n\n\n\n\n\nEn funktion i är ett kodblock som kan anropas och processas som en separat del i programmet. Den kan, men behöver inte, returnera ett värde (tal, sträng, lista,…).\n\n\ndef greet(name):\n    print(f\"Hej {name}!\")\ngreet(\"Alice\") # Funktionen körs, och skriver ut Hej Alice!\n\n\n\ndef divide(divisor, dividend):\n    if dividend == 0:\n        return(\"Odefinierat!\")\n    else:\n        return divisor / dividend\na = divide(10, 5) # a är nu 2.0\na = divide(10, 0) # a är nu \"Odefinierat!\"\n\n\n\n\nFunktioner som har med slumptal att göra finns i en separat modul, nämligen random.\n\n\nimport random as rand\nrandom_int = rand.randint(0, 99)\n# random_int kommer nu att innehålla ett slumptal mellan, och inklusive, 0 och 99\n\n\n\nimport random as rand\nrandom_float = rand.random()\n# random_float kommer nu att innehålla ett slumpmässigt flyttal mellan 0 och 1 (dock ej inklusive 1).\n\n\n\nimport random as rand\nlst = list(range(0, 10)) \nrand.shuffle(lst) # lst kommer nu att vara blandad\n\n\n\nimport random as rand\nlst = list(range(0, 10))\nrand.choice(lst)\n# Returnerar ett av talen i lst, taget på måfå. lst är oförändrad.",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Python Cheat Sheet"
    ]
  },
  {
    "objectID": "pr1/python/cheat_sheet_python.html#matematiska-operatorer",
    "href": "pr1/python/cheat_sheet_python.html#matematiska-operatorer",
    "title": "Python Cheat Sheet",
    "section": "",
    "text": "Operator\nOperation\nExempel\n\n\n\n\n**\nUpphöjt till\n3 ** 2 # Resultat: 9\n\n\n%\nModulo\n9 % 2 # Resultat: 1\n\n\n//\nHeltalsdivision\n9  // 2 # Resultat: 4\n\n\n/\nDivision\n9 / 2 # Resultat: 4.5\n\n\n*\nMultiplikation\n2 * 3 # Resultat: 6\n\n\n-\nSubtraktion\n2 - 3 # Resultat: -1\n\n\n+\nAddition\n2 + 3 # Resultat: 5\n\n\n\nOperatorerna ovan är listade i prioriteringsordning.",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Python Cheat Sheet"
    ]
  },
  {
    "objectID": "pr1/python/cheat_sheet_python.html#variabler-och-datatyper",
    "href": "pr1/python/cheat_sheet_python.html#variabler-och-datatyper",
    "title": "Python Cheat Sheet",
    "section": "",
    "text": "En variabel är ett namn med ett värde knutet till sig. En variabel är av en specifik datatyp. Variabler tilldelas ett värde enligt följande exempel (datatyp inom parentes):\npris    = 10                # Datatyp int (Heltal), utan decimalpunkt\nsträcka = 4.5               # Datayp float (flyttal), med decimalpunkt\nnamn    = \"Ada\"             # Datatyp str (Sträng), teckenföljd\nis_game_on = True           # Datatyp bool (Boolesk variabel), kan anta värdena True och False\neven5   = [2, 4, 6, 8, 10]  # Datatyp list (Lista)\nuppslag = {\"a\":1, \"b\":2}    # Datatyp dict (Uppslagstabell)\nEn variabel kan förändras med t ex pris += 0.5 (nu kommer pris att ha värdet 10.5, och således också ha bytt datatyp till float). Ett annat exempel är namn += \" Lovelace\". Nu kommer namn att utgöras av strängen \"Ada Lovelace\".\nVissa datatyper går att konvertera till andra datatyper. T ex ger str(3.14) resultatet \"3.14\" (konvertering från float till str) och int(\"9\") ger resultatet 9 (konvertering från str till int).\n\n\n\nEn egendefinierad datatyp skapas med nyckelorden class. Den kan skapas och användas enligt följande:\n# Datatypen skapas\nclass Bil:\n    märke = \"\"\n    årsmodell = -1\n\n# En instans skapas\na_bil = Bil()\na_bil.märke = \"Volvo\"\na_bil.årsmodell = 2021\n\n# Informationen kan läsas enligt\nprint(f\"Variabeln a_bil är en bil av märket {a_bil.märke} \", end=\"\")\nprint(f\"och årsmodell {a_bil.årsmodell}\")",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Python Cheat Sheet"
    ]
  },
  {
    "objectID": "pr1/python/cheat_sheet_python.html#print-satsen",
    "href": "pr1/python/cheat_sheet_python.html#print-satsen",
    "title": "Python Cheat Sheet",
    "section": "",
    "text": "För att skriva ut något till konsolen kan en print-sats användas. Exempel:\nprint(\"Hello, world\") # Skriver ut: Hello, world\nfavorite_number = 42\nprint(favorite_number) # Skriver ut: 42\nprint(f\"Mitt favorittal är {favorite_number}, förstås.\")\n# Skriver ut: Mitt favorittal är 42, förstås.",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Python Cheat Sheet"
    ]
  },
  {
    "objectID": "pr1/python/cheat_sheet_python.html#input-satsen",
    "href": "pr1/python/cheat_sheet_python.html#input-satsen",
    "title": "Python Cheat Sheet",
    "section": "",
    "text": "Ett program kan vänta på indata från konsolen genom funktionen input. Denna funktion returnerar alltid en sträng (str). Exempel:\ngiven_name = input(\"Ange ditt förnamn -&gt; \")\nprint(f\"Hej, {given_name}!\")",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Python Cheat Sheet"
    ]
  },
  {
    "objectID": "pr1/python/cheat_sheet_python.html#jämförelseoperatorer",
    "href": "pr1/python/cheat_sheet_python.html#jämförelseoperatorer",
    "title": "Python Cheat Sheet",
    "section": "",
    "text": "Följande tilldelningar görs: a = -2, b = a och c = 0. Då kan dessa variabler jämföras t ex enligt följande:\n\n\n\nOperator\nOperation\nResultat\n\n\n\n\nLika med\na == b\nTrue\n\n\nSkilt från\na != b\nFalse\n\n\nStörre än\na &gt; b\nFalse\n\n\nMindre än\na &lt; c\nTrue\n\n\nStörre än eller lika med\na &gt;= b\nTrue\n\n\nMindre än eller lika med\na &lt;= c\nTrue\n\n\n\nDet går även att jämföra flera variabler i en följd, t ex a == b &lt; c, vilket returnar True.",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Python Cheat Sheet"
    ]
  },
  {
    "objectID": "pr1/python/cheat_sheet_python.html#logiska-operatorer",
    "href": "pr1/python/cheat_sheet_python.html#logiska-operatorer",
    "title": "Python Cheat Sheet",
    "section": "",
    "text": "Det finns tre inbyggda logiska operatorer i Python: and, or och not. Följande tilldelningar görs: a = True, b = False, c = True och d = False.\n\n\n\nOperator\nOperation\nResultat\n\n\n\n\nand\na and c\nTrue\n\n\nand\na and b\nFalse\n\n\nor\na or b\nTrue\n\n\nor\nb or d\nFalse\n\n\nnot\nnot b\nTrue\n\n\nnot\nnot a\nFalse\n\n\n\nDet går att tillämpa flera logiska operatorer i en följd, t ex (a and not b) or (a and d), vilket returnerar True.",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Python Cheat Sheet"
    ]
  },
  {
    "objectID": "pr1/python/cheat_sheet_python.html#villkor",
    "href": "pr1/python/cheat_sheet_python.html#villkor",
    "title": "Python Cheat Sheet",
    "section": "",
    "text": "I Python prövas ett villkor med if-satser. Syntaxen är\nif &lt;booleskt_uttryck_1&gt;:\n    &lt;gör något om booleskt_uttryck_1 är True&gt;\nelif &lt;booleskt_uttryck_2&gt;:\n    &lt;Om inte booleskt_uttryck_1 var True, gör något annat om booleskt_uttryck_2\n    är True&gt;\nelse:\n    &lt;Gör något annat om inget av de tidigare prövade booleska uttrycken var True&gt;\nDetta kan exemplifieras i följande program:\nmy_number = 42\nif my_number &gt; 100:\n    print(\"Talet är större än hundra.\")\nelif my_number &gt;= 0:\n    print(\"Talet är större än eller lika med noll\")\nelse:\n    print(\"Talet är negativt\")\n# Programmet skriver ut: Talet är större än eller lika med noll.",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Python Cheat Sheet"
    ]
  },
  {
    "objectID": "pr1/python/cheat_sheet_python.html#loopar",
    "href": "pr1/python/cheat_sheet_python.html#loopar",
    "title": "Python Cheat Sheet",
    "section": "",
    "text": "I en loop kan kod processas flera gånger. Exempel:\na  = 0\nwhile a &lt; 5:\n    print(a, end=\" \")\n    a += 1\n# Skriver ut 0 1 2 3 4\nDet går att kontrollera hur loopen körs genom nyckelorden break (avbryter aktuell loop) och continue (startar om loopen från början). Exempel:\na = 0\nwhile True:\n    if a == 5:\n        a = 7\n        continue\n    if a == 9:\n        break\n    print(a, end=\" \")\n    a += 1\n# Skriver ut: 0 1 2 3 4 7 8\n\n\n\nSe avsnitt Listor, underavsnitt Loopa genom listor. Nyckelorden break och continue fungerar på samma sätt i for-loopar som i while-loopar.",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Python Cheat Sheet"
    ]
  },
  {
    "objectID": "pr1/python/cheat_sheet_python.html#dataföljder",
    "href": "pr1/python/cheat_sheet_python.html#dataföljder",
    "title": "Python Cheat Sheet",
    "section": "",
    "text": "Låt lst = [10, 20, 30, 40, 50]. Då gäller att lst[0] har värdet 10 och lst[1] har värdet 20 osv. Det gäller också att lst[-1] har värdet 50 och lst[-2] har värdet 40 osv.\nDet går att komma åt delar av listan går det att göra\nlst[2:4]   # Resultat: [30, 40] (Elementen mellan två index)\nlst[2:]    # Resultat: [30, 40, 50] (Elementen fr o m index nr. 2)\nlst[:4]    # Resultat: [10, 20, 30, 40] (Elementen till index nr. 4 (men inte inklusive detta))\nlst[1:4:2] # Resultat: [20, 40] (Vartannat element mellan två index)\nlst[::-1]  # Resultat: [50, 40, 30, 20, 10] (Baklänges)\n\n\n\nEn lista kan skapas med den inbyggda funktionen range. T ex long_list = list(range(100, 1000, 2)). Detta kommer att skapa listan [100, 102, 104,..., 998].\n\n\n\nAntalet element i en lista erhålls med den inbyggda funktionen len. Exempel:\nlst = list(range(100, 1000, 2))\nprint(len(lst)) # Skriver ut antalet element: 450\n\n\n\nFörekomsten av ett element i en lista kan kontrolleras enligt följande:\nlong_list = list(range(100, 1000, 2))\n500 in long_list # Returnerar True\n501 in long_list # Returnerar False\n\n\n\nEn lista kan gås igenom element för element i en for-loop enligt fäljande:\nlst = list(range(5, 0, -1)) # Skapar listan [5, 4, 3, 2, 1]\nfor i in lst:\n    print(i, end=\" \")\n# Matar ut: 5 4 3 2 1\n\n\n\nFöljande exempel visar några tilläggs- och borttagningsoperationer:\nlst = [10, 20, 30, 40]\nlst.append(50) # lst är nu [10, 20, 30, 40, 50]\nlst.remove(30) # lst är nu [10, 20, 40, 50]\ndel(lst[1])    # lst är nu [10, 40, 50]\nlst.pop()      # Returnerar 50, lst är nu [10, 40]\na = lst.pop()  # a är nu 40, lst är nu [10]\n\n\n\nFöljande exempel visar hur en lista kan sorteras\nlst = [5, 3, 10, -1, 8]\nsorted(lst) # Returnerar [-1, 3, 5, 8, 10]; lst är fortfarande [5, 3, 10, -1, 8]\nlst.sort()  # Returnerar inget, lst är ändrad till [-1, 3, 5, 8, 10]\nlst.sort(reverse=True) # lst är nu [10, 8, 5, 3, -1]\n\n\n\n\nEn uppslagstabell fungerar som en lista, men istället för numrerade index så har den nyckel:värde-par. Nyckeln kan vara vara av vilken immuterbar, datatyp som helst (t ex en sträng eller ett tal), värdet kan vara av vilken datatyp som helst, inklusive egendefinierade datatyper. Exempel:\nmy_dict = {\"namn\": \"Anna\",\n           \"ålder\": 25,\n           \"längd\": 1.75}\n\n# Loopar genom uppslagstabellen\nfor key, value in my_dict.items():\n    print(f\"{key}: {value}\", end=\", \")\n    # Skriver ut \"namn: Anna, ålder:25, längd:1.75, \"\n\n# Lägger till en ny nyckel med värde i form av en lista\nmy_dict[\"värden\"] = [1, 2, 3] \n\n# Raderar nyckeln \"längd\"\ndel my_dict[\"längd\"]\n\n# Alternativ loop genom uppslagstabellens nycklar\nfor key in my_dict.keys():\n    print(f\"{key}: {my_dict[key]}\")\n    # Skriver ut:\n    # namn: Anna\n    # ålder: 25\n    # värden: [1, 2, 3]\n\n# Kontroll av förekomsten av en nyckel:\n\"värden\" in my_dict # Returnerar True\n\"längd\" in my_dict  # Returnerar False",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Python Cheat Sheet"
    ]
  },
  {
    "objectID": "pr1/python/cheat_sheet_python.html#strängar-och-strängmetoder",
    "href": "pr1/python/cheat_sheet_python.html#strängar-och-strängmetoder",
    "title": "Python Cheat Sheet",
    "section": "",
    "text": "En sträng (datatyp str) kan i flera flera fall hanteras som en lista. Exempel: str1 = \"abc 123\". Då gäller att str1[1] innehåller \"b\" och str1[-1] innehåller \"3\". Däremot går det inte att utföra str1[-1] = 4; det ger ett felmeddelande eftersom strängar inte är muterbara. Antalet tecken i en sträng erhålls på samma sätt som antalet element i en lista med funktionen len; t ex ger len(str1) returvärdet 7.\nDelsträngar fungerar på samma sätt som att komma åt delar av en lista; se rubriken Listor, underrubrik Åkomst av element ovan.\n\n\nI följande exempel är följande deklaration gjord: str1 = \"Detta är en sträng som består av 42 tecken\"\n\n\n\n\n\n\n\n\n\nMetod\nExempel\nResultat\nKommentar\n\n\n\n\n.count()\nstr1.count(\"e\")\n2\nGer antalet tecken av den specificerade sorten. Det går även att söka på en följd av tecken, då måste hela följden matchas för att räknas\n\n\n.upper()\nstr1.upper()\n\"DETTA ÄR EN STRÄNG SOM BESTÅR AV 42 TECKEN\"\nReturnerar strängen, där de alfanumeriska tecknen är versaler. str1 är oförändrad.\n\n\n.lower()\nstr1.lower()\n\"detta är en sträng som består av 42 tecken\"\nReturnerar strängen, där de alfanumeriska tecknen är gemener. str1 är oförändrad.\n\n\n.title()\nstr1.title()\n\"Detta Är En Sträng Som Består Av 42 Tecken\"\nKonverterar det första tecknet i varje ord till versal. str1 är oförändrad.\n\n\n.strip()\nstr1.strip()\n\"Detta är en sträng som består av 42 tecken\"\nTar bort mellanslag i början och i slutet av strängen (finns inga sådana i den aktuella strängen). str1 är oförändrad.\n\n\n.replace()\nstr1.replace(\"42\", \"många\")\n\"Detta är en sträng som består av många tecken\"\nErsätter ett tecken, eller en följd av tecken, med andra tecken. str1 är oförändrad.\n\n\n.split()\nstr1.split()\n['Detta', 'är', 'en', 'sträng', 'som', 'består', 'av', '42', 'tecken']\nGör om strängen till ord i en lista. Separatortecknet är mellanslag som standard. str1 är oförändrad.\n\n\n.index()\nstr1.index(\"a\")\n4\nReturnerar första positionen av ett tecken eller en teckenföljd. str1 är oförändrad.\n\n\n.isalnum()\n\"abc123\".isalnum()\nTrue\nReturnerar True om alla tecken som kontrolleras är alfanumeriska, dvs bokstäver eller siffror; annars False.\n\n\n.isalpha()\n\"abc123\".isalpha()\nFalse\nReturnerar True om alla tecken som kontrolleras är bokstäver, annars False.\n\n\n.isdigit()\n\"42\".isdigit()\nTrue\nReturnerar True om alla tecken som kontrolleras är siffror, annars False.",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Python Cheat Sheet"
    ]
  },
  {
    "objectID": "pr1/python/cheat_sheet_python.html#funktioner",
    "href": "pr1/python/cheat_sheet_python.html#funktioner",
    "title": "Python Cheat Sheet",
    "section": "",
    "text": "En funktion i är ett kodblock som kan anropas och processas som en separat del i programmet. Den kan, men behöver inte, returnera ett värde (tal, sträng, lista,…).\n\n\ndef greet(name):\n    print(f\"Hej {name}!\")\ngreet(\"Alice\") # Funktionen körs, och skriver ut Hej Alice!\n\n\n\ndef divide(divisor, dividend):\n    if dividend == 0:\n        return(\"Odefinierat!\")\n    else:\n        return divisor / dividend\na = divide(10, 5) # a är nu 2.0\na = divide(10, 0) # a är nu \"Odefinierat!\"",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Python Cheat Sheet"
    ]
  },
  {
    "objectID": "pr1/python/cheat_sheet_python.html#slumptal",
    "href": "pr1/python/cheat_sheet_python.html#slumptal",
    "title": "Python Cheat Sheet",
    "section": "",
    "text": "Funktioner som har med slumptal att göra finns i en separat modul, nämligen random.\n\n\nimport random as rand\nrandom_int = rand.randint(0, 99)\n# random_int kommer nu att innehålla ett slumptal mellan, och inklusive, 0 och 99\n\n\n\nimport random as rand\nrandom_float = rand.random()\n# random_float kommer nu att innehålla ett slumpmässigt flyttal mellan 0 och 1 (dock ej inklusive 1).\n\n\n\nimport random as rand\nlst = list(range(0, 10)) \nrand.shuffle(lst) # lst kommer nu att vara blandad\n\n\n\nimport random as rand\nlst = list(range(0, 10))\nrand.choice(lst)\n# Returnerar ett av talen i lst, taget på måfå. lst är oförändrad.",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Python Cheat Sheet"
    ]
  },
  {
    "objectID": "pr1/python/strangar/presentation/index.html#uppgifter",
    "href": "pr1/python/strangar/presentation/index.html#uppgifter",
    "title": "Presentation: Strängar",
    "section": "Uppgifter",
    "text": "Uppgifter\nUppgifterna i dokumentet Uppgifter Pr1, Strängar",
    "crumbs": [
      "Home",
      "Programmering 1",
      "Presentationer, Python",
      "Presentation: Strängar"
    ]
  },
  {
    "objectID": "pr1/python/for-loopar/presentation/for-pres.html#dagens-mål",
    "href": "pr1/python/for-loopar/presentation/for-pres.html#dagens-mål",
    "title": "for-loopar i Python",
    "section": "Dagens mål",
    "text": "Dagens mål\n\nAtt känna till vad en for-loop är\nAtt kunna använda range-funktionen\nAtt känna till skillnaden mellan while- och for-loopar\nAtt kunna skriva egna små program som innehåller en for-loop."
  },
  {
    "objectID": "pr1/python/for-loopar/presentation/for-pres.html#likheter-och-skillnader-mellan-while--och-for-loopar",
    "href": "pr1/python/for-loopar/presentation/for-pres.html#likheter-och-skillnader-mellan-while--och-for-loopar",
    "title": "for-loopar i Python",
    "section": "Likheter och skillnader mellan while- och for-loopar",
    "text": "Likheter och skillnader mellan while- och for-loopar\n\n\n\n\nOfta används while-loopar när antalet varv avgörs under programkörningens gång, medan for-loopar används då det är ett känt antal varv. I vissa fall går den ena typen av loop lika bra som den andra.\nEn for-loop använder sig av en lista som loopas igenom."
  },
  {
    "objectID": "pr1/python/for-loopar/presentation/for-pres.html#enklast-möjliga-for-loop",
    "href": "pr1/python/for-loopar/presentation/for-pres.html#enklast-möjliga-for-loop",
    "title": "for-loopar i Python",
    "section": "Enklast möjliga for-loop",
    "text": "Enklast möjliga for-loop\n\n\n\n\nlista = [10, 20, 30]\nfor element in lista:\n    print(element, end=\" \")\nprint(f\"Loopen avslutas eftersom listan är slut\")\n\n10 20 30 Loopen avslutas eftersom listan är slut\n\n\n\n\n\nVariabeln element antar respektive värde i listan i tur och ordning."
  },
  {
    "objectID": "pr1/python/for-loopar/presentation/for-pres.html#längre-listor",
    "href": "pr1/python/for-loopar/presentation/for-pres.html#längre-listor",
    "title": "for-loopar i Python",
    "section": "Längre listor",
    "text": "Längre listor\nListorna behöver inte skrivas in manuellt, det är bra då loopen behöver snurra många varv. Här används range för att skapa en lista från ett värde till ett annat värde.\n\n\n\n\nfor i in range(3, 8):   # Här skapas listan\n    print(i, end=\" \")\n\n3 4 5 6 7 \n\n\n\n\n\nFunktionen range(3, 8) skapar listan [3, 4, 5, 6, 7]\nOm det hade varit en while-loop som skulle snurra fem varav skulle ett villkor och en räknare behövt sättas upp."
  },
  {
    "objectID": "pr1/python/for-loopar/presentation/for-pres.html#funktionen-range",
    "href": "pr1/python/for-loopar/presentation/for-pres.html#funktionen-range",
    "title": "for-loopar i Python",
    "section": "Funktionen range",
    "text": "Funktionen range\nExempel på hur parametrar påverkar resultatet av range\n\nlista_A = list(range(10))\nlista_B = list(range(-5, 5))\nlista_C = list(range(0, 10, 2))\nlista_D = list(range(10, 0, -1))\nprint(f\"lista_A = {lista_A}\")\nprint(f\"lista_B = {lista_B}\")\nprint(f\"lista_C = {lista_C}\")\nprint(f\"lista_D = {lista_D}\")\n\nlista_A = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nlista_B = [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]\nlista_C = [0, 2, 4, 6, 8]\nlista_D = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]"
  },
  {
    "objectID": "pr1/python/for-loopar/presentation/for-pres.html#exempel-multiplikationstabell",
    "href": "pr1/python/for-loopar/presentation/for-pres.html#exempel-multiplikationstabell",
    "title": "for-loopar i Python",
    "section": "Exempel: Multiplikationstabell",
    "text": "Exempel: Multiplikationstabell\n\n# Detta program beräknar och skriver ut \"tolvans tabell\"\nfor i in range(1, 13):\n    print(f\"{i:2.0f} * 12 = {i*12:3.0f}\")\n\n 1 * 12 =  12\n 2 * 12 =  24\n 3 * 12 =  36\n 4 * 12 =  48\n 5 * 12 =  60\n 6 * 12 =  72\n 7 * 12 =  84\n 8 * 12 =  96\n 9 * 12 = 108\n10 * 12 = 120\n11 * 12 = 132\n12 * 12 = 144"
  },
  {
    "objectID": "pr1/python/for-loopar/presentation/for-pres.html#andra-listelement-än-tal",
    "href": "pr1/python/for-loopar/presentation/for-pres.html#andra-listelement-än-tal",
    "title": "for-loopar i Python",
    "section": "Andra listelement än tal",
    "text": "Andra listelement än tal\nEn lista kan innehålla andra element än tal.\n\n\n\n\nitems = [\"Klocka\", \"Kikare\", \"Termometer\"]\nprint(\"Du har tillgång till:\", end=\" \")\nfor item in items:\n    print(item, end=\" \")\n\nDu har tillgång till: Klocka Kikare Termometer \n\n\n\n\n\nVi kommer senare att titta på hur element kan läggas till, tas bort och sorteras i listor. Det är användbart t ex i spel."
  },
  {
    "objectID": "pr1/python/for-loopar/presentation/for-pres.html#ett-tänkt-exempel",
    "href": "pr1/python/for-loopar/presentation/for-pres.html#ett-tänkt-exempel",
    "title": "for-loopar i Python",
    "section": "Ett tänkt exempel",
    "text": "Ett tänkt exempel\n\n\n\nitems = [\"Klocka\", \"Kikare\", \"Termometer\"]\nfor item in items:\n    if item.is_boostable:\n      item.boost()\n      print(f\"Din {item} är nu boostad ✅\")\n    else:\n      print(f\"{item} gick inte att boosta ❌\")\nSekvensen ovan skulle kunna ingå i ett spelprogram. Här är is_boostable en egenskap hos objektet item och boost är en metod som tillämpas. Dessa saker måste programmeraren designa själv; det är inte inbyggt i Python.\nSenare i kursen kommer vi att komma till klasser, och koppla objekt, egenskaper och metoder till dessa."
  },
  {
    "objectID": "pr1/python/for-loopar/presentation/for-pres.html#sammanfattning",
    "href": "pr1/python/for-loopar/presentation/for-pres.html#sammanfattning",
    "title": "for-loopar i Python",
    "section": "Sammanfattning",
    "text": "Sammanfattning\n\nfor-loopar används antingen när något ska göras ett förutbestämt antal gånger…\n… eller när någon funktion ska tillämpas på ett element i taget i en lista\nFunktionen range kan användas för att skapa listor\nFunktionen range ger olika utdata beroende på vilka parametrar som används"
  },
  {
    "objectID": "pr1/python/funktioner/presentation/func-pres.html#dagens-mål",
    "href": "pr1/python/funktioner/presentation/func-pres.html#dagens-mål",
    "title": "Funktioner i Python",
    "section": "Dagens mål",
    "text": "Dagens mål\n\nAtt känna till vad en funktion är för något\nAtt känna till hur en funktion anropas\nAtt kunna läsa ut vilka parametrar en funktion tar\nAtt känna till skillnaden mellan funktioner som har …\n… respektive saknar return-sats\nAtt kunna tilldela en variabel ett värde från en funktion\nAtt kunna skriva enkla funktioner …\n… såväl med som utan return"
  },
  {
    "objectID": "pr1/python/funktioner/presentation/func-pres.html#vad-är-en-funktion-i-programmering",
    "href": "pr1/python/funktioner/presentation/func-pres.html#vad-är-en-funktion-i-programmering",
    "title": "Funktioner i Python",
    "section": "Vad är en funktion i programmering?",
    "text": "Vad är en funktion i programmering?\n\n\n\n\nFunktioner används för att dela upp ett program i mindre delar. En funktion anropas från det ställe man vill den ska utföras.\nVi har redan träffat på funktioner i form av print, input och range. Nu ska vi titta på hur egna funktioner skapas."
  },
  {
    "objectID": "pr1/python/funktioner/presentation/func-pres.html#användning-av-en-enkel-funktion",
    "href": "pr1/python/funktioner/presentation/func-pres.html#användning-av-en-enkel-funktion",
    "title": "Funktioner i Python",
    "section": "Användning av en enkel funktion",
    "text": "Användning av en enkel funktion\n\n\n\nExempel: En funktion som adderar två tal:\ntal_1 = 10\ntal_2 = 20\nsumma = add(tal_1, tal_2)\nprint(f\"Summan av {tal_1} och {tal_2} är {summa}\")\n\n\n\nFunktionen add finns inte fördefinierad i Python, den måste vi skapa själva!"
  },
  {
    "objectID": "pr1/python/funktioner/presentation/func-pres.html#implementering",
    "href": "pr1/python/funktioner/presentation/func-pres.html#implementering",
    "title": "Funktioner i Python",
    "section": "Implementering",
    "text": "Implementering\nVi kan skapa och använda funktionen add enligt följande:\n\n\n\n\ndef add(a, b):     # Här\n  the_sum = a + b  # skapas\n  return the_sum   # funktionen\n\n# Huvudprogram nedan\ntal_1 = 10\ntal_2 = 20\nsumma = add(tal_1, tal_2) # Här anropas funktionen\n\nprint(f\"Summan av {tal_1} och {tal_2} är {summa}\")\n\nSumman av 10 och 20 är 30"
  },
  {
    "objectID": "pr1/python/funktioner/presentation/func-pres.html#funktioners-anatomi",
    "href": "pr1/python/funktioner/presentation/func-pres.html#funktioners-anatomi",
    "title": "Funktioner i Python",
    "section": "Funktioners anatomi",
    "text": "Funktioners anatomi\ndef add(a, b):\n  the_sum = a + b\n  return the_sum\n\nadd: Funktionens namn\na och b: Funktionens parametrar\nreturn: Det värde som funktionen lämnar som resultat\n\nFunktionen anropas t ex enligt summa = add(1, 2). Här kallas talen 1 och 2 i anropet för argument.\nVariabeln summa antar det värde som return skickar tillbaka."
  },
  {
    "objectID": "pr1/python/funktioner/presentation/func-pres.html#variabler-i-funktioner",
    "href": "pr1/python/funktioner/presentation/func-pres.html#variabler-i-funktioner",
    "title": "Funktioner i Python",
    "section": "Variabler i funktioner",
    "text": "Variabler i funktioner\nVariablerna som är deklarerade i funktioner är lokala. Det innebär att de inte är tillgängliga utanför funktionen.\nT ex är variablerna a, b och the_sum enbart tillgängliga inuti funktionen add nedan.\ndef add(a, b):\n  the_sum = a + b\n  return the_sum\n\n# Huvudprogram\nadd(1, 2)\n# Nedanstående ger ett felmeddelande eftersom\n# giltighetsområdet (omfattningen) för variabeln\n# the_sum inte räcker till denna nivå i programmet.\nprint(the_sum)"
  },
  {
    "objectID": "pr1/python/funktioner/presentation/func-pres.html#funktioners-returvärden",
    "href": "pr1/python/funktioner/presentation/func-pres.html#funktioners-returvärden",
    "title": "Funktioner i Python",
    "section": "Funktioners returvärden",
    "text": "Funktioners returvärden\nIbland saknas behov av return-värde.\n\ndef print_multabell(n):\n  # Skriver ut fem rader i multiplikationstabell n\n  for i in range(1, 6):\n    print(f\"{i:2.0f} * {n} = {i*n:3.0f}\")\n\nprint_multabell(12) # Ange önskad tabell att skriva ut här\n\n 1 * 12 =  12\n 2 * 12 =  24\n 3 * 12 =  36\n 4 * 12 =  48\n 5 * 12 =  60\n\n\nHär ser syns att en valfri multiplikationstabell kan skrivas ut, men det finns ingen variabel utanför funktionen som känner till något om multiplikationen."
  },
  {
    "objectID": "pr1/python/funktioner/presentation/func-pres.html#alla-funktioner-har-ett-returvärde",
    "href": "pr1/python/funktioner/presentation/func-pres.html#alla-funktioner-har-ett-returvärde",
    "title": "Funktioner i Python",
    "section": "Alla funktioner har ett returvärde",
    "text": "Alla funktioner har ett returvärde\n\ndef print_multabell(n):\n  # Skriver ut fem rader i multiplikationstabell n\n  for i in range(1, 6):\n    print(f\"{i:2.0f} * {n} = {i*n:3.0f}\")\n\nprint(print_multabell(12)) \n\n 1 * 12 =  12\n 2 * 12 =  24\n 3 * 12 =  36\n 4 * 12 =  48\n 5 * 12 =  60\nNone\n\n\nHär anropas funktionen, och skriver ut resultatet av den på rad 6. Vi ser att resultatet blir None."
  },
  {
    "objectID": "pr1/python/funktioner/presentation/func-pres.html#dokumentation-av-funktioner",
    "href": "pr1/python/funktioner/presentation/func-pres.html#dokumentation-av-funktioner",
    "title": "Funktioner i Python",
    "section": "Dokumentation av funktioner",
    "text": "Dokumentation av funktioner\nFunktioner bör dokumenteras. Python använder s.k docstrings för detta. Ej att förväxla med kommentarer för kodrader eller andra sekvenser i programmet!\ndef add(a, b):\n  '''\n  Funktionen adderar två tal. Ingen typkontroll sker.\n  Parameter 1: a | ett tal (int eller float)\n  Parameter 2: b | ett tal (int eller float)\n  Returvärde: summan av talen (int eller float)\n  '''\n  the_sum = a + b\n  return the_sum\nDocstrings kan användas av editorn när man skriver kod, eller i konsolen när man skriver help(add)."
  },
  {
    "objectID": "pr1/python/funktioner/presentation/func-pres.html#lämna-funktionen",
    "href": "pr1/python/funktioner/presentation/func-pres.html#lämna-funktionen",
    "title": "Funktioner i Python",
    "section": "Lämna funktionen",
    "text": "Lämna funktionen\nEn funktion lämnas när den når sista raden eller return.\ndef maximum(a, b):\n  '''\n  Funktionen returnerar det största av två tal\n  Parameter 1: a | ett tal (int eller float)\n  Parameter 2: b | ett tal (int eller float)\n  Returvärde: Det största av talen. Vid likhet returneras None.\n  '''\n\n  if a &gt; b:\n    return a\n  elif b &gt; a:\n    return b\n  return None # Onödig rad, utan return-sats returneras None ändå"
  },
  {
    "objectID": "pr1/python/funktioner/presentation/func-pres.html#sammanfattning",
    "href": "pr1/python/funktioner/presentation/func-pres.html#sammanfattning",
    "title": "Funktioner i Python",
    "section": "Sammanfattning",
    "text": "Sammanfattning\n\nFunktioner är byggstenar i program …\n… vilket ger programmet en enklare struktur\nVariablerna i en funktion är lokala\nEn funktion lämnas vid return-sats\nOm ingen return-sats finns returneras None\nEn variabel bör tilldelas ett returnerat värde\nEn funktion bör dokumenteras med en docstring"
  },
  {
    "objectID": "pr1/python/spara-data-pa-fil/presentation/spara-data-pa-fil.html#dagens-mål",
    "href": "pr1/python/spara-data-pa-fil/presentation/spara-data-pa-fil.html#dagens-mål",
    "title": "Spara data till fil i Python",
    "section": "Dagens mål",
    "text": "Dagens mål\n\nAtt kunna läsa in och skriva data från instanser av en egendefinierad datatyp på fil."
  },
  {
    "objectID": "pr1/python/spara-data-pa-fil/presentation/spara-data-pa-fil.html#json-format",
    "href": "pr1/python/spara-data-pa-fil/presentation/spara-data-pa-fil.html#json-format",
    "title": "Spara data till fil i Python",
    "section": "JSON-format",
    "text": "JSON-format\n\n\n\nVi kommer att spara datan på fil i JSON-format (JavaScript Object Notation). Det är ett vanligt sätt att representera data på i många sammanhang.\n{\n    \"namn\": \"Anna\",\n    \"ålder\": 30,\n    \"stad\": \"Stockholm\"\n}\nFör att använda JSON i Python behövs importeras en modul:\nimport json"
  },
  {
    "objectID": "pr1/python/spara-data-pa-fil/presentation/spara-data-pa-fil.html#skapa-en-egen-datatyp",
    "href": "pr1/python/spara-data-pa-fil/presentation/spara-data-pa-fil.html#skapa-en-egen-datatyp",
    "title": "Spara data till fil i Python",
    "section": "Skapa en egen datatyp",
    "text": "Skapa en egen datatyp\n\n\n\nVi kan deklarera en variabeltyp Car på det här sättet:\n\nclass Car:\n    def __init__(self, brand, price, mileage):\n        self.brand = brand\n        self.price = price\n        self.mileage = mileage\n\n\n\n\nInstanser av denna datatyp kan skapas enligt\ncar1 = Car(\"Volvo\", 200000, 10000)\ncar2 = Car(\"BMW\", 300000, 5000)\ncars = [car1, car2]"
  },
  {
    "objectID": "pr1/python/spara-data-pa-fil/presentation/spara-data-pa-fil.html#konvertera-instanserna-till-json",
    "href": "pr1/python/spara-data-pa-fil/presentation/spara-data-pa-fil.html#konvertera-instanserna-till-json",
    "title": "Spara data till fil i Python",
    "section": "Konvertera instanserna till JSON",
    "text": "Konvertera instanserna till JSON\n\nJSON kan inte direkt hantera Python-objekt, så vi behöver konvertera våra objekt till en Python-datatypes som JSON kan serialisera, som en dict.\nAnvända __dict__ för att konvertera objekt till dict.\n\ncars_dict = [car.__dict__ for car in cars]\nDetta sätt att skapa en lista på kallas för listomfattning eller list comprehension. cars_dict är alltså en lista."
  },
  {
    "objectID": "pr1/python/spara-data-pa-fil/presentation/spara-data-pa-fil.html#instansen-på-fil",
    "href": "pr1/python/spara-data-pa-fil/presentation/spara-data-pa-fil.html#instansen-på-fil",
    "title": "Spara data till fil i Python",
    "section": "Instansen på fil",
    "text": "Instansen på fil\n\n\n\nVi använder json.dump() för att spara till fil:\nwith open('cars.json', 'w') as f:\n    json.dump(cars_dict, f)\n\n\n\nVi använder json.load() för att läsa från fil:\nwith open('cars.json', 'r') as f:\n    loaded_cars_dict = json.load(f)"
  },
  {
    "objectID": "pr1/python/spara-data-pa-fil/presentation/spara-data-pa-fil.html#konvertera-tillbaka-till-objekt",
    "href": "pr1/python/spara-data-pa-fil/presentation/spara-data-pa-fil.html#konvertera-tillbaka-till-objekt",
    "title": "Spara data till fil i Python",
    "section": "Konvertera tillbaka till objekt",
    "text": "Konvertera tillbaka till objekt\n\n\n\nKonvertera dict tillbaka till Car-objekt.\nloaded_cars = [Car(**car_dict) for car_dict in loaded_cars_dict]\n\n\n\nNu innehåller listan de båda bilarna; t ex det första objektets bilmärke är\nloaded_cars[0].brand # Volvo"
  },
  {
    "objectID": "pr1/python/spara-data-pa-fil/presentation/spara-data-pa-fil.html#sammanfattning",
    "href": "pr1/python/spara-data-pa-fil/presentation/spara-data-pa-fil.html#sammanfattning",
    "title": "Spara data till fil i Python",
    "section": "Sammanfattning",
    "text": "Sammanfattning\n\nInstanser av egendefinierade datatyper kan lagras på fil\nEtt vanligt format är JSON; filen är läsbar och förståelig för människor\nFör att lagra instansen som JSON måste den omvandlas till en dict (dictionary) i Python, som lagrar datan i samma format\nFör att skriva till filen används metoden json.dump()\nFör att läsa från filen används metoden json.load()\nEfter inläsning kan datan lagras i en lista i programmet"
  },
  {
    "objectID": "pr1/python/while-loopar/presentation/while-pres.html#dagens-mål",
    "href": "pr1/python/while-loopar/presentation/while-pres.html#dagens-mål",
    "title": "While-loopar i Python",
    "section": "Dagens mål",
    "text": "Dagens mål\n\nAtt känna till innebörden av en loopstruktur.\nAtt skriva enkla program som innehåller en eller flera while-loopar.\nAtt kunna använda styrsatserna break och continue.\nPå högre nivå: Att skriva program som innehåller nästlade loopar."
  },
  {
    "objectID": "pr1/python/while-loopar/presentation/while-pres.html#varför-loopar",
    "href": "pr1/python/while-loopar/presentation/while-pres.html#varför-loopar",
    "title": "While-loopar i Python",
    "section": "Varför loopar?",
    "text": "Varför loopar?\n\nLoopar används när en del i ett program ska upprepas ett bestämt eller obestämt antal gånger. Det kan t ex vara ett gissningsspel: Så länge som spelaren gissar fel ska det finnas möjlighet att gissa igen.\nVi vet inte hur många gissningar som behövs, men det ska finnas ett villkor som anger när loopen ska avslutas. Programmet kan även hålla koll på hur många gissningar som behövdes."
  },
  {
    "objectID": "pr1/python/while-loopar/presentation/while-pres.html#enklast-möjliga-while-loop",
    "href": "pr1/python/while-loopar/presentation/while-pres.html#enklast-möjliga-while-loop",
    "title": "While-loopar i Python",
    "section": "Enklast möjliga while-loop",
    "text": "Enklast möjliga while-loop\n\n\n\n\n\nflowchart LR\n    A((Start)) --&gt; B(\"Tilldela\\ni = 1\")\n    B --&gt; C{\"Är i ≤ 5?\"}\n    C --&gt;|Ja| D[/Skriv ut i/]\n    D --&gt; G(Öka i med 1)\n    G --&gt; C \n    C --&gt;|Nej| F((Avsluta))\n\n\n\n\n\n\n\n\n\n\ni = 1\nwhile i &lt;= 5:\n    print(i, end=\" \")\n    i += 1  # i ökar med 1\nprint(f\"\\nProgrammet avslutas eftersom i = {i}\")\n\n1 2 3 4 5 \nProgrammet avslutas eftersom i = 6\n\n\n\n\n\nVillkoret är på rad 2. Allt som omfattas av loopen är radindraget."
  },
  {
    "objectID": "pr1/python/while-loopar/presentation/while-pres.html#beräkning-av-summa-ver.-1",
    "href": "pr1/python/while-loopar/presentation/while-pres.html#beräkning-av-summa-ver.-1",
    "title": "While-loopar i Python",
    "section": "Beräkning av summa – ver. 1",
    "text": "Beräkning av summa – ver. 1\n# Detta program beräknar summan av ett antal tal\navsluta = False\nsumma = 0\nwhile not avsluta:\n    tal = int(input(\"Ange ett valfritt tal, noll avslutar -&gt; \"))\n    if tal == 0:\n        avsluta = True\n    summa += tal\nprint(f\"Summan är {summa}\")\n\n\n\n\nEtt problem här är även det sista inmatade talet ingår i summan, ett annat villkor för avslut skulle ge en felaktig summa."
  },
  {
    "objectID": "pr1/python/while-loopar/presentation/while-pres.html#beräkning-av-summa-ver.-2",
    "href": "pr1/python/while-loopar/presentation/while-pres.html#beräkning-av-summa-ver.-2",
    "title": "While-loopar i Python",
    "section": "Beräkning av summa – ver. 2",
    "text": "Beräkning av summa – ver. 2\n# Detta program beräknar summan av ett antal tal\nsumma = 0\nwhile True:\n    tal = int(input(\"Ange ett valfritt tal, noll avslutar -&gt; \"))\n    if tal == 0:\n        break\n    summa += tal\nprint(f\"Summan är {summa}\")\n\n\n\n\nHär används styrsatsen break för att avbryta loopen då ett villkor uppfylls. Det gör att det sista talet inte kommer att ingå i summan.\nSjälva loopvillkoret är alltid sant, det är innebörden av while True på rad 3."
  },
  {
    "objectID": "pr1/python/while-loopar/presentation/while-pres.html#summan-av-positiva-tal",
    "href": "pr1/python/while-loopar/presentation/while-pres.html#summan-av-positiva-tal",
    "title": "While-loopar i Python",
    "section": "Summan av positiva tal",
    "text": "Summan av positiva tal\n# Detta program beräknar summan av ett antal positiva tal\nsumma = 0\nwhile True:\n    tal = int(input(\"Ange ett valfritt tal, noll avslutar -&gt; \"))\n    if tal == 0:\n        break\n    if tal &lt; 0:\n        continue\n    summa += tal\nprint(f\"Summan av de inmatade positiva talen är {summa}\")\n\n\n\n\nStyrsatsen continue används för att hoppa över resten av loopen och börja om från dess början."
  },
  {
    "objectID": "pr1/python/while-loopar/presentation/while-pres.html#nästlad-loop-flödesschema",
    "href": "pr1/python/while-loopar/presentation/while-pres.html#nästlad-loop-flödesschema",
    "title": "While-loopar i Python",
    "section": "Nästlad loop – flödesschema",
    "text": "Nästlad loop – flödesschema\n\n\n\n\n\n\nflowchart LR\n    A((Start)) --&gt; B(\"Ansätt i = 0\")\n    B --&gt; C{\"i ≤  3?\"}\n    C --&gt; |\"Ja\"| D(\"Ansätt j = 0\")\n    D --&gt; E{\"j ≤  3?\"}\n    E --&gt;  |\"Ja\"| F[/Skriv ut i och j/]\n    F --&gt; G(Öka j med 1)\n    G --&gt; E\n    E --&gt; |\"Nej\"|H(\"Öka i med 1\")\n    H --&gt; C\n    C --&gt; |\"Nej\"|I((\"Avsluta\"))\n\n\n\n\n\n\n\n\n\n\n\nHär finns en “loop i en loop”. För varje varv som den yttre loopen gör så kommer den inre loopen att gå ett givet antal varv."
  },
  {
    "objectID": "pr1/python/while-loopar/presentation/while-pres.html#nästlad-loop-kodexempel",
    "href": "pr1/python/while-loopar/presentation/while-pres.html#nästlad-loop-kodexempel",
    "title": "While-loopar i Python",
    "section": "Nästlad loop – kodexempel",
    "text": "Nästlad loop – kodexempel\n# Detta program demonstrerar nästlade loopar\ni = 0\nwhile i &lt; 3: # Start yttre loop\n    j = 0\n    while j &lt; 3: # Start inre loop\n        print(f\"i = {i}, j = {j}\")\n        j += 1\n    i += 1\nprint(\"Programmet avslutas\")\n\n\n\nDenna kod motsvarar det ritade flödesschemat på förra slajden."
  },
  {
    "objectID": "pr1/python/while-loopar/presentation/while-pres.html#sammanfattning",
    "href": "pr1/python/while-loopar/presentation/while-pres.html#sammanfattning",
    "title": "While-loopar i Python",
    "section": "Sammanfattning",
    "text": "Sammanfattning\n\nEn loop är en kontrollstruktur som upprepar kod.\nDet finns flera typer av loopar, idag har vi gått igenom while-loopen.\nwhile-loopen löper så länge ett villkor är uppfyllt…\n…eller tills den stöter på en break-sats.\nStyrsatsen continue gör att koden går tillbaka till loopens start.\nI nästlade loopar går koden igenom alla kombinationer av värden i den yttre och inre loopen."
  },
  {
    "objectID": "ma/ma-5/bevis/bevis-pres.html#dagens-mål",
    "href": "ma/ma-5/bevis/bevis-pres.html#dagens-mål",
    "title": "Grunderna i matematisk bevisföring",
    "section": "Dagens mål",
    "text": "Dagens mål\n\nKänna till några relevanta begrepp inom matematisk bevisföring\nKänna till vad ett direkt bevis är\nKunna genomföra grundläggande bevis"
  },
  {
    "objectID": "ma/ma-5/bevis/bevis-pres.html#axiom",
    "href": "ma/ma-5/bevis/bevis-pres.html#axiom",
    "title": "Grunderna i matematisk bevisföring",
    "section": "Axiom",
    "text": "Axiom\n\n\n\nGrundläggande påstående som accepteras utan bevis.\n\n\n\nExempel: Om \\(A=B\\) så gäller att \\(B=A\\).\nExempel: Om \\(A=B\\) och \\(A=C\\) så gäller att \\(B=C\\).\n\n\n\nDetta är två av nio axiom som den italienske matematikern Giuseppe Peano (1858 – 1932) ställde upp som ett slags fundament inom logiken."
  },
  {
    "objectID": "ma/ma-5/bevis/bevis-pres.html#definition",
    "href": "ma/ma-5/bevis/bevis-pres.html#definition",
    "title": "Grunderna i matematisk bevisföring",
    "section": "Definition",
    "text": "Definition\n\n\n\nEn exakt beskrivning av ett begrepp.\n\n\n\nExempel: Ett rationellt tal är ett tal \\(\\frac{a}{b}\\), där \\(a\\) och \\(b\\) är heltal.\n\n\n\nExempel: \\(\\sqrt{x^2} = |x|\\)\n\n\n\nExempel: \\(|x|= \\left\\{\\begin{matrix}x,\\hspace{5mm}&x\\geq 0&\\\\\n-x,\\hspace{5mm}&x&lt;0&\\end{matrix}\\right .\\)"
  },
  {
    "objectID": "ma/ma-5/bevis/bevis-pres.html#påstående",
    "href": "ma/ma-5/bevis/bevis-pres.html#påstående",
    "title": "Grunderna i matematisk bevisföring",
    "section": "Påstående",
    "text": "Påstående\n\n\n\nExempel: Talet \\(21\\) är delbart med \\(3\\) eftersom \\(21=3\\cdot 7\\) (Sant).\n\n\n\nExempel: Ekvationen \\[a^n+b^n=c^n\\] har heltalslösningar \\(a,b\\) och \\(c\\) för alla \\(n\\) som är positiva heltal (Falskt).\nEtt påstående i matematiken behöver alltså inte vara sant för att klassificeras som påstående."
  },
  {
    "objectID": "ma/ma-5/bevis/bevis-pres.html#bevis",
    "href": "ma/ma-5/bevis/bevis-pres.html#bevis",
    "title": "Grunderna i matematisk bevisföring",
    "section": "Bevis",
    "text": "Bevis\n\n\n\nMatematisk argumentation för att ett resultat ska accepteras. Bygger på axiom eller tidigare bevis.\n\n\n\nExempel: Visa att \\[\\frac{1}{2}(a+b)&gt;\\sqrt{ab}\\] för alla tal \\(a,b&gt;0\\)."
  },
  {
    "objectID": "ma/ma-5/bevis/bevis-pres.html#direkta-bevis",
    "href": "ma/ma-5/bevis/bevis-pres.html#direkta-bevis",
    "title": "Grunderna i matematisk bevisföring",
    "section": "Direkta bevis",
    "text": "Direkta bevis\n\n\n\nMan utgår från givna antaganden eller axiom och med logiska steg visar att slutsatsen måste vara sann.\n\n\n\nBeviset som vi genomförde i förra slajden var ett exempel på ett direkt bevis.\nDet finns andra typer av bevis: Indirekta bevis, motsägelsebevis och induktionsbevis. Dessa tas upp senare i kursen."
  },
  {
    "objectID": "ma/ma-5/bevis/bevis-pres.html#falsifikation",
    "href": "ma/ma-5/bevis/bevis-pres.html#falsifikation",
    "title": "Grunderna i matematisk bevisföring",
    "section": "Falsifikation",
    "text": "Falsifikation\n\n\n\nAtt visa att något är sant inom en viss ram kräver att alla fall täcks med logiska resonemang. Att visa att något är falskt kräver endast ett motexempel.\n\n\n\nExempel: Produkten av ett jämnt tal och ett udda tal är alltid ett jämnt tal (visa det!). Gäller det att varje jämnt tal kan skrivas som en produkt av ett jämnt och ett udda tal?\nNej, visserligen så vet vi t ex att \\(12=3\\cdot 4\\), men även att \\(16=2\\cdot 8\\). Detta motsäger påståendet att varje jämnt tal är en produkt av ett jämnt och ett udda tal."
  },
  {
    "objectID": "ma/ma-5/bevis/bevis-pres.html#slutnot",
    "href": "ma/ma-5/bevis/bevis-pres.html#slutnot",
    "title": "Grunderna i matematisk bevisföring",
    "section": "Slutnot",
    "text": "Slutnot\n\nUtgå aldrig från att det som ska visas gäller! Försök istället att med logik och räkneregler gå från påståendet till slutmålet.\nDet kan vara tålamodskrävande att genomföra ett korrekt bevis. Man kanske inte omdelbart ser någon angreppsmetod. Övning ger färdighet!\nEtt bevis avslutas lämpligen med V.S.B, V.S.V eller Q.E.D."
  },
  {
    "objectID": "ma/ma-spec/programmering/teori-och-ovningar/octave-som-kalkylator/index.html",
    "href": "ma/ma-spec/programmering/teori-och-ovningar/octave-som-kalkylator/index.html",
    "title": "Octave: Octave som kalkylator",
    "section": "",
    "text": "Se kap. 1 i dokumentet Teori och övningar i programmet Octave\n\n\n\n\n\nBeräkna \\(\\frac{1}{19} - \\frac{1}{17} + \\frac{1}{131}\\) med Octave. Svara med\n\nFyra decimaler\nI bråkform\nMed femton decimaler\n\n\n\n\n\n\n\nLösningsförslag övning 101\n\n\n\n\n\nLösningarna är gjorda i Command Window; den text som står tillsammans med ett nummer, t ex Octave:1&gt;, ska inte matas in.\na-uppgiften\noctave:1&gt; 1/19 - 1/17 + 1/131\nans = 1.4416e-03\nb-uppgiften\noctave:2&gt; format rat\noctave:3&gt; 1/19 - 1/17 + 1/131\nans = 61/42313\nc-uppgiften\noctave:4&gt; format long\noctave:5&gt; 1/19 - 1/17 + 1/131\nans = 1.441637321863255e-03\n\n\n\n\n\n\nBeräkna \\(\\frac{1}{19^2} - \\frac{1}{17^2} + \\frac{1}{131^2}\\) med Octave. Svara med\n\nFemton decimaler\nI bråkform\n\nJämför dina svar ovan med det du får om du anger samma uttryck i Wolfram Alpha. Kommentera resultatet.\n\n\n\n\n\n\nLösningsförslag övning 102\n\n\n\n\n\na-uppgiften\nKommentar: formatet med 15 decimaler är kvar från den tidigare inmatningen i övning 1c; formatet ändras inte tillbaka till standard per automatik.\noctave:6&gt; 1/19^2 - 1/17^2 + 1/131^2\nans = -6.318528474731418e-04\nb-uppgiften\noctave:7&gt; format rat\noctave:8&gt; 1/19^2 - 1/17^2 + 1/131^2\nans = -17/26905\nKommentar: Med Wolfram Alpha kommer svaret att bli \\(\\frac{-1131263}{1790389969}\\). Det vi ser är att Octave skapar ett rationellt tal av ett avrundat värde.\n\n\n\n\n\n\nBeräkna värdet av uttrycket \\[\n\\frac{\\left (\\frac{\\sqrt{5} + 1}{2} \\right )^{10} - \\left (\\frac{\\sqrt{5} - 1}{2} \\right )^{10}}{\\sqrt{5}}\n\\] på en enda rad.\n\n\n\n\n\n\nLösningsförslag övning 103\n\n\n\n\n\noctave:9&gt; format short\noctave:10&gt; (((sqrt(5) + 1) / 2)^10 - ((sqrt(5) - 1) / 2)^10) / sqrt(5)\nans = 55.000\n\n\n\n\n\n\nSkapa en vektor \\(\\vec{v}\\) med tio jämnt fördelade vinklar i intervallet 0° – 360° (tips: slå upp funktionen linspace genom att skriva help linspace vid Octave-prompten). Verifiera med en beräkning att identiteten \\(\\sin^2v_j + \\cos^2v_j\\) gäller, där \\(v_j\\) är komponenten i \\(\\vec{v}\\) med indexet \\(j\\).\n\n\n\n\n\n\nLösningsförslag övning 104\n\n\n\n\n\noctave:11&gt; v = linspace(0, 360, 10)\nv =\n\n     0    40    80   120   160   200   240   280   320   360\n\noctave:12&gt; (sin(v)).^2 + (cos(v)).^2\nans =\n\n   1   1   1   1   1   1   1   1   1   1\n\nvilket indikerar att respektive summa är 1.\nObservera punkten framför exponent-tecknet i uttrycket; den gör så att beräkningen sker komponentvis. Om punkten utelämnas kommer Octave att mata ut ett felmeddelande.\n\n\n\n\n\n\nEvaluera följande uttryck i Octave, reflektera över resultatet.\n\n1/0\n0/0\ntan(pi/2)\ninf + 1\ninf + 1e99\ninf + inf\ninf - inf\n\n\n\n\n\n\n\nLösningsförslag övning 105\n\n\n\n\n\na-uppgiften\noctave:13&gt; 1/0\nans = Inf\nKommentar: Inf betyder “oändligheten”.\nb-uppgiften\noctave:14&gt; 0/0\nans = NaN\nKommentar: NaN betyde Not a Number. Det är intressant att notera att Octave gör skillnad på uttrycken i a och b. I matematiken är såväl \\(1/0\\) som \\(0/0\\) odefinierat.\nc-uppgiften\noctave:15&gt; tan(pi/2)\nans = 1.6331e+16\nKommentar: Uttrycket \\(\\tan (\\pi/2)\\) odefinierat i matematiken. Men eftersom Octave avrundar pi till ett ändligt antal decimaler så är inte Octave:s värde på pi detsamma som den matematiska konstanten \\(\\pi\\). Ju närmare \\(\\pi/2\\) en vinkel kommer, desto större värde kommer \\(\\arctan(\\pi/2)\\) att få. Därför så blir inte Octave:s svar Inf eller NaN, det blir helt enkelt ett stort tal.\nd-uppgiften\noctave:16&gt; Inf + 1\nans = Inf\nKommentar: Läggs 1 till “oändligheten” är det fortfarande “oändligheten”. Annars så skulle “oändligheten” ha varit ett tal, och det är det inte.\ne-uppgiften\noctave:17&gt; Inf + 1e99\nans = Inf\nKommentar: Även om ett väldigt stort tal läggs till oändligheten så är det fortfarande oändligheten, på samma sätt som i övning 105 d.\nf-uppgiften\noctave:18&gt; Inf + Inf\nans = Inf\nKommentar: Här kanske det är intressant att svaret inte blir “två oändligheter”. “Oändligheten” är inte kvantiserad.\ng-uppgiften\noctave:19&gt; Inf - Inf\nans = NaN\nKommentar: Eftersom oändligheten inte är kvantiserad så kan vad som helst tas bort från oändligheten utan att den förändras. Eftersom något som inte är kvantiserat tar bort från något som inte heller är kvantiserat så blir resultatet odefinierat.\n\n\n\n\n\n\nFörenkla talet \\(i^{95}\\) med Octave. Hur står sig svaret i förhållande till det värde som uttrycket faktiskt har? Kommentera.\n\n\n\n\n\n\nLösningsförslag övning 106\n\n\n\n\n\noctave:20&gt; i^95\nans =  -4.8800e-16 - 1.0000e+00i\nKommentar: Uttryckets värde är precis \\(-i\\). Eftersom Octave arbetar med närmevärden så kan svaret se ut att skilja sig lite från detta. Du bör dock vara uppmärksam när du ser exponenter som är negativa på ett stort avstånd från noll; det kan ofta vara en “matematisk nolla”.\n\n\n\n\n\n\nDeklarera en vektor \\(\\vec{v}\\) som innehåller tio jämnt fördelade vinklar mellan \\(0\\) och \\(2\\pi\\). Skapa med hjälp av \\(\\vec{v}\\) en vektor \\(\\vec{z}\\), vars komponenter \\(z_j=e^{iv_j}\\).\n\nVerifiera att \\(\\mathrm{Re}(z_j)=\\cos{v}\\). Tips: skriv help real vid Octave-prompten.\nVerifiera att \\(\\mathrm{Im}(z_j)=\\sin{v}\\). Tips: skriv help imag vid Octave-prompten.\n\n\n\n\n\n\n\nLösningsförslag övning 107\n\n\n\n\n\nArbetsgång: Först skapas vektorn med vinklar, därefter utförs respektive beräkningar vars resultat läggs i varsin resultatsvektor. Slutligen subtraheras dessa resultatsvektorer med varandra. Om likhet gäller ska respektive komponent i denna differensvektor vara noll.\noctave:21&gt; v = linspace(0, 2*pi, 10);\noctave:22&gt; z = e.^(i.*v);\noctave:23&gt; trigres_cos  = cos(v);\noctave:24&gt; trigres_sin  = sin(v);\noctave:25&gt; real(z) - trigres_cos # Detta är a-uppgiften\nans =\n\n   0   0   0   0   0   0   0   0   0   0\n\noctave:26&gt; imag(z) - trigres_sin # Detta är b-uppgiften\nans =\n\n   0   0   0   0   0   0   0   0   0   0\nEftersom differensen av respektive par av vektorkomponenter blir noll så är de lika!\n\n\n\n\n\n\nI ett annat programspråk så finns en funktion som heter append, vilken används till att lägga till element i listor. Octave har inte den funktionen, istället så kan en komponent a läggas till en vektor v genom v(end+1) = a.\nSkapa en vektor v = [1 2 3] och lägg till talet 4 sist med hjälp av denna metod.\n\n\n\n\n\n\nLösningsförslag övning 108\n\n\n\n\n\noctave:27&gt; v = 1:3\nv =\n\n   1   2   3\n\noctave:28&gt; v(end+1) = 4\nv =\n\n   1   2   3   4\n\n\n\n\n\n\nSkapa en vektor \\(\\vec{v}\\) med talen \\(0, 0.25, 0.5, 0.75, \\ldots 3\\) i Octave. Med hjälp av denna vektor ska du skapa en vektor \\(\\vec{x}\\), där \\(x_i=\\log_3 v_i\\) (observera att \\(i\\) är index, inte den imaginära enheten!). Kommentera resultatet, speciellt utdatan för x(1), x(5) och x(end).\nTips för beräkningen: skriv om \\(x=\\log_3 v_i\\) som en ekvation med \\(x\\) som exponent.\n\n\n\n\n\n\nLösningsförslag övning 109\n\n\n\n\n\nFörst måste logaritmen med basen 3 kunna beräknas; Octave har ingen inbyggd funktion för detta. Nedanstående ekvation, vars lösning dels skrivs med logaritmen med basen 3 och dels med hjälp av omskrivning med logaritmlag, är till hjälp.\n\\[\n\\begin{matrix}\n3^x &=& v_i &\\Leftrightarrow& x &=& \\log_3 v_i \\\\[5mm]\n3^x &=& v_i &\\Leftrightarrow& x &=& \\frac{\\log{v_i}}{\\log{3}}\n\\end{matrix}\n\\hspace{5mm} \\Rightarrow \\log_3{v_i} = \\frac{\\log{v_i}}{\\log{3}}\n\\]\nHär är \\(\\log v_i\\) och \\(\\log 3\\) av godtycklig (men samma) bas. Därför kan funktionen log i Octave användas (som ger logaritm med basen \\(e\\)).\nKoden blir\noctave:29&gt; v = 0:0.25:3;\noctave:30&gt; x = log(v) / log(3);\noctave:31&gt; x(1)\nans = -Inf\noctave:32&gt; x(5)\nans = 0\noctave:33&gt; x(end)\nans = 1\nKommentarer: x(1) antar “värdet” -Inf eftersom vi önskar lösa ekvationen \\(3^x = 0\\). Ju längre avstånd från noll utefter den negativa delen på tallinjen, desto närmare noll kommer resultatet att bli. Men det kommer aldrig att bli noll. Vi kan se i vektorn v att den första komponenten är noll:\noctave:34&gt; v(1)\nans = 0\nAtt x(5) antar värdet noll måste betyda att \\(\\log_3 1\\) beräknas, eftersom \\(3^0\\) är 1. En koll visar också att det är den beräkningen som gjorts:\noctave:35&gt; v(5)\nans = 1\nSlutligen gäller att x(end) antar värdet 1 eftersom \\(3^1=3\\). Vi kontrollerar att så är fallet:\noctave:36&gt; v(end)\nans = 3\n\n\n\n\n\n\nI den här övningen ska du undersöka funktionen diff och logspace.\n\nMata in diff([1 4 6 5.5 10]). Baserat på resultatet, hur tror du att funktionen diff verkar på en vektor?\nSkapa en vektor med hjälp av funktionen logspace enligt logspace(1, 3, 8). Betrakta vektorn och förklara resultatet.\nEftersom resultatet av övning 110b automatiskt har lagrats i variabeln ans så kan funktionen diff tillämpas på svaret genom att skriva diff(ans). Gör det, och lagra resultatet av detta i variabeln expdiff. Betrakta och reflektera över resultatet.\nLogaritmera expdiff från övning 110c.\nTillämpa nu funktionen diff på resultatet i övning 110d. Kommentera.\nGör om övningarna 110d och 110e, men logaritmera med basen 2 och 10 i tur och ordning. Kommentera resultatet.\n\n\n\n\n\n\n\nLösningsförslag övning 110\n\n\n\n\n\na-uppgiften\noctave:37&gt; diff([1 4 6 5.5 10])\nans =\n\n   3.0000   2.0000  -0.5000   4.5000\nKommentar: Funktionen diff tar parvis differensen mellan två närliggande tal i vektorn som den verkar på.\nb-uppgiften\noctave:38&gt; logspace(1, 3, 8)\nans =\n\n     10.000     19.307     37.276     71.969    138.950    268.270    517.947   1000.000\nKommentar: Detta anrop till funktionen logspace skapar åtta tal mellan (och inklusive) \\(10^1\\) och \\(10^3\\). Talens exponenter är linjärt fördelade, men det blir inte själva talen (som kommer att synas i nästa övning).\nc-uppgiften\noctave:39&gt; expdiff = diff(ans)\nans =\n\n     9.3070    17.9690    34.6926    66.9810   129.3200   249.6779   482.0525\nKommentar: Här syns att differensen ökar.\nd-uppgiften\noctave:40&gt; log(expdiff) \nans =\n\n   2.2308   2.8886   3.5465   4.2044   4.8623   5.5202   6.1781\nKommentar: Är de logaritmerade differenserna möjligen desamma? Det kommer att visa sig i …\ne-uppgiften\noctave:41&gt; diff(ans)\nans =\n\n   0.6579   0.6579   0.6579   0.6579   0.6579   0.6579\nKommentar: Japp, de logaritmerade differenserna är desamma!\nf-uppgiften\nVi logaritmerar i tur och ordning med baserna 2 och 10, och sparar resultaten i log2expdiff respektive log10expdiff.\noctave:42&gt; log2expdiff = log2(expdiff)\nlog2expdiff =\n\n   3.2183   4.1674   5.1166   6.0657   7.0148   7.9639   8.9130\noctave:43&gt; log10expdiff = log10(expdiff)\nlog10expdiff =\n\n   0.9688   1.2545   1.5402   1.8260   2.1117   2.3974   2.6831\nVi ser att resultaten blir olika beroende på vilken logaritmbas som används. Nu tar vi differensen mellan två närliggande komponenter i respektive vektor:\noctave:44&gt; diff(log2expdiff)\nans =\n\n   0.9491   0.9491   0.9491   0.9491   0.9491   0.9491\noctave:45&gt; diff(log10expdiff)\nans =\n\n   0.2857   0.2857   0.2857   0.2857   0.2857   0.2857\nDet syns att differensen mellan komponenternas värden inte förändras, men vilken differens som det blir beror på logaritmbasen.",
    "crumbs": [
      "Home",
      "Programmering i matematik",
      "MatSpec",
      "Teori och övningar",
      "Octave: Octave som kalkylator"
    ]
  },
  {
    "objectID": "ma/ma-spec/programmering/teori-och-ovningar/octave-som-kalkylator/index.html#teori",
    "href": "ma/ma-spec/programmering/teori-och-ovningar/octave-som-kalkylator/index.html#teori",
    "title": "Octave: Octave som kalkylator",
    "section": "",
    "text": "Se kap. 1 i dokumentet Teori och övningar i programmet Octave",
    "crumbs": [
      "Home",
      "Programmering i matematik",
      "MatSpec",
      "Teori och övningar",
      "Octave: Octave som kalkylator"
    ]
  },
  {
    "objectID": "ma/ma-spec/programmering/teori-och-ovningar/octave-som-kalkylator/index.html#övningar",
    "href": "ma/ma-spec/programmering/teori-och-ovningar/octave-som-kalkylator/index.html#övningar",
    "title": "Octave: Octave som kalkylator",
    "section": "",
    "text": "Beräkna \\(\\frac{1}{19} - \\frac{1}{17} + \\frac{1}{131}\\) med Octave. Svara med\n\nFyra decimaler\nI bråkform\nMed femton decimaler\n\n\n\n\n\n\n\nLösningsförslag övning 101\n\n\n\n\n\nLösningarna är gjorda i Command Window; den text som står tillsammans med ett nummer, t ex Octave:1&gt;, ska inte matas in.\na-uppgiften\noctave:1&gt; 1/19 - 1/17 + 1/131\nans = 1.4416e-03\nb-uppgiften\noctave:2&gt; format rat\noctave:3&gt; 1/19 - 1/17 + 1/131\nans = 61/42313\nc-uppgiften\noctave:4&gt; format long\noctave:5&gt; 1/19 - 1/17 + 1/131\nans = 1.441637321863255e-03\n\n\n\n\n\n\nBeräkna \\(\\frac{1}{19^2} - \\frac{1}{17^2} + \\frac{1}{131^2}\\) med Octave. Svara med\n\nFemton decimaler\nI bråkform\n\nJämför dina svar ovan med det du får om du anger samma uttryck i Wolfram Alpha. Kommentera resultatet.\n\n\n\n\n\n\nLösningsförslag övning 102\n\n\n\n\n\na-uppgiften\nKommentar: formatet med 15 decimaler är kvar från den tidigare inmatningen i övning 1c; formatet ändras inte tillbaka till standard per automatik.\noctave:6&gt; 1/19^2 - 1/17^2 + 1/131^2\nans = -6.318528474731418e-04\nb-uppgiften\noctave:7&gt; format rat\noctave:8&gt; 1/19^2 - 1/17^2 + 1/131^2\nans = -17/26905\nKommentar: Med Wolfram Alpha kommer svaret att bli \\(\\frac{-1131263}{1790389969}\\). Det vi ser är att Octave skapar ett rationellt tal av ett avrundat värde.\n\n\n\n\n\n\nBeräkna värdet av uttrycket \\[\n\\frac{\\left (\\frac{\\sqrt{5} + 1}{2} \\right )^{10} - \\left (\\frac{\\sqrt{5} - 1}{2} \\right )^{10}}{\\sqrt{5}}\n\\] på en enda rad.\n\n\n\n\n\n\nLösningsförslag övning 103\n\n\n\n\n\noctave:9&gt; format short\noctave:10&gt; (((sqrt(5) + 1) / 2)^10 - ((sqrt(5) - 1) / 2)^10) / sqrt(5)\nans = 55.000\n\n\n\n\n\n\nSkapa en vektor \\(\\vec{v}\\) med tio jämnt fördelade vinklar i intervallet 0° – 360° (tips: slå upp funktionen linspace genom att skriva help linspace vid Octave-prompten). Verifiera med en beräkning att identiteten \\(\\sin^2v_j + \\cos^2v_j\\) gäller, där \\(v_j\\) är komponenten i \\(\\vec{v}\\) med indexet \\(j\\).\n\n\n\n\n\n\nLösningsförslag övning 104\n\n\n\n\n\noctave:11&gt; v = linspace(0, 360, 10)\nv =\n\n     0    40    80   120   160   200   240   280   320   360\n\noctave:12&gt; (sin(v)).^2 + (cos(v)).^2\nans =\n\n   1   1   1   1   1   1   1   1   1   1\n\nvilket indikerar att respektive summa är 1.\nObservera punkten framför exponent-tecknet i uttrycket; den gör så att beräkningen sker komponentvis. Om punkten utelämnas kommer Octave att mata ut ett felmeddelande.\n\n\n\n\n\n\nEvaluera följande uttryck i Octave, reflektera över resultatet.\n\n1/0\n0/0\ntan(pi/2)\ninf + 1\ninf + 1e99\ninf + inf\ninf - inf\n\n\n\n\n\n\n\nLösningsförslag övning 105\n\n\n\n\n\na-uppgiften\noctave:13&gt; 1/0\nans = Inf\nKommentar: Inf betyder “oändligheten”.\nb-uppgiften\noctave:14&gt; 0/0\nans = NaN\nKommentar: NaN betyde Not a Number. Det är intressant att notera att Octave gör skillnad på uttrycken i a och b. I matematiken är såväl \\(1/0\\) som \\(0/0\\) odefinierat.\nc-uppgiften\noctave:15&gt; tan(pi/2)\nans = 1.6331e+16\nKommentar: Uttrycket \\(\\tan (\\pi/2)\\) odefinierat i matematiken. Men eftersom Octave avrundar pi till ett ändligt antal decimaler så är inte Octave:s värde på pi detsamma som den matematiska konstanten \\(\\pi\\). Ju närmare \\(\\pi/2\\) en vinkel kommer, desto större värde kommer \\(\\arctan(\\pi/2)\\) att få. Därför så blir inte Octave:s svar Inf eller NaN, det blir helt enkelt ett stort tal.\nd-uppgiften\noctave:16&gt; Inf + 1\nans = Inf\nKommentar: Läggs 1 till “oändligheten” är det fortfarande “oändligheten”. Annars så skulle “oändligheten” ha varit ett tal, och det är det inte.\ne-uppgiften\noctave:17&gt; Inf + 1e99\nans = Inf\nKommentar: Även om ett väldigt stort tal läggs till oändligheten så är det fortfarande oändligheten, på samma sätt som i övning 105 d.\nf-uppgiften\noctave:18&gt; Inf + Inf\nans = Inf\nKommentar: Här kanske det är intressant att svaret inte blir “två oändligheter”. “Oändligheten” är inte kvantiserad.\ng-uppgiften\noctave:19&gt; Inf - Inf\nans = NaN\nKommentar: Eftersom oändligheten inte är kvantiserad så kan vad som helst tas bort från oändligheten utan att den förändras. Eftersom något som inte är kvantiserat tar bort från något som inte heller är kvantiserat så blir resultatet odefinierat.\n\n\n\n\n\n\nFörenkla talet \\(i^{95}\\) med Octave. Hur står sig svaret i förhållande till det värde som uttrycket faktiskt har? Kommentera.\n\n\n\n\n\n\nLösningsförslag övning 106\n\n\n\n\n\noctave:20&gt; i^95\nans =  -4.8800e-16 - 1.0000e+00i\nKommentar: Uttryckets värde är precis \\(-i\\). Eftersom Octave arbetar med närmevärden så kan svaret se ut att skilja sig lite från detta. Du bör dock vara uppmärksam när du ser exponenter som är negativa på ett stort avstånd från noll; det kan ofta vara en “matematisk nolla”.\n\n\n\n\n\n\nDeklarera en vektor \\(\\vec{v}\\) som innehåller tio jämnt fördelade vinklar mellan \\(0\\) och \\(2\\pi\\). Skapa med hjälp av \\(\\vec{v}\\) en vektor \\(\\vec{z}\\), vars komponenter \\(z_j=e^{iv_j}\\).\n\nVerifiera att \\(\\mathrm{Re}(z_j)=\\cos{v}\\). Tips: skriv help real vid Octave-prompten.\nVerifiera att \\(\\mathrm{Im}(z_j)=\\sin{v}\\). Tips: skriv help imag vid Octave-prompten.\n\n\n\n\n\n\n\nLösningsförslag övning 107\n\n\n\n\n\nArbetsgång: Först skapas vektorn med vinklar, därefter utförs respektive beräkningar vars resultat läggs i varsin resultatsvektor. Slutligen subtraheras dessa resultatsvektorer med varandra. Om likhet gäller ska respektive komponent i denna differensvektor vara noll.\noctave:21&gt; v = linspace(0, 2*pi, 10);\noctave:22&gt; z = e.^(i.*v);\noctave:23&gt; trigres_cos  = cos(v);\noctave:24&gt; trigres_sin  = sin(v);\noctave:25&gt; real(z) - trigres_cos # Detta är a-uppgiften\nans =\n\n   0   0   0   0   0   0   0   0   0   0\n\noctave:26&gt; imag(z) - trigres_sin # Detta är b-uppgiften\nans =\n\n   0   0   0   0   0   0   0   0   0   0\nEftersom differensen av respektive par av vektorkomponenter blir noll så är de lika!\n\n\n\n\n\n\nI ett annat programspråk så finns en funktion som heter append, vilken används till att lägga till element i listor. Octave har inte den funktionen, istället så kan en komponent a läggas till en vektor v genom v(end+1) = a.\nSkapa en vektor v = [1 2 3] och lägg till talet 4 sist med hjälp av denna metod.\n\n\n\n\n\n\nLösningsförslag övning 108\n\n\n\n\n\noctave:27&gt; v = 1:3\nv =\n\n   1   2   3\n\noctave:28&gt; v(end+1) = 4\nv =\n\n   1   2   3   4\n\n\n\n\n\n\nSkapa en vektor \\(\\vec{v}\\) med talen \\(0, 0.25, 0.5, 0.75, \\ldots 3\\) i Octave. Med hjälp av denna vektor ska du skapa en vektor \\(\\vec{x}\\), där \\(x_i=\\log_3 v_i\\) (observera att \\(i\\) är index, inte den imaginära enheten!). Kommentera resultatet, speciellt utdatan för x(1), x(5) och x(end).\nTips för beräkningen: skriv om \\(x=\\log_3 v_i\\) som en ekvation med \\(x\\) som exponent.\n\n\n\n\n\n\nLösningsförslag övning 109\n\n\n\n\n\nFörst måste logaritmen med basen 3 kunna beräknas; Octave har ingen inbyggd funktion för detta. Nedanstående ekvation, vars lösning dels skrivs med logaritmen med basen 3 och dels med hjälp av omskrivning med logaritmlag, är till hjälp.\n\\[\n\\begin{matrix}\n3^x &=& v_i &\\Leftrightarrow& x &=& \\log_3 v_i \\\\[5mm]\n3^x &=& v_i &\\Leftrightarrow& x &=& \\frac{\\log{v_i}}{\\log{3}}\n\\end{matrix}\n\\hspace{5mm} \\Rightarrow \\log_3{v_i} = \\frac{\\log{v_i}}{\\log{3}}\n\\]\nHär är \\(\\log v_i\\) och \\(\\log 3\\) av godtycklig (men samma) bas. Därför kan funktionen log i Octave användas (som ger logaritm med basen \\(e\\)).\nKoden blir\noctave:29&gt; v = 0:0.25:3;\noctave:30&gt; x = log(v) / log(3);\noctave:31&gt; x(1)\nans = -Inf\noctave:32&gt; x(5)\nans = 0\noctave:33&gt; x(end)\nans = 1\nKommentarer: x(1) antar “värdet” -Inf eftersom vi önskar lösa ekvationen \\(3^x = 0\\). Ju längre avstånd från noll utefter den negativa delen på tallinjen, desto närmare noll kommer resultatet att bli. Men det kommer aldrig att bli noll. Vi kan se i vektorn v att den första komponenten är noll:\noctave:34&gt; v(1)\nans = 0\nAtt x(5) antar värdet noll måste betyda att \\(\\log_3 1\\) beräknas, eftersom \\(3^0\\) är 1. En koll visar också att det är den beräkningen som gjorts:\noctave:35&gt; v(5)\nans = 1\nSlutligen gäller att x(end) antar värdet 1 eftersom \\(3^1=3\\). Vi kontrollerar att så är fallet:\noctave:36&gt; v(end)\nans = 3\n\n\n\n\n\n\nI den här övningen ska du undersöka funktionen diff och logspace.\n\nMata in diff([1 4 6 5.5 10]). Baserat på resultatet, hur tror du att funktionen diff verkar på en vektor?\nSkapa en vektor med hjälp av funktionen logspace enligt logspace(1, 3, 8). Betrakta vektorn och förklara resultatet.\nEftersom resultatet av övning 110b automatiskt har lagrats i variabeln ans så kan funktionen diff tillämpas på svaret genom att skriva diff(ans). Gör det, och lagra resultatet av detta i variabeln expdiff. Betrakta och reflektera över resultatet.\nLogaritmera expdiff från övning 110c.\nTillämpa nu funktionen diff på resultatet i övning 110d. Kommentera.\nGör om övningarna 110d och 110e, men logaritmera med basen 2 och 10 i tur och ordning. Kommentera resultatet.\n\n\n\n\n\n\n\nLösningsförslag övning 110\n\n\n\n\n\na-uppgiften\noctave:37&gt; diff([1 4 6 5.5 10])\nans =\n\n   3.0000   2.0000  -0.5000   4.5000\nKommentar: Funktionen diff tar parvis differensen mellan två närliggande tal i vektorn som den verkar på.\nb-uppgiften\noctave:38&gt; logspace(1, 3, 8)\nans =\n\n     10.000     19.307     37.276     71.969    138.950    268.270    517.947   1000.000\nKommentar: Detta anrop till funktionen logspace skapar åtta tal mellan (och inklusive) \\(10^1\\) och \\(10^3\\). Talens exponenter är linjärt fördelade, men det blir inte själva talen (som kommer att synas i nästa övning).\nc-uppgiften\noctave:39&gt; expdiff = diff(ans)\nans =\n\n     9.3070    17.9690    34.6926    66.9810   129.3200   249.6779   482.0525\nKommentar: Här syns att differensen ökar.\nd-uppgiften\noctave:40&gt; log(expdiff) \nans =\n\n   2.2308   2.8886   3.5465   4.2044   4.8623   5.5202   6.1781\nKommentar: Är de logaritmerade differenserna möjligen desamma? Det kommer att visa sig i …\ne-uppgiften\noctave:41&gt; diff(ans)\nans =\n\n   0.6579   0.6579   0.6579   0.6579   0.6579   0.6579\nKommentar: Japp, de logaritmerade differenserna är desamma!\nf-uppgiften\nVi logaritmerar i tur och ordning med baserna 2 och 10, och sparar resultaten i log2expdiff respektive log10expdiff.\noctave:42&gt; log2expdiff = log2(expdiff)\nlog2expdiff =\n\n   3.2183   4.1674   5.1166   6.0657   7.0148   7.9639   8.9130\noctave:43&gt; log10expdiff = log10(expdiff)\nlog10expdiff =\n\n   0.9688   1.2545   1.5402   1.8260   2.1117   2.3974   2.6831\nVi ser att resultaten blir olika beroende på vilken logaritmbas som används. Nu tar vi differensen mellan två närliggande komponenter i respektive vektor:\noctave:44&gt; diff(log2expdiff)\nans =\n\n   0.9491   0.9491   0.9491   0.9491   0.9491   0.9491\noctave:45&gt; diff(log10expdiff)\nans =\n\n   0.2857   0.2857   0.2857   0.2857   0.2857   0.2857\nDet syns att differensen mellan komponenternas värden inte förändras, men vilken differens som det blir beror på logaritmbasen.",
    "crumbs": [
      "Home",
      "Programmering i matematik",
      "MatSpec",
      "Teori och övningar",
      "Octave: Octave som kalkylator"
    ]
  },
  {
    "objectID": "ma/ma-spec/programmering/teori-och-ovningar/lin-ekvationssystem-med-octave/index.html",
    "href": "ma/ma-spec/programmering/teori-och-ovningar/lin-ekvationssystem-med-octave/index.html",
    "title": "Octave: Lösning av linjära ekvationssystem",
    "section": "",
    "text": "Ett sätt att lösa ett linjära ekvationssystem i Octave är att först deklarera det som en koefficientmatris \\(A\\) och en vektor \\(\\vec{v}\\) enligt \\(A\\vec{x}=\\vec{v}\\) (här kommer vektorn \\(\\vec{x}\\) att utgöra den beräknade lösningsvektorn).\nFör att lösa ekvationssystemet \\(A\\vec{x}=\\vec{v}\\), där \\(A\\) och \\(\\vec{v}\\) är deklarerade så används “backslash-operatorn” enligt A \\ v.\nExempel\n\n\n\n\n\n\nLös följande ekvationssystem med Octave\n\\[\n\\left \\{\n\\begin{matrix*}[r]\nx_1&+&2x_2&=&-1\\\\\n2x_1&-&3x_2&=&12\n\\end{matrix*}\n\\right .\n\\]\nVi deklarerar koefficientmatrisen \\(A\\) och vektorn \\(\\vec{v}\\):\noctave:1&gt; A = [1 2 ; 2 -3];\noctave:2&gt; v = [-1 ; 12];\nDärefter så löses systemet:\noctave:3&gt; x = A \\ v\nx =\n\n   3\n  -2\ndär utmatningen innebär att \\(x_1=3\\) och \\(x_2=-2\\).\nJust i det här fallet blev lösningen heltal, men det kan bli såväl rationella som irrationella lösningar; man får då ha i åtanke att Octave jobbar med avrundade närmevärden och inte exakta tal (som går att approximera till rationella tal).\n\n\n\n\n\n\n\n\nLös det linjära ekvationssystemet nedan med Octave.\n\\[\n\\left \\{\n\\begin{matrix*}[r]\nx&+&2y&+&3z&=&10\\\\\nx&+&y&-&z&=&4\\\\\n2x&-&y&+&z&=&5\n\\end{matrix*}\n\\right .\n\\]\nLagra koefficientmatrisen som A och den beräknade lösningen i vektorvariabeln x och verifiera den genom att exekvera A*x.\n\n\n\nStäll in Octave i rationellt läge genom att exekverar format rat. Lös sedan det linjära ekvationssystemet\n\\[\n\\left \\{\n  \\begin{matrix}\n  5x_1&-&x_2&+&3x_3&=&\\frac{1849}{1092}\\\\[3mm]\n  &x_1 &+&x_3& &=&\\frac{119}{156}\\\\[3mm]\n  &x_3 &-&x_2& &=&\\frac{38}{91}\n  \\end{matrix}\n\\right .\n\\]\nLagra koefficientmatrisen som A och den beräknade lösningen i vektorvariabeln x och verifiera den genom att exekvera A*x. Kommentera resultatet.\n\n\n\nEn motorbåt färdas i en flod med strömt vatten. När den går med en given motorstyrka tar det fem timmar för den att färdas från punkt \\(A\\) till \\(B\\), vilket är en sträcka på 60 km mot strömmen. När den sedan åker tillbaka från \\(B\\) till \\(A\\), färdas den med strömmen; den färden tar fyra timmar med samma givna motorstyrka.\nTeckna ett ekvationssystem, som du löser med hjälp av Octave, som bestämmer dels båtens fart i vatten som inte är strömt (med den givna motorstyrkan) och dels vattenströmmens fart.\n\n\n\n\n\n\nSvar övning 303\n\n\n\n\n\nBåtens fart i oströmt vatten: \\(13.5\\) km/h\nStrömmens fart: \\(1.5\\) km/h\n\n\n\n\n\n\nOctave-koden i denna övning ska köras från en fil, och inte från konsolen\nDet går att skapa matriser av en godtycklig storlek med slumpade element. T ex så skapar randi([-100 100], 5, 5) en slumpad \\(5\\times 5\\)-matris med heltal mellan \\(-100\\) och \\(100\\):\noctave:1&gt; randi([-100 100], 5, 5)\nans =\n\n  -56   64   70   69  -17\n   30   98  -82   76  -61\n   10  -41   41  -59   63\n   93   12  -26   24  -45\n   84  -64  -73   49   93\n\nSkapa en \\(5\\times 5\\)-matris på detta sätt, och en tillhörande vektor av rätt storlek, med slumpade heltal mellan \\(-100\\) och \\(100\\). Låt Octave lösa det linjära ekvationssystem som matrisen och vektorn representerar.\nSkapa en en matris med tillhörande vektor som representerar ett linjärt ekvationssystem med \\(100\\) obekanta och \\(100\\) ekvationer. Tiden kan mätas med funktionerna tic och toc enligt följande:\n\n# Skapa matris och vektor\ntic();\n# Lös det linjära ekvationssystem matrisen och vektorn representerar.\n# OBS! Se till att resultatet INTE skrivs ut då den processen tar lång tid!\ntoc();\n# Tiden det tog att lösa systemet skrivs ut i konsolen automatiskt efter toc()\nHur lång tid tar det att lösa detta system av linjära ekvationer?\n\nUngefär hur stort ekvationssystem (lika många obekanta som ekvationer) kan lösas på\n\n1 sekund?\n5 sekunder?\n10 sekunder?\n\nPröva dig fram!",
    "crumbs": [
      "Home",
      "Programmering i matematik",
      "MatSpec",
      "Teori och övningar",
      "Octave: Lösning av linjära ekvationssystem"
    ]
  },
  {
    "objectID": "ma/ma-spec/programmering/teori-och-ovningar/lin-ekvationssystem-med-octave/index.html#teori",
    "href": "ma/ma-spec/programmering/teori-och-ovningar/lin-ekvationssystem-med-octave/index.html#teori",
    "title": "Octave: Lösning av linjära ekvationssystem",
    "section": "",
    "text": "Ett sätt att lösa ett linjära ekvationssystem i Octave är att först deklarera det som en koefficientmatris \\(A\\) och en vektor \\(\\vec{v}\\) enligt \\(A\\vec{x}=\\vec{v}\\) (här kommer vektorn \\(\\vec{x}\\) att utgöra den beräknade lösningsvektorn).\nFör att lösa ekvationssystemet \\(A\\vec{x}=\\vec{v}\\), där \\(A\\) och \\(\\vec{v}\\) är deklarerade så används “backslash-operatorn” enligt A \\ v.\nExempel\n\n\n\n\n\n\nLös följande ekvationssystem med Octave\n\\[\n\\left \\{\n\\begin{matrix*}[r]\nx_1&+&2x_2&=&-1\\\\\n2x_1&-&3x_2&=&12\n\\end{matrix*}\n\\right .\n\\]\nVi deklarerar koefficientmatrisen \\(A\\) och vektorn \\(\\vec{v}\\):\noctave:1&gt; A = [1 2 ; 2 -3];\noctave:2&gt; v = [-1 ; 12];\nDärefter så löses systemet:\noctave:3&gt; x = A \\ v\nx =\n\n   3\n  -2\ndär utmatningen innebär att \\(x_1=3\\) och \\(x_2=-2\\).\nJust i det här fallet blev lösningen heltal, men det kan bli såväl rationella som irrationella lösningar; man får då ha i åtanke att Octave jobbar med avrundade närmevärden och inte exakta tal (som går att approximera till rationella tal).",
    "crumbs": [
      "Home",
      "Programmering i matematik",
      "MatSpec",
      "Teori och övningar",
      "Octave: Lösning av linjära ekvationssystem"
    ]
  },
  {
    "objectID": "ma/ma-spec/programmering/teori-och-ovningar/lin-ekvationssystem-med-octave/index.html#övningar",
    "href": "ma/ma-spec/programmering/teori-och-ovningar/lin-ekvationssystem-med-octave/index.html#övningar",
    "title": "Octave: Lösning av linjära ekvationssystem",
    "section": "",
    "text": "Lös det linjära ekvationssystemet nedan med Octave.\n\\[\n\\left \\{\n\\begin{matrix*}[r]\nx&+&2y&+&3z&=&10\\\\\nx&+&y&-&z&=&4\\\\\n2x&-&y&+&z&=&5\n\\end{matrix*}\n\\right .\n\\]\nLagra koefficientmatrisen som A och den beräknade lösningen i vektorvariabeln x och verifiera den genom att exekvera A*x.\n\n\n\nStäll in Octave i rationellt läge genom att exekverar format rat. Lös sedan det linjära ekvationssystemet\n\\[\n\\left \\{\n  \\begin{matrix}\n  5x_1&-&x_2&+&3x_3&=&\\frac{1849}{1092}\\\\[3mm]\n  &x_1 &+&x_3& &=&\\frac{119}{156}\\\\[3mm]\n  &x_3 &-&x_2& &=&\\frac{38}{91}\n  \\end{matrix}\n\\right .\n\\]\nLagra koefficientmatrisen som A och den beräknade lösningen i vektorvariabeln x och verifiera den genom att exekvera A*x. Kommentera resultatet.\n\n\n\nEn motorbåt färdas i en flod med strömt vatten. När den går med en given motorstyrka tar det fem timmar för den att färdas från punkt \\(A\\) till \\(B\\), vilket är en sträcka på 60 km mot strömmen. När den sedan åker tillbaka från \\(B\\) till \\(A\\), färdas den med strömmen; den färden tar fyra timmar med samma givna motorstyrka.\nTeckna ett ekvationssystem, som du löser med hjälp av Octave, som bestämmer dels båtens fart i vatten som inte är strömt (med den givna motorstyrkan) och dels vattenströmmens fart.\n\n\n\n\n\n\nSvar övning 303\n\n\n\n\n\nBåtens fart i oströmt vatten: \\(13.5\\) km/h\nStrömmens fart: \\(1.5\\) km/h\n\n\n\n\n\n\nOctave-koden i denna övning ska köras från en fil, och inte från konsolen\nDet går att skapa matriser av en godtycklig storlek med slumpade element. T ex så skapar randi([-100 100], 5, 5) en slumpad \\(5\\times 5\\)-matris med heltal mellan \\(-100\\) och \\(100\\):\noctave:1&gt; randi([-100 100], 5, 5)\nans =\n\n  -56   64   70   69  -17\n   30   98  -82   76  -61\n   10  -41   41  -59   63\n   93   12  -26   24  -45\n   84  -64  -73   49   93\n\nSkapa en \\(5\\times 5\\)-matris på detta sätt, och en tillhörande vektor av rätt storlek, med slumpade heltal mellan \\(-100\\) och \\(100\\). Låt Octave lösa det linjära ekvationssystem som matrisen och vektorn representerar.\nSkapa en en matris med tillhörande vektor som representerar ett linjärt ekvationssystem med \\(100\\) obekanta och \\(100\\) ekvationer. Tiden kan mätas med funktionerna tic och toc enligt följande:\n\n# Skapa matris och vektor\ntic();\n# Lös det linjära ekvationssystem matrisen och vektorn representerar.\n# OBS! Se till att resultatet INTE skrivs ut då den processen tar lång tid!\ntoc();\n# Tiden det tog att lösa systemet skrivs ut i konsolen automatiskt efter toc()\nHur lång tid tar det att lösa detta system av linjära ekvationer?\n\nUngefär hur stort ekvationssystem (lika många obekanta som ekvationer) kan lösas på\n\n1 sekund?\n5 sekunder?\n10 sekunder?\n\nPröva dig fram!",
    "crumbs": [
      "Home",
      "Programmering i matematik",
      "MatSpec",
      "Teori och övningar",
      "Octave: Lösning av linjära ekvationssystem"
    ]
  },
  {
    "objectID": "ma/ma-spec/ovningar/matrisinvertering/index.html",
    "href": "ma/ma-spec/ovningar/matrisinvertering/index.html",
    "title": "Matrisinvertering: Extra övningar",
    "section": "",
    "text": "Radreducera matrisen \\[\n\\begin{bmatrix*}[r]\n  1 & 3 & 5 & 7 \\\\ 3 & 5 & 7 & 9 \\\\ 5 & 7 & 9 & 1\n\\end{bmatrix*}\n\\]\ntill reducerad trappstegsform och markera pivotkolonnerna.\n\n\n\n\n\n\nSvar\n\n\n\n\n\nDen reducerade trappstegsformen är\n\\[\n\\begin{bmatrix*}[r]\n1 & 0 & -1 & 0 \\\\ 0 & 1 & 2 & 0 \\\\ 0 & 0 & 0 & 1\n\\end{bmatrix*}\n\\]\n\n\n\n\n\n\nVi har ekvationssystemet \\[\n\\left\\{\n\\begin{matrix}\nx &+& 2y &+& z &=& -1 \\\\\n2x &+& 6y &&    &=& -2 \\\\\nx &+&  6y &+& z &=& \\phantom{-}3\n\\end{matrix}\n\\right .\n\\]\nBestäm lösningen till detta genom att teckna en koefficientmatris \\(A\\), en lösningsvektor \\(\\vec{v}\\) och en vektor för högerledet, \\(\\vec{b}\\). Invertera \\(A\\) och bestäm lösningsvektorn genom operationen \\(A^{-1}A\\vec{v}=A^{-1}\\vec{b}\\).\n\n\n\n\n\n\nSvar\n\n\n\n\n\n\\(x=-4\\), \\(y=1\\) och \\(z=1\\). Observera att det är övningen med matrisinvertering samt matrismultiplikation som är syftet, inte själva ekvationslösningen.\n\n\n\n\n\n\nOm vi har en \\(2\\times 2\\)-matris \\(A\\) enligt \\[\nA=\\begin{bmatrix}\na_{11} & a_{12} \\\\ a_{21} & a_{22}\n\\end{bmatrix}\n\\] så gäller att determinanten, \\(\\det A\\), beräknas enligt \\[\n\\det A = a_{11}a_{22}-a_{12}a_{21}\n\\]\nFör en \\(3\\times3\\)-matris gäller följande formel för determinanten:\n\\[\nA=\\begin{bmatrix}\na_{11} & a_{12} & a_{13} \\\\ a_{21} & a_{22} & a_{23} \\\\ a_{31} & a_{32} & a_{33}\n\\end{bmatrix}\n\\Rightarrow\\det A=\na_{11}\\det\\begin{bmatrix}\na_{22} & a_{23} \\\\ a_{32} & a_{33}\n\\end{bmatrix}\n-\na_{12}\\det\\begin{bmatrix}\na_{21} & a_{23} \\\\ a_{31} & a_{33}\n\\end{bmatrix}\n+\na_{13}\\det\\begin{bmatrix}\na_{21} & a_{22} \\\\ a_{31} & a_{32}\n\\end{bmatrix}\n\\] En av de saker determinanten berättar för oss är om en matris är singulär (och därmed inte går att invertera); determinanten är för dessa matriser noll.\nSkapa en Pythonfunktion som tar en \\(3\\times 3\\)-matris som argument och returnerar dess determinant. Matrisen kan implementeras som en 2D-lista; exempel på anrop till funktionen det([[1,2,3], [4,5,6], [7,8,9]]). Jämför ditt svar med Wolfram Alpha!\n\n\n\nMatrisinverteringar är ett tidskrävande arbete som kräver stor noggranhet, och som ligger till grund för ekvationssystemslösning. Det är mycket vanligt att datorer löser stora ekvationssystem, och därför behövs algoritmer för matrisinvertering kodas i program. Nedan visas pdeudokod för Gauss-Jordan-elimination. Skapa en Python-funktion som implementerar denna kod med listor.\nTips: Börja med att skapa funktioner för att byta plats på två rader, att addera en multipel av en rad till en annan och för att multiplicera en rad med ett tal; dvs funktioner som implementerar de elementära radoperationerna!\nFunktion INVERTERA(A):\n  # A är en nxn matris\n  # Returnerar A^-1 om den existerar, annars ett felmeddelande\n\n  # Skapa en förstorad matris [A|I]\n  I = Skapa en nxn identitetsmatris\n  AI = Skapa en nx2n matris genom att sätta ihop A och I horisontellt\n\n  # Applicera elementära radoperationer på [A|I] för att få den på formen [I|B]\n  För i från 1 till n:\n    # Hitta pivotelementet på rad i och kolumn i\n    pivot = AI[i][i]\n\n    # Kontrollera om pivotelementet är noll\n    Om pivot == 0:\n      # Hitta en annan rad j under rad i som har ett icke-noll element på kolumn i\n      j = i + 1\n      Medan j &lt;= n och AI[j][i] == 0:\n        j = j + 1\n      \n      # Om ingen sådan rad hittades, så är A inte inverterbar\n      Om j &gt; n:\n        Returnera \"Matrisen A är inte inverterbar\"\n      \n      # Annars, byt plats på rad i och rad j\n      Annars:\n        Byt rad i och rad j i AI\n    \n    # Dela rad i med pivotelementet för att få ett 1-tal på position i, i\n    För k från 1 till 2n:\n      AI[i][k] = AI[i][k] / pivot\n    \n    # Eliminera alla andra element på kolumn i genom att subtrahera lämpliga multipler av rad i från andra rader\n    För j från 1 till n:\n      Om j != i:\n        faktor = AI[j][i]\n        För k från 1 till 2n:\n          AI[j][k] = AI[j][k] - faktor * AI[i][k]\n  \n  # Extrahera matrisen B från den högra halvan av AI\n  B = Skapa en nxn matris\n  För i från 1 till n:\n    För j från 1 till n:\n      B[i][j] = AI[i][n+j]\n  \n  # Returnera B som är inversen av A\n  Returnera B",
    "crumbs": [
      "Home",
      "Matematik specialisering",
      "Matrisinvertering: Extra övningar"
    ]
  },
  {
    "objectID": "ma/ma-spec/ovningar/matrisinvertering/index.html#några-kompletterande-övningar",
    "href": "ma/ma-spec/ovningar/matrisinvertering/index.html#några-kompletterande-övningar",
    "title": "Matrisinvertering: Extra övningar",
    "section": "",
    "text": "Radreducera matrisen \\[\n\\begin{bmatrix*}[r]\n  1 & 3 & 5 & 7 \\\\ 3 & 5 & 7 & 9 \\\\ 5 & 7 & 9 & 1\n\\end{bmatrix*}\n\\]\ntill reducerad trappstegsform och markera pivotkolonnerna.\n\n\n\n\n\n\nSvar\n\n\n\n\n\nDen reducerade trappstegsformen är\n\\[\n\\begin{bmatrix*}[r]\n1 & 0 & -1 & 0 \\\\ 0 & 1 & 2 & 0 \\\\ 0 & 0 & 0 & 1\n\\end{bmatrix*}\n\\]\n\n\n\n\n\n\nVi har ekvationssystemet \\[\n\\left\\{\n\\begin{matrix}\nx &+& 2y &+& z &=& -1 \\\\\n2x &+& 6y &&    &=& -2 \\\\\nx &+&  6y &+& z &=& \\phantom{-}3\n\\end{matrix}\n\\right .\n\\]\nBestäm lösningen till detta genom att teckna en koefficientmatris \\(A\\), en lösningsvektor \\(\\vec{v}\\) och en vektor för högerledet, \\(\\vec{b}\\). Invertera \\(A\\) och bestäm lösningsvektorn genom operationen \\(A^{-1}A\\vec{v}=A^{-1}\\vec{b}\\).\n\n\n\n\n\n\nSvar\n\n\n\n\n\n\\(x=-4\\), \\(y=1\\) och \\(z=1\\). Observera att det är övningen med matrisinvertering samt matrismultiplikation som är syftet, inte själva ekvationslösningen.\n\n\n\n\n\n\nOm vi har en \\(2\\times 2\\)-matris \\(A\\) enligt \\[\nA=\\begin{bmatrix}\na_{11} & a_{12} \\\\ a_{21} & a_{22}\n\\end{bmatrix}\n\\] så gäller att determinanten, \\(\\det A\\), beräknas enligt \\[\n\\det A = a_{11}a_{22}-a_{12}a_{21}\n\\]\nFör en \\(3\\times3\\)-matris gäller följande formel för determinanten:\n\\[\nA=\\begin{bmatrix}\na_{11} & a_{12} & a_{13} \\\\ a_{21} & a_{22} & a_{23} \\\\ a_{31} & a_{32} & a_{33}\n\\end{bmatrix}\n\\Rightarrow\\det A=\na_{11}\\det\\begin{bmatrix}\na_{22} & a_{23} \\\\ a_{32} & a_{33}\n\\end{bmatrix}\n-\na_{12}\\det\\begin{bmatrix}\na_{21} & a_{23} \\\\ a_{31} & a_{33}\n\\end{bmatrix}\n+\na_{13}\\det\\begin{bmatrix}\na_{21} & a_{22} \\\\ a_{31} & a_{32}\n\\end{bmatrix}\n\\] En av de saker determinanten berättar för oss är om en matris är singulär (och därmed inte går att invertera); determinanten är för dessa matriser noll.\nSkapa en Pythonfunktion som tar en \\(3\\times 3\\)-matris som argument och returnerar dess determinant. Matrisen kan implementeras som en 2D-lista; exempel på anrop till funktionen det([[1,2,3], [4,5,6], [7,8,9]]). Jämför ditt svar med Wolfram Alpha!\n\n\n\nMatrisinverteringar är ett tidskrävande arbete som kräver stor noggranhet, och som ligger till grund för ekvationssystemslösning. Det är mycket vanligt att datorer löser stora ekvationssystem, och därför behövs algoritmer för matrisinvertering kodas i program. Nedan visas pdeudokod för Gauss-Jordan-elimination. Skapa en Python-funktion som implementerar denna kod med listor.\nTips: Börja med att skapa funktioner för att byta plats på två rader, att addera en multipel av en rad till en annan och för att multiplicera en rad med ett tal; dvs funktioner som implementerar de elementära radoperationerna!\nFunktion INVERTERA(A):\n  # A är en nxn matris\n  # Returnerar A^-1 om den existerar, annars ett felmeddelande\n\n  # Skapa en förstorad matris [A|I]\n  I = Skapa en nxn identitetsmatris\n  AI = Skapa en nx2n matris genom att sätta ihop A och I horisontellt\n\n  # Applicera elementära radoperationer på [A|I] för att få den på formen [I|B]\n  För i från 1 till n:\n    # Hitta pivotelementet på rad i och kolumn i\n    pivot = AI[i][i]\n\n    # Kontrollera om pivotelementet är noll\n    Om pivot == 0:\n      # Hitta en annan rad j under rad i som har ett icke-noll element på kolumn i\n      j = i + 1\n      Medan j &lt;= n och AI[j][i] == 0:\n        j = j + 1\n      \n      # Om ingen sådan rad hittades, så är A inte inverterbar\n      Om j &gt; n:\n        Returnera \"Matrisen A är inte inverterbar\"\n      \n      # Annars, byt plats på rad i och rad j\n      Annars:\n        Byt rad i och rad j i AI\n    \n    # Dela rad i med pivotelementet för att få ett 1-tal på position i, i\n    För k från 1 till 2n:\n      AI[i][k] = AI[i][k] / pivot\n    \n    # Eliminera alla andra element på kolumn i genom att subtrahera lämpliga multipler av rad i från andra rader\n    För j från 1 till n:\n      Om j != i:\n        faktor = AI[j][i]\n        För k från 1 till 2n:\n          AI[j][k] = AI[j][k] - faktor * AI[i][k]\n  \n  # Extrahera matrisen B från den högra halvan av AI\n  B = Skapa en nxn matris\n  För i från 1 till n:\n    För j från 1 till n:\n      B[i][j] = AI[i][n+j]\n  \n  # Returnera B som är inversen av A\n  Returnera B",
    "crumbs": [
      "Home",
      "Matematik specialisering",
      "Matrisinvertering: Extra övningar"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "CodeBubo Nest 🦉",
    "section": "",
    "text": "Under denna sajt samlar jag (se sidan About om vem “jag” är) en del av de presentationer, uppgifter, instruktioner och dokument som jag använder i min undervisning i matematik, fysik och programmering.\nSajten är under utbyggnad, och viss omstrukturering kan förekomma."
  },
  {
    "objectID": "index.html#hello-world",
    "href": "index.html#hello-world",
    "title": "CodeBubo Nest 🦉",
    "section": "",
    "text": "Under denna sajt samlar jag (se sidan About om vem “jag” är) en del av de presentationer, uppgifter, instruktioner och dokument som jag använder i min undervisning i matematik, fysik och programmering.\nSajten är under utbyggnad, och viss omstrukturering kan förekomma."
  }
]